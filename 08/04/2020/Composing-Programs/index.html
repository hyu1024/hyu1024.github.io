<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Programming," />





  <link rel="alternate" href="/atom.xml" title="HBlog" type="application/atom+xml" />






<meta name="description" content="About  Online textbook of CS 61A: Structure and Interpretation of Computer Programs by Prof. John DeNero from University of California, Berkeley. Preface  Welcome to Composing Programs, a free online">
<meta property="og:type" content="article">
<meta property="og:title" content="Composing Programs">
<meta property="og:url" content="http://yoursite.com/08/04/2020/Composing-Programs/index.html">
<meta property="og:site_name" content="HBlog">
<meta property="og:description" content="About  Online textbook of CS 61A: Structure and Interpretation of Computer Programs by Prof. John DeNero from University of California, Berkeley. Preface  Welcome to Composing Programs, a free online">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://composingprograms.com/img/call_expression.png">
<meta property="og:image" content="http://composingprograms.com/img/expression_tree.png">
<meta property="og:image" content="http://composingprograms.com/img/function_abs.png">
<meta property="og:image" content="http://composingprograms.com/img/function_print.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215341985.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215412798.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215437663.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215508978.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215531724.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215553644.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215613072.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215637725.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215705473.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215731077.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215810249.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206215849848.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206220110429.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206220138044.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206220209651.png">
<meta property="og:image" content="http://composingprograms.com/img/pi_sum.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206221358578.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206221447372.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206221544486.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206221753026.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206221834025.png">
<meta property="og:image" content="http://composingprograms.com/img/newton.png">
<meta property="og:image" content="http://composingprograms.com/img/curves.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222006416.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222107575.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222210261.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222305459.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222713997.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222808554.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222842994.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206222949749.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206223014148.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206223040022.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225321275.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225457395.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225624384.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225705039.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225806165.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206225906416.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230004637.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230054899.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230155509.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230251700.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230344409.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230449146.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230538522.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230748739.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206230900314.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231021214.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231135959.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231232752.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231349191.png">
<meta property="og:image" content="http://composingprograms.com/img/constraints.png">
<meta property="og:image" content="http://composingprograms.com/img/multiple_inheritance.png">
<meta property="og:image" content="http://composingprograms.com/img/fib.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231830660.png">
<meta property="og:image" content="http://composingprograms.com/img/fib_memo.png">
<meta property="og:image" content="http://yoursite.com/Users/brooklyn/Library/Application%20Support/typora-user-images/image-20200206231931893.png">
<meta property="og:image" content="http://composingprograms.com/img/set_trees.png">
<meta property="og:image" content="http://composingprograms.com/img/star.png">
<meta property="og:image" content="http://composingprograms.com/img/sier.png">
<meta property="og:image" content="http://composingprograms.com/img/factorial_machine.png">
<meta property="og:image" content="http://composingprograms.com/img/clientserver.png">
<meta property="og:image" content="http://composingprograms.com/img/deadlock.png">
<meta property="article:published_time" content="2020-04-08T10:53:12.480Z">
<meta property="article:modified_time" content="2020-04-08T11:03:06.091Z">
<meta property="article:author" content="H Yu">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://composingprograms.com/img/call_expression.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/08/04/2020/Composing-Programs/"/>





  <title>Composing Programs | HBlog</title>
  








<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/08/04/2020/Composing-Programs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="H Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Composing Programs</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-08T11:53:12+01:00">
                08-04-2020
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <font face="Superclarendon" size="18px">About</font>

<p>Online textbook of <em>CS 61A: Structure and Interpretation of Computer Programs</em> by <a href="https://denero.org" target="_blank" rel="noopener">Prof. John DeNero</a> from <a href="https://www.berkeley.edu" target="_blank" rel="noopener">University of California, Berkeley</a>.</p>
<font face="Superclarendon" size="18px">Preface</font>

<p>Welcome to <a href="http://www.composingprograms.com/" target="_blank" rel="noopener">Composing Programs</a>, a free online introduction to programming and computer science.</p>
<p>In the tradition of <a href="http://mitpress.mit.edu/sicp/" target="_blank" rel="noopener">SICP</a>, this text focuses on methods for abstraction, programming paradigms, and techniques for managing the complexity of large programs. These concepts are illustrated primarily using the <a href="http://www.python.org/" target="_blank" rel="noopener">Python 3</a> programming language.</p>
<p>In addition to reading the chapters below, you can apply your knowledge to the <a href="http://composingprograms.com/projects.html" target="_blank" rel="noopener">programming projects</a>that accompany the text and visualize program execution using the <a href="http://composingprograms.com/tutor.html" target="_blank" rel="noopener">Online Python Tutor</a>.</p>
<p><strong>Instructors</strong>: If you are interested in adapting any of these materials for your courses, please <a href="https://docs.google.com/forms/d/1lcDf-_y9t1oSDH_-HFz3UhUFouAX1518XeCMnlRISss/viewform" target="_blank" rel="noopener">fill out this short survey</a> so that we can support your efforts.</p>
<p><strong>Chapter 1: Building Abstractions with Functions</strong></p>
<p><a href="http://composingprograms.com/pages/11-getting-started.html" target="_blank" rel="noopener">1.1 Getting Started</a></p>
<p><a href="http://composingprograms.com/pages/12-elements-of-programming.html" target="_blank" rel="noopener">1.2 Elements of Programming</a></p>
<p><a href="http://composingprograms.com/pages/13-defining-new-functions.html" target="_blank" rel="noopener">1.3 Defining New Functions</a></p>
<p><a href="http://composingprograms.com/pages/14-designing-functions.html" target="_blank" rel="noopener">1.4 Designing Functions</a></p>
<p><a href="http://composingprograms.com/pages/15-control.html" target="_blank" rel="noopener">1.5 Control</a></p>
<p><a href="http://composingprograms.com/pages/16-higher-order-functions.html" target="_blank" rel="noopener">1.6 Higher-Order Functions</a></p>
<p><a href="http://composingprograms.com/pages/17-recursive-functions.html" target="_blank" rel="noopener">1.7 Recursive Functions</a></p>
<p><strong>Chapter 2: Building Abstractions with Data</strong></p>
<p><a href="http://composingprograms.com/pages/21-introduction.html" target="_blank" rel="noopener">2.1 Introduction</a></p>
<p><a href="http://composingprograms.com/pages/22-data-abstraction.html" target="_blank" rel="noopener">2.2 Data Abstraction</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html" target="_blank" rel="noopener">2.3 Sequences</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html" target="_blank" rel="noopener">2.4 Mutable Data</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html" target="_blank" rel="noopener">2.5 Object-Oriented Programming</a></p>
<p><a href="http://composingprograms.com/pages/26-implementing-classes-and-objects.html" target="_blank" rel="noopener">2.6 Implementing Classes and Objects</a></p>
<p><a href="http://composingprograms.com/pages/27-object-abstraction.html" target="_blank" rel="noopener">2.7 Object Abstraction</a></p>
<p><a href="http://composingprograms.com/pages/28-efficiency.html" target="_blank" rel="noopener">2.8 Efficiency</a></p>
<p><a href="http://composingprograms.com/pages/29-recursive-objects.html" target="_blank" rel="noopener">2.9 Recursive Objects</a></p>
<p><strong>Chapter 3: Interpreting Computer Programs</strong></p>
<p><a href="http://composingprograms.com/pages/31-introduction.html" target="_blank" rel="noopener">3.1 Introduction</a></p>
<p><a href="http://composingprograms.com/pages/32-functional-programming.html" target="_blank" rel="noopener">3.2 Functional Programming</a></p>
<p><a href="http://composingprograms.com/pages/33-exceptions.html" target="_blank" rel="noopener">3.3 Exceptions</a></p>
<p><a href="http://composingprograms.com/pages/34-interpreters-for-languages-with-combination.html" target="_blank" rel="noopener">3.4 Interpreters for Languages with Combination</a></p>
<p><a href="http://composingprograms.com/pages/35-interpreters-for-languages-with-abstraction.html" target="_blank" rel="noopener">3.5 Interpreters for Languages with Abstraction</a></p>
<p><strong>Chapter 4: Data Processing</strong></p>
<p><a href="http://composingprograms.com/pages/41-introduction.html" target="_blank" rel="noopener">4.1 Introduction</a></p>
<p><a href="http://composingprograms.com/pages/42-implicit-sequences.html" target="_blank" rel="noopener">4.2 Implicit Sequences</a></p>
<p><a href="http://composingprograms.com/pages/43-declarative-programming.html" target="_blank" rel="noopener">4.3 Declarative Programming</a></p>
<p><a href="http://composingprograms.com/pages/44-logic-programming.html" target="_blank" rel="noopener">4.4 Logic Programming</a></p>
<p><a href="http://composingprograms.com/pages/45-unification.html" target="_blank" rel="noopener">4.5 Unification</a></p>
<p><a href="http://composingprograms.com/pages/46-distributed-computing.html" target="_blank" rel="noopener">4.6 Distributed Computing</a></p>
<p><a href="http://composingprograms.com/pages/47-distributed-data-processing.html" target="_blank" rel="noopener">4.7 Distributed Data Processing</a></p>
<p><a href="http://composingprograms.com/pages/48-parallel-computing.html" target="_blank" rel="noopener">4.8 Parallel Computing</a></p>
<h1 id="Chapter-1-Building-Abstractions-with-Functions"><a href="#Chapter-1-Building-Abstractions-with-Functions" class="headerlink" title="Chapter 1: Building Abstractions with Functions"></a>Chapter 1: Building Abstractions with Functions</h1><h2 id="1-1-Getting-Started"><a href="#1-1-Getting-Started" class="headerlink" title="1.1  Getting Started"></a>1.1  Getting Started</h2><p>Computer science is a tremendously broad academic discipline. The areas of globally distributed systems, artificial intelligence, robotics, graphics, security, scientific computing, computer architecture, and dozens of emerging sub-fields all expand with new techniques and discoveries every year. The rapid progress of computer science has left few aspects of human life unaffected. Commerce, communication, science, art, leisure, and politics have all been reinvented as computational domains.</p>
<p>The high productivity of computer science is only possible because the discipline is built upon an elegant and powerful set of fundamental ideas. All computing begins with representing information, specifying logic to process it, and designing abstractions that manage the complexity of that logic. Mastering these fundamentals will require us to understand precisely how computers interpret computer programs and carry out computational processes.</p>
<p>These fundamental ideas have long been taught using the classic textbook <em>Structure and Interpretation of Computer Programs</em> (<a href="http://mitpress.mit.edu/sicp" target="_blank" rel="noopener">SICP</a>) by Harold Abelson and Gerald Jay Sussman with Julie Sussman. This text borrows heavily from that textbook, which the original authors have kindly licensed for adaptation and reuse under a Creative Commons license. These notes are published under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US" target="_blank" rel="noopener">Creative Commons attribution non-commericial share-alike license version 3</a>.</p>
<h3 id="1-1-1-Programming-in-Python"><a href="#1-1-1-Programming-in-Python" class="headerlink" title="1.1.1  Programming in Python"></a>1.1.1  Programming in Python</h3><blockquote>
<p>A language isn’t something you learn so much as something you join.</p>
<p>—<a href="http://arikaokrent.com/" target="_blank" rel="noopener">Arika Okrent</a></p>
</blockquote>
<p>In order to define computational processes, we need a programming language; preferably one that many humans and a great variety of computers can all understand. In this text, we will work primarily with the <a href="http://docs.python.org/py3k/" target="_blank" rel="noopener">Python</a> language.</p>
<p>Python is a widely used programming language that has recruited enthusiasts from many professions: web programmers, game engineers, scientists, academics, and even designers of new programming languages. When you learn Python, you join a million-person-strong community of developers. Developer communities are tremendously important institutions: members help each other solve problems, share their projects and experiences, and collectively develop software and tools. Dedicated members often achieve celebrity and widespread esteem for their contributions.</p>
<p>The Python language itself is the product of a <a href="http://www.python.org/psf/members/" target="_blank" rel="noopener">large volunteer community</a> that prides itself on the <a href="http://python.org/community/diversity/" target="_blank" rel="noopener">diversity</a>of its contributors. The language was conceived and first implemented by <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="noopener">Guido van Rossum</a> in the late 1980’s. The first chapter of his <a href="http://docs.python.org/py3k/tutorial/appetite.html" target="_blank" rel="noopener">Python 3 Tutorial</a> explains why Python is so popular, among the many languages available today.</p>
<p>Python excels as an instructional language because, throughout its history, Python’s developers have emphasized the human interpretability of Python code, reinforced by the <a href="http://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">Zen of Python</a> guiding principles of beauty, simplicity, and readability. Python is particularly appropriate for this text because its broad set of features support a variety of different programming styles, which we will explore. While there is no single way to program in Python, there are a set of conventions shared across the developer community that facilitate reading, understanding, and extending existing programs. Python’s combination of great flexibility and accessibility allows students to explore many programming paradigms, and then apply their newly acquired knowledge to thousands of <a href="http://pypi.python.org/pypi" target="_blank" rel="noopener">ongoing projects</a>.</p>
<p>These notes maintain the spirit of <a href="http://mitpress.mit.edu/sicp" target="_blank" rel="noopener">SICP</a> by introducing the features of Python in step with techniques for abstraction and a rigorous model of computation. In addition, these notes provide a practical introduction to Python programming, including some advanced language features and illustrative examples. Increasing your facility with Python should come naturally as you progress through the text.</p>
<p>The best way to get started programming in Python is to interact with the interpreter directly. This section describes how to install Python 3, initiate an interactive session with the interpreter, and start programming.</p>
<h3 id="1-1-2-Installing-Python-3"><a href="#1-1-2-Installing-Python-3" class="headerlink" title="1.1.2  Installing Python 3"></a>1.1.2  Installing Python 3</h3><p>As with all great software, Python has many versions. This text will use the most recent stable version of Python 3. Many computers have older versions of Python installed already, such as Python 2.7, but those will not match the descriptions in this text. You should be able to use any computer, but expect to install Python 3. (Don’t worry, Python is free.)</p>
<p>You can download Python 3 from the Python downloads page by clicking on the version that begins with 3 (not 2). Follow the instructions of the installer to complete installation.</p>
<p>For further guidance, try these video tutorials on <a href="http://www.youtube.com/watch?v=54-wuFsPi0w" target="_blank" rel="noopener">Windows installation</a> and <a href="http://www.youtube.com/watch?v=smHuBHxJdK8" target="_blank" rel="noopener">Mac installation</a> of Python 3, created by Julia Oh.</p>
<h3 id="1-1-3-Interactive-Sessions"><a href="#1-1-3-Interactive-Sessions" class="headerlink" title="1.1.3  Interactive Sessions"></a>1.1.3  Interactive Sessions</h3><p>In an interactive Python session, you type some Python <em>code</em> after the <em>prompt</em>, <code>&gt;&gt;&gt;</code>. The Python <em>interpreter</em> reads and executes what you type, carrying out your various commands.</p>
<p>To start an interactive session, run the Python 3 application. Type <code>python3</code> at a terminal prompt (Mac/Unix/Linux) or open the Python 3 application in Windows.</p>
<p>If you see the Python prompt, <code>&gt;&gt;&gt;</code>, then you have successfully started an interactive session. These notes depict example interactions using the prompt, followed by some input.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Interactive controls.</strong> Each session keeps a history of what you have typed. To access that history, press <code>-P</code> (previous) and <code>-N</code> (next). <code>-D</code> exits a session, which discards this history. Up and down arrows also cycle through history on some systems.</p>
<h3 id="1-1-4-First-Example"><a href="#1-1-4-First-Example" class="headerlink" title="1.1.4  First Example"></a>1.1.4  First Example</h3><blockquote>
<p>And, as imagination bodies forth</p>
<p>The forms of things to unknown, and the poet’s pen</p>
<p>Turns them to shapes, and gives to airy nothing</p>
<p>A local habitation and a name.</p>
<p>—William Shakespeare, A Midsummer-Night’s Dream</p>
</blockquote>
<p>To give Python a proper introduction, we will begin with an example that uses several language features. In the next section, we will start from scratch and build up the language piece by piece. Think of this section as a sneak preview of features to come.</p>
<p>Python has built-in support for a wide range of common programming activities, such as manipulating text, displaying graphics, and communicating over the Internet. The line of Python code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.request import urlopen</span><br></pre></td></tr></table></figure>
<p>is an <code>import</code> statement that loads functionality for accessing data on the Internet. In particular, it makes available a function called <code>urlopen</code>, which can access the content at a uniform resource locator (URL), a location of something on the Internet.</p>
<p><strong>Statements &amp; Expressions</strong>. Python code consists of expressions and statements. Broadly, computer programs consist of instructions to either</p>
<ol>
<li>Compute some value</li>
<li>Carry out some action</li>
</ol>
<p>Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations. When Python evaluates an expression, it computes the value of that expression. This chapter introduces several types of statements and expressions.</p>
<p>The assignment statement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; shakespeare &#x3D; urlopen(&#39;http:&#x2F;&#x2F;composingprograms.com&#x2F;shakespeare.txt&#39;)</span><br></pre></td></tr></table></figure>
<p>associates the name <code>shakespeare</code> with the value of the expression that follows <code>=</code>. That expression applies the <code>urlopen</code> function to a URL that contains the complete text of William Shakespeare’s 37 plays, all in a single text document.</p>
<p><strong>Functions</strong>. Functions encapsulate logic that manipulates data. <code>urlopen</code> is a function. A web address is a piece of data, and the text of Shakespeare’s plays is another. The process by which the former leads to the latter may be complex, but we can apply that process using only a simple expression because that complexity is tucked away within a function. Functions are the primary topic of this chapter.</p>
<p>Another assignment statement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; words &#x3D; set(shakespeare.read().decode().split())</span><br></pre></td></tr></table></figure>
<p>associates the name <code>words</code> to the set of all unique words that appear in Shakespeare’s plays, all 33,721 of them. The chain of commands to <code>read</code>, <code>decode</code>, and <code>split</code>, each operate on an intermediate computational entity: we <code>read</code> the data from the opened URL, then <code>decode</code> the data into text, and finally <code>split</code> the text into words. All of those words are placed in a <code>set</code>.</p>
<p><strong>Objects</strong>. A <code>set</code> is a type of object, one that supports set operations like computing intersections and membership. An object seamlessly bundles together data and the logic that manipulates that data, in a way that manages the complexity of both. Objects are the primary topic of Chapter 2. Finally, the expression</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;w for w in words if len(w) &#x3D;&#x3D; 6 and w[::-1] in words&#125;</span><br><span class="line">&#123;&#39;redder&#39;, &#39;drawer&#39;, &#39;reward&#39;, &#39;diaper&#39;, &#39;repaid&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>is a compound expression that evaluates to the set of all Shakespearian words that are simultaneously a word spelled in reverse. The cryptic notation <code>w[::-1]</code> enumerates each letter in a word, but the <code>-1</code>dictates to step backwards. When you enter an expression in an interactive session, Python prints its value on the following line.</p>
<p><strong>Interpreters</strong>. Evaluating compound expressions requires a precise procedure that interprets code in a predictable way. A program that implements such a procedure, evaluating compound expressions, is called an interpreter. The design and implementation of interpreters is the primary topic of Chapter 3.</p>
<p>When compared with other computer programs, interpreters for programming languages are unique in their generality. Python was not designed with Shakespeare in mind. However, its great flexibility allowed us to process a large amount of text with only a few statements and expressions.</p>
<p>In the end, we will find that all of these core concepts are closely related: functions are objects, objects are functions, and interpreters are instances of both. However, developing a clear understanding of each of these concepts and their role in organizing code is critical to mastering the art of programming.</p>
<h3 id="1-1-5-Errors"><a href="#1-1-5-Errors" class="headerlink" title="1.1.5  Errors"></a>1.1.5  Errors</h3><p>Python is waiting for your command. You are encouraged to experiment with the language, even though you may not yet know its full vocabulary and structure. However, be prepared for errors. While computers are tremendously fast and flexible, they are also extremely rigid. The nature of computers is described in <a href="http://web.stanford.edu/class/cs101/code-1-introduction.html" target="_blank" rel="noopener">Stanford’s introductory course</a> as</p>
<blockquote>
<p>The fundamental equation of computers is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computer &#x3D; powerful + stupid</span><br></pre></td></tr></table></figure>
<p>Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple.</p>
<p>Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer lacks anything like real insight … it’s nothing like the HAL 9000 from the movies. If nothing else, you should not be intimidated by the computer as if it’s some sort of brain. It’s very mechanical underneath it all.</p>
<p>Programming is about a person using their real insight to build something useful, constructed out of these teeny, simple little operations that the computer can do.</p>
<p>—Francisco Cai and Nick Parlante, Stanford CS101</p>
</blockquote>
<p>The rigidity of computers will immediately become apparent as you experiment with the Python interpreter: even the smallest spelling and formatting changes will cause unexpected output and errors.</p>
<p>Learning to interpret errors and diagnose the cause of unexpected errors is called <em>debugging</em>. Some guiding principles of debugging are:</p>
<ol>
<li><strong>Test incrementally</strong>: Every well-written program is composed of small, modular components that can be tested individually. Try out everything you write as soon as possible to identify problems early and gain confidence in your components.</li>
<li><strong>Isolate errors</strong>: An error in the output of a statement can typically be attributed to a particular modular component. When trying to diagnose a problem, trace the error to the smallest fragment of code you can before trying to correct it.</li>
<li><strong>Check your assumptions</strong>: Interpreters do carry out your instructions to the letter — no more and no less. Their output is unexpected when the behavior of some code does not match what the programmer believes (or assumes) that behavior to be. Know your assumptions, then focus your debugging effort on verifying that your assumptions actually hold.</li>
<li><strong>Consult others</strong>: You are not alone! If you don’t understand an error message, ask a friend, instructor, or search engine. If you have isolated an error, but can’t figure out how to correct it, ask someone else to take a look. A lot of valuable programming knowledge is shared in the process of group problem solving.</li>
</ol>
<p>Incremental testing, modular design, precise assumptions, and teamwork are themes that persist throughout this text. Hopefully, they will also persist throughout your computer science career.</p>
<h2 id="1-2-Elements-of-Programming"><a href="#1-2-Elements-of-Programming" class="headerlink" title="1.2  Elements of Programming"></a>1.2  Elements of Programming</h2><p>A programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about computational processes. Programs serve to communicate those ideas among the members of a programming community. Thus, programs must be written for people to read, and only incidentally for machines to execute.</p>
<p>When we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three such mechanisms:</p>
<ul>
<li><strong>primitive expressions and statements</strong>, which represent the simplest building blocks that the language provides,</li>
<li><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li>
<li><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.</li>
</ul>
<p>In programming, we deal with two kinds of elements: functions and data. (Soon we will discover that they are really not so distinct.) Informally, data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.</p>
<h3 id="1-2-1-Expressions"><a href="#1-2-1-Expressions" class="headerlink" title="1.2.1  Expressions"></a>1.2.1  Expressions</h3><p><strong>Video:</strong> Show Hide</p>
<p>Having experimented with the full Python interpreter in the previous section, we now start anew, methodically developing the Python language element by element. Be patient if the examples seem simplistic — more exciting material is soon to come.</p>
<p>We begin with primitive expressions. One kind of primitive expression is a number. More precisely, the expression that you type consists of the numerals that represent the number in base 10.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 42</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<p>Expressions representing numbers may be combined with mathematical operators to form a compound expression, which the interpreter will evaluate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; -1 - -1</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 1&#x2F;2 + 1&#x2F;4 + 1&#x2F;8 + 1&#x2F;16 + 1&#x2F;32 + 1&#x2F;64 + 1&#x2F;128</span><br><span class="line">0.9921875</span><br></pre></td></tr></table></figure>
<p>These mathematical expressions use <em>infix</em> notation, where the <em>operator</em> (e.g., <code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code>) appears in between the <em>operands</em> (numbers). Python includes many ways to form compound expressions. Rather than attempt to enumerate them all immediately, we will introduce new expression forms as we go, along with the language features that they support.</p>
<h3 id="1-2-2-Call-Expressions"><a href="#1-2-2-Call-Expressions" class="headerlink" title="1.2.2  Call Expressions"></a>1.2.2  Call Expressions</h3><p><strong>Video:</strong> Show Hide</p>
<p>The most important kind of compound expression is a <em>call expression</em>, which applies a function to some arguments. Recall from algebra that the mathematical notion of a function is a mapping from some input arguments to an output value. For instance, the <code>max</code> function maps its inputs to a single output, which is the largest of the inputs. The way in which Python expresses function application is the same as in conventional mathematics.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(7.5, 9.5)</span><br><span class="line">9.5</span><br></pre></td></tr></table></figure>
<p>This call expression has subexpressions: the <em>operator</em> is an expression that precedes parentheses, which enclose a comma-delimited list of <em>operand</em> expressions.</p>
<p><img src="http://composingprograms.com/img/call_expression.png" alt="img"></p>
<p>The operator specifies a <em>function</em>. When this call expression is evaluated, we say that the function <code>max</code> is <em>called</em> with <em>arguments</em> 7.5 and 9.5, and <em>returns</em> a <em>value</em> of 9.5.</p>
<p>The order of the arguments in a call expression matters. For instance, the function <code>pow</code> raises its first argument to the power of its second argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(100, 2)</span><br><span class="line">10000</span><br><span class="line">&gt;&gt;&gt; pow(2, 100)</span><br><span class="line">1267650600228229401496703205376</span><br></pre></td></tr></table></figure>
<p>Function notation has three principal advantages over the mathematical convention of infix notation. First, functions may take an arbitrary number of arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(1, -2, 3, -4)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>No ambiguity can arise, because the function name always precedes its arguments.</p>
<p>Second, function notation extends in a straightforward way to <em>nested</em> expressions, where the elements are themselves compound expressions. In nested call expressions, unlike compound infix expressions, the structure of the nesting is entirely explicit in the parentheses.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(min(1, -2), min(pow(3, 5), -4))</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<p>There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Python interpreter can evaluate. However, humans quickly get confused by multi-level nesting. An important role for you as a programmer is to structure expressions so that they remain interpretable by yourself, your programming partners, and other people who may read your expressions in the future.</p>
<p>Third, mathematical notation has a great variety of forms: multiplication appears between terms, exponents appear as superscripts, division as a horizontal bar, and a square root as a roof with slanted siding. Some of this notation is very hard to type! However, all of this complexity can be unified via the notation of call expressions. While Python supports common mathematical operators using infix notation (like <code>+</code> and <code>-</code>), any operator can be expressed as a function with a name.</p>
<h3 id="1-2-3-Importing-Library-Functions"><a href="#1-2-3-Importing-Library-Functions" class="headerlink" title="1.2.3  Importing Library Functions"></a>1.2.3  Importing Library Functions</h3><p>Python defines a very large number of functions, including the operator functions mentioned in the preceding section, but does not make all of their names available by default. Instead, it organizes the functions and other quantities that it knows about into modules, which together comprise the Python Library. To use these elements, one imports them. For example, the <code>math</code> module provides a variety of familiar mathematical functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import sqrt</span><br><span class="line">&gt;&gt;&gt; sqrt(256)</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure>
<p>and the <code>operator</code> module provides access to functions corresponding to infix operators:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub, mul</span><br><span class="line">&gt;&gt;&gt; add(14, 28)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; sub(100, mul(7, add(8, 4)))</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>An <code>import</code> statement designates a module name (e.g., <code>operator</code> or <code>math</code>), and then lists the named attributes of that module to import (e.g., <code>sqrt</code>). Once a function is imported, it can be called multiple times.</p>
<p>There is no difference between using these operator functions (e.g., <code>add</code>) and the operator symbols themselves (e.g., <code>+</code>). Conventionally, most programmers use symbols and infix notation to express simple arithmetic.</p>
<p>The <a href="http://docs.python.org/py3k/library/index.html" target="_blank" rel="noopener">Python 3 Library Docs</a> list the functions defined by each module, such as the <a href="http://docs.python.org/py3k/library/math.html" target="_blank" rel="noopener">math module</a>. However, this documentation is written for developers who know the whole language well. For now, you may find that experimenting with a function tells you more about its behavior than reading the documentation. As you become familiar with the Python language and vocabulary, this documentation will become a valuable reference source.</p>
<h3 id="1-2-4-Names-and-the-Environment"><a href="#1-2-4-Names-and-the-Environment" class="headerlink" title="1.2.4  Names and the Environment"></a>1.2.4  Names and the Environment</h3><p><strong>Video:</strong> Show Hide</p>
<p>A critical aspect of a programming language is the means it provides for using names to refer to computational objects. If a value has been given a name, we say that the name <em>binds</em> to the value.</p>
<p>In Python, we can establish new bindings using the assignment statement, which contains a name to the left of <code>=</code> and a value to the right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; radius &#x3D; 10</span><br><span class="line">&gt;&gt;&gt; radius</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; 2 * radius</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>Names are also bound via <code>import</code> statements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import pi</span><br><span class="line">&gt;&gt;&gt; pi * 71 &#x2F; 223</span><br><span class="line">1.0002380197528042</span><br></pre></td></tr></table></figure>
<p>The <code>=</code> symbol is called the <em>assignment</em> operator in Python (and many other languages). Assignment is our simplest means of <em>abstraction</em>, for it allows us to use simple names to refer to the results of compound operations, such as the <code>area</code> computed above. In this way, complex programs are constructed by building, step by step, computational objects of increasing complexity.</p>
<p>The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an <em>environment</em>.</p>
<p>Names can also be bound to functions. For instance, the name <code>max</code> is bound to the max function we have been using. Functions, unlike numbers, are tricky to render as text, so Python prints an identifying description instead, when asked to describe a function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure>
<p>We can use assignment statements to give new names to existing functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>And successive assignment statements can rebind a name to a new value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>In Python, names are often called <em>variable names</em> or <em>variables</em> because they can be bound to different values in the course of executing a program. When a name is bound to a new value through assignment, it is no longer bound to any previous value. One can even bind built-in names to new values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max &#x3D; 5</span><br><span class="line">&gt;&gt;&gt; max</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>After assigning <code>max</code> to 5, the name <code>max</code> is no longer bound to a function, and so attempting to call <code>max(2, 3, 4)</code> will cause an error.</p>
<p>When executing an assignment statement, Python evaluates the expression to the right of <code>=</code> before changing the binding to the name on the left. Therefore, one can refer to a name in right-side expression, even if it is the name to be bound by the assignment statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; x &#x3D; x + 1</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>We can also assign multiple values to multiple names in a single statement, where names on the left of <code>=</code>and expressions on the right of <code>=</code> are separated by commas.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; area, circumference &#x3D; pi * radius * radius, 2 * pi * radius</span><br><span class="line">&gt;&gt;&gt; area</span><br><span class="line">314.1592653589793</span><br><span class="line">&gt;&gt;&gt; circumference</span><br><span class="line">62.83185307179586</span><br></pre></td></tr></table></figure>
<p>Changing the value of one name does not affect other names. Below, even though the name <code>area</code> was bound to a value defined originally in terms of <code>radius</code>, the value of <code>area</code> has not changed. Updating the value of <code>area</code> requires another assignment statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; radius &#x3D; 11</span><br><span class="line">&gt;&gt;&gt; area</span><br><span class="line">314.1592653589793</span><br><span class="line">&gt;&gt;&gt; area &#x3D; pi * radius * radius</span><br><span class="line">380.132711084365</span><br></pre></td></tr></table></figure>
<p>With multiple assignment, <em>all</em> expressions to the right of <code>=</code> are evaluated before <em>any</em> names to the left are bound to those values. As a result of this rule, swapping the values bound to two names can be performed in a single statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y &#x3D; 3, 4.5</span><br><span class="line">&gt;&gt;&gt; y, x &#x3D; x, y</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">4.5</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-Evaluating-Nested-Expressions"><a href="#1-2-5-Evaluating-Nested-Expressions" class="headerlink" title="1.2.5  Evaluating Nested Expressions"></a>1.2.5  Evaluating Nested Expressions</h3><p>One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating nested call expressions, the interpreter is itself following a procedure.</p>
<p>To evaluate a call expression, Python will do the following:</p>
<ol>
<li>Evaluate the operator and operand subexpressions, then</li>
<li>Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.</li>
</ol>
<p>Even this simple procedure illustrates some important points about processes in general. The first step dictates that in order to accomplish the evaluation process for a call expression we must first evaluate other expressions. Thus, the evaluation procedure is <em>recursive</em> in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.</p>
<p>For example, evaluating</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sub(pow(2, add(1, 10)), pow(2, 5))</span><br><span class="line">2016</span><br></pre></td></tr></table></figure>
<p>requires that this evaluation procedure be applied four times. If we draw each expression that we evaluate, we can visualize the hierarchical structure of this process.</p>
<p><img src="http://composingprograms.com/img/expression_tree.png" alt="img"></p>
<p>This illustration is called an <em>expression tree</em>. In computer science, trees conventionally grow from the top down. The objects at each point in a tree are called nodes; in this case, they are expressions paired with their values.</p>
<p>Evaluating its root, the full expression at the top, requires first evaluating the branches that are its subexpressions. The leaf expressions (that is, nodes with no branches stemming from them) represent either functions or numbers. The interior nodes have two parts: the call expression to which our evaluation rule is applied, and the result of that expression. Viewing evaluation in terms of this tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels.</p>
<p>Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not call expressions, but primitive expressions such as numerals (e.g., 2) and names (e.g., <code>add</code>). We take care of the primitive cases by stipulating that</p>
<ul>
<li>A numeral evaluates to the number it names,</li>
<li>A name evaluates to the value associated with that name in the current environment.</li>
</ul>
<p>Notice the important role of an environment in determining the meaning of the symbols in expressions. In Python, it is meaningless to speak of the value of an expression such as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(x, 1)</span><br></pre></td></tr></table></figure>
<p>without specifying any information about the environment that would provide a meaning for the name <code>x</code>(or even for the name <code>add</code>). Environments provide the context in which evaluation takes place, which plays an important role in our understanding of program execution.</p>
<p>This evaluation procedure does not suffice to evaluate all Python code, only call expressions, numerals, and names. For instance, it does not handle assignment statements. Executing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>does not return a value nor evaluate a function on some arguments, since the purpose of assignment is instead to bind a name to a value. In general, statements are not evaluated but <em>executed</em>; they do not produce a value but instead make some change. Each type of expression or statement has its own evaluation or execution procedure.</p>
<p>A pedantic note: when we say that “a numeral evaluates to a number,” we actually mean that the Python interpreter evaluates a numeral to a number. It is the interpreter which endows meaning to the programming language. Given that the interpreter is a fixed program that always behaves consistently, we can say that numerals (and expressions) themselves evaluate to values in the context of Python programs.</p>
<h3 id="1-2-6-The-Non-Pure-Print-Function"><a href="#1-2-6-The-Non-Pure-Print-Function" class="headerlink" title="1.2.6  The Non-Pure Print Function"></a>1.2.6  The Non-Pure Print Function</h3><p><strong>Video:</strong> Show Hide</p>
<p>Throughout this text, we will distinguish between two types of functions.</p>
<p><strong>Pure functions.</strong> Functions have some input (their arguments) and return some output (the result of applying them). The built-in function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-2)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>can be depicted as a small machine that takes input and produces output.</p>
<p><img src="http://composingprograms.com/img/function_abs.png" alt="img"></p>
<p>The function <code>abs</code> is <em>pure</em>. Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.</p>
<p><strong>Non-pure functions.</strong> In addition to returning a value, applying a non-pure function can generate <em>side effects</em>, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the <code>print</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(1, 2, 3)</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p>While <code>print</code> and <code>abs</code> may appear to be similar in these examples, they work in fundamentally different ways. The value that <code>print</code> returns is always <code>None</code>, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value <code>None</code>. In the case of <code>print</code>, the function itself is printing output as a side effect of being called.</p>
<p><img src="http://composingprograms.com/img/function_print.png" alt="img"></p>
<p>A nested expression of calls to <code>print</code> highlights the non-pure character of the function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(print(1), print(2))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">None None</span><br></pre></td></tr></table></figure>
<p>If you find this output to be unexpected, draw an expression tree to clarify why evaluating this expression produces this peculiar output.</p>
<p>Be careful with <code>print</code>! The fact that it returns <code>None</code> means that it <em>should not</em> be the expression in an assignment statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; two &#x3D; print(2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(two)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>Pure functions are restricted in that they cannot have side effects or change behavior over time. Imposing these restrictions yields substantial benefits. First, pure functions can be composed more reliably into compound call expressions. We can see in the non-pure function example above that <code>print</code>does not return a useful result when used in an operand expression. On the other hand, we have seen that functions such as <code>max</code>, <code>pow</code> and <code>sqrt</code> can be used effectively in nested expressions.</p>
<p>Second, pure functions tend to be simpler to test. A list of arguments will always lead to the same return value, which can be compared to the expected return value. Testing is discussed in more detail later in this chapter.</p>
<p>Third, Chapter 4 will illustrate that pure functions are essential for writing <em>concurrent</em> programs, in which multiple call expressions may be evaluated simultaneously.</p>
<p>By contrast, Chapter 2 investigates a range of non-pure functions and describes their uses.</p>
<p>For these reasons, we concentrate heavily on creating and using pure functions in the remainder of this chapter. The <code>print</code> function is only used so that we can see the intermediate results of computations.</p>
<h2 id="1-3-Defining-New-Functions"><a href="#1-3-Defining-New-Functions" class="headerlink" title="1.3  Defining New Functions"></a>1.3  Defining New Functions</h2><p><strong>Video:</strong> Show Hide</p>
<p>We have identified in Python some of the elements that must appear in any powerful programming language:</p>
<ol>
<li>Numbers and arithmetic operations are <em>primitive</em> built-in data values and functions.</li>
<li>Nested function application provides a means of <em>combining</em> operations.</li>
<li>Binding names to values provides a limited means of <em>abstraction</em>.</li>
</ol>
<p>Now we will learn about <em>function definitions</em>, a much more powerful abstraction technique by which a name can be bound to compound operation, which can then be referred to as a unit.</p>
<p>We begin by examining how to express the idea of <em>squaring</em>. We might say, “To square something, multiply it by itself.” This is expressed in Python as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return mul(x, x)</span><br></pre></td></tr></table></figure>
<p>which defines a new function that has been given the name <code>square</code>. This user-defined function is not built into the interpreter. It represents the compound operation of multiplying something by itself. The <code>x</code> in this definition is called a <em>formal parameter</em>, which provides a name for the thing to be multiplied. The definition creates this user-defined function and associates it with the name <code>square</code>.</p>
<p><strong>How to define a function.</strong> Function definitions consist of a <code>def</code> statement that indicates a <code>and a comma-separated list of named</code>, then a <code>return</code> statement, called the function body, that specifies the `` of the function, which is an expression to be evaluated whenever the function is applied:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    return &lt;return expression&gt;</span><br></pre></td></tr></table></figure>
<p>The second line <em>must</em> be indented — most programmers use four spaces to indent. The return expression is not evaluated right away; it is stored as part of the newly defined function and evaluated only when the function is eventually applied.</p>
<p>Having defined <code>square</code>, we can apply it with a call expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square(21)</span><br><span class="line">441</span><br><span class="line">&gt;&gt;&gt; square(add(2, 5))</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; square(square(3))</span><br><span class="line">81</span><br></pre></td></tr></table></figure>
<p>We can also use <code>square</code> as a building block in defining other functions. For example, we can easily define a function <code>sum_squares</code> that, given any two numbers as arguments, returns the sum of their squares:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_squares(x, y):</span><br><span class="line">        return add(square(x), square(y))</span><br><span class="line">&gt;&gt;&gt; sum_squares(3, 4)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>User-defined functions are used in exactly the same way as built-in functions. Indeed, one cannot tell from the definition of <code>sum_squares</code> whether <code>square</code> is built into the interpreter, imported from a module, or defined by the user.</p>
<p>Both <code>def</code> statements and assignment statements bind names to values, and any existing bindings are lost. For example, <code>g</code> below first refers to a function of no arguments, then a number, and then a different function of two arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def g():</span><br><span class="line">        return 1</span><br><span class="line">&gt;&gt;&gt; g()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; g &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; def g(h, i):</span><br><span class="line">        return h + i</span><br><span class="line">&gt;&gt;&gt; g(1, 2)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-Environments"><a href="#1-3-1-Environments" class="headerlink" title="1.3.1  Environments"></a>1.3.1  Environments</h3><p><strong>Video:</strong> Show Hide</p>
<p>Our subset of Python is now complex enough that the meaning of programs is non-obvious. What if a formal parameter has the same name as a built-in function? Can two functions share names without confusion? To resolve such questions, we must describe environments in more detail.</p>
<p>An environment in which an expression is evaluated consists of a sequence of <em>frames</em>, depicted as boxes. Each frame contains <em>bindings</em>, each of which associates a name with its corresponding value. There is a single <em>global</em> frame. Assignment and import statements add entries to the first frame of the current environment. So far, our environment consists only of the global frame.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line">tau = <span class="number">2</span> * pi</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215341985.png" alt="image-20200206215341985" style="zoom:50%;"></p>
<p>This <em>environment diagram</em> shows the bindings of the current environment, along with the values to which names are bound. The environment diagrams in this text are interactive: you can step through the lines of the small program on the left to see the state of the environment evolve on the right. You can also click on the “Edit code in Online Python Tutor” link to load the example into the <a href="http://composingprograms.com/tutor.html" target="_blank" rel="noopener">Online Python Tutor</a>, a tool created by <a href="http://www.pgbovine.net/" target="_blank" rel="noopener">Philip Guo</a> for generating these environment diagrams. You are encouraged to create examples yourself and study the resulting environment diagrams.</p>
<p>Functions appear in environment diagrams as well. An <code>import</code> statement binds a name to a built-in function. A <code>def</code> statement binds a name to a user-defined function created by the definition. The resulting environment after importing <code>mul</code> and defining <code>square</code> appears below:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215412798.png" alt="image-20200206215412798"></p>
<p>Each function is a line that starts with <code>func</code>, followed by the function name and formal parameters. Built-in functions such as <code>mul</code> do not have formal parameter names, and so <code>...</code> is always used instead.</p>
<p>The name of a function is repeated twice, once in the frame and again as part of the function itself. The name appearing in the function is called the <em>intrinsic name</em>. The name in a frame is a <em>bound name</em>. There is a difference between the two: different names may refer to the same function, but that function itself has only one intrinsic name.</p>
<p>The name bound to a function in a frame is the one used during evaluation. The intrinsic name of a function does not play a role in evaluation. Step through the example below using the <em>Forward</em> button to see that once the name <code>max</code> is bound to the value 3, it can no longer be used as a function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = max</span><br><span class="line">max = <span class="number">3</span></span><br><span class="line">result = f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">max(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># Causes an error</span></span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215437663.png" alt="image-20200206215437663"></p>
<p>The error message <code>TypeError: &#39;int&#39; object is not callable</code> is reporting that the name <code>max</code> (currently bound to the number 3) is an integer and not a function. Therefore, it cannot be used as the operator in a call expression.</p>
<p><strong>Function Signatures.</strong> Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined function <code>square</code> takes only <code>x</code>; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function’s signature.</p>
<p>The function <code>max</code> can take an arbitrary number of arguments. It is rendered as <code>max(...)</code>. Regardless of the number of arguments taken, all built-in functions will be rendered as <code>(...)</code>, because these primitive functions were never explicitly defined.</p>
<h3 id="1-3-2-Calling-User-Defined-Functions"><a href="#1-3-2-Calling-User-Defined-Functions" class="headerlink" title="1.3.2  Calling User-Defined Functions"></a>1.3.2  Calling User-Defined Functions</h3><p>To evaluate a call expression whose operator names a user-defined function, the Python interpreter follows a computational process. As with any call expression, the interpreter evaluates the operator and operand expressions, and then applies the named function to the resulting arguments.</p>
<p>Applying a user-defined function introduces a second <em>local</em> frame, which is only accessible to that function. To apply a user-defined function to some arguments:</p>
<ol>
<li>Bind the arguments to the names of the function’s formal parameters in a new <em>local</em> frame.</li>
<li>Execute the body of the function in the environment that starts with this frame.</li>
</ol>
<p>The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else. Each instance of a function application has its own independent local frame.</p>
<p>To illustrate an example in detail, several steps of the environment diagram for the same example are depicted below. After executing the first import statement, only the name <code>mul</code> is bound in the global frame.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br><span class="line">square(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215508978.png" alt="image-20200206215508978"></p>
<p>First, the definition statement for the function <code>square</code> is executed. Notice that the entire <code>def</code> statement is processed in a single step. The body of a function is not executed until the function is called (not when it is defined).</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215531724.png" alt="image-20200206215531724"></p>
<p>Next, The <code>square</code> function is called with the argument <code>-2</code>, and so a new frame is created with the formal parameter <code>x</code> bound to the value <code>-2</code>.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215553644.png" alt="image-20200206215553644"></p>
<p>Then, the name <code>x</code> is looked up in the current environment, which consists of the two frames shown. In both occurrences, <code>x</code> evaluates to <code>-2</code>, and so the <code>square</code> function returns 4.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215613072.png" alt="image-20200206215613072" style="zoom:50%;"></p>
<p>The “Return value” in the <code>square()</code> frame is not a name binding; instead it indicates the value returned by the function call that created the frame.</p>
<p>Even in this simple example, two different environments are used. The top-level expression <code>square(-2)</code> is evaluated in the global environment, while the return expression <code>mul(x, x)</code> is evaluated in the environment created for by calling <code>square</code>. Both <code>x</code> and <code>mul</code> are bound in this environment, but in different frames.</p>
<p>The order of frames in an environment affects the value returned by looking up a name in an expression. We stated previously that a name is evaluated to the value associated with that name in the current environment. We can now be more precise:</p>
<p><strong>Name Evaluation.</strong> A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.</p>
<p>Our conceptual framework of environments, names, and functions constitutes a <em>model of evaluation</em>; while some mechanical details are still unspecified (e.g., how a binding is implemented), our model does precisely and correctly describe how the interpreter evaluates call expressions. In Chapter 3 we will see how this model can serve as a blueprint for implementing a working interpreter for a programming language.</p>
<h3 id="1-3-3-Example-Calling-a-User-Defined-Function"><a href="#1-3-3-Example-Calling-a-User-Defined-Function" class="headerlink" title="1.3.3  Example: Calling a User-Defined Function"></a>1.3.3  Example: Calling a User-Defined Function</h3><p>Let us again consider our two simple function definitions and illustrate the process that evaluates a call expression for a user-defined function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_squares</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> add(square(x), square(y))</span><br><span class="line"></span><br><span class="line">result = sum_squares(<span class="number">5</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215637725.png" alt="image-20200206215637725" style="zoom:50%;"></p>
<p>Python first evaluates the name <code>sum_squares</code>, which is bound to a user-defined function in the global frame. The primitive numeric expressions 5 and 12 evaluate to the numbers they represent.</p>
<p>Next, Python applies <code>sum_squares</code>, which introduces a local frame that binds x to 5 and y to 12.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215705473.png" alt="image-20200206215705473" style="zoom:50%;"></p>
<p>The body of <code>sum_squares</code> contains this call expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  add     (  square(x)  ,  square(y)  )</span><br><span class="line">________     _________     _________</span><br><span class="line">operator     operand 0     operand 1</span><br></pre></td></tr></table></figure>
<p>All three subexpressions are evaluated in the current environment, which begins with the frame labeled <code>sum_squares()</code>. The operator subexpression <code>add</code> is a name found in the global frame, bound to the built-in function for addition. The two operand subexpressions must be evaluated in turn, before addition is applied. Both operands are evaluated in the current environment beginning with the frame labeled <code>sum_squares</code>.</p>
<p>In <code>operand 0</code>, <code>square</code> names a user-defined function in the global frame, while <code>x</code> names the number 5 in the local frame. Python applies <code>square</code> to 5 by introducing yet another local frame that binds x to 5.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215731077.png" alt="image-20200206215731077" style="zoom:50%;"></p>
<p>Using this environment, the expression <code>mul(x, x)</code> evaluates to 25.</p>
<p>Our evaluation procedure now turns to <code>operand 1</code>, for which <code>y</code> names the number 12. Python evaluates the body of <code>square</code> again, this time introducing yet another local frame that binds <code>x</code> to 12. Hence, <code>operand 1</code> evaluates to 144.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215810249.png" alt="image-20200206215810249" style="zoom:50%;"></p>
<p>Finally, applying addition to the arguments 25 and 144 yields a final return value for <code>sum_squares</code>: 169.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206215849848.png" alt="image-20200206215849848" style="zoom:50%;"></p>
<p>This example illustrates many of the fundamental ideas we have developed so far. Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called, even if the same function is called twice.</p>
<p>All of this machinery exists to ensure that names resolve to the correct values at the correct times during program execution. This example illustrates why our model requires the complexity that we have introduced. All three local frames contain a binding for the name <code>x</code>, but that name is bound to different values in different frames. Local frames keep these names separate.</p>
<h3 id="1-3-4-Local-Names"><a href="#1-3-4-Local-Names" class="headerlink" title="1.3.4  Local Names"></a>1.3.4  Local Names</h3><p>One detail of a function’s implementation that should not affect the function’s behavior is the implementer’s choice of names for the function’s formal parameters. Thus, the following functions should provide the same behavior:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return mul(x, x)</span><br><span class="line">&gt;&gt;&gt; def square(y):</span><br><span class="line">        return mul(y, y)</span><br></pre></td></tr></table></figure>
<p>This principle — that the meaning of a function should be independent of the parameter names chosen by its author — has important consequences for programming languages. The simplest consequence is that the parameter names of a function must remain local to the body of the function.</p>
<p>If the parameters were not local to the bodies of their respective functions, then the parameter <code>x</code> in <code>square</code> could be confused with the parameter <code>x</code> in <code>sum_squares</code>. Critically, this is not the case: the binding for <code>x</code> in different local frames are unrelated. The model of computation is carefully designed to ensure this independence.</p>
<p>We say that the <em>scope</em> of a local name is limited to the body of the user-defined function that defines it. When a name is no longer accessible, it is out of scope. This scoping behavior isn’t a new fact about our model; it is a consequence of the way environments work.</p>
<h3 id="1-3-5-Choosing-Names"><a href="#1-3-5-Choosing-Names" class="headerlink" title="1.3.5  Choosing Names"></a>1.3.5  Choosing Names</h3><p>The interchangeability of names does not imply that formal parameter names do not matter at all. On the contrary, well-chosen function and parameter names are essential for the human interpretability of function definitions!</p>
<p>The following guidelines are adapted from the <a href="http://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">style guide for Python code</a>, which serves as a guide for all (non-rebellious) Python programmers. A shared set of conventions smooths communication among members of a developer community. As a side effect of following these conventions, you will find that your code becomes more internally consistent.</p>
<ol>
<li>Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.</li>
<li>Function names typically evoke operations applied to arguments by the interpreter (e.g., <code>print</code>, <code>add</code>, <code>square</code>) or the name of the quantity that results (e.g., <code>max</code>, <code>abs</code>, <code>sum</code>).</li>
<li>Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.</li>
<li>Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.</li>
<li>Single letter parameter names are acceptable when their role is obvious, but avoid “l” (lowercase ell), “O” (capital oh), or “I” (capital i) to avoid confusion with numerals.</li>
</ol>
<p>There are many exceptions to these guidelines, even in the Python standard library. Like the vocabulary of the English language, Python has inherited words from a variety of contributors, and the result is not always consistent.</p>
<h3 id="1-3-6-Functions-as-Abstractions"><a href="#1-3-6-Functions-as-Abstractions" class="headerlink" title="1.3.6  Functions as Abstractions"></a>1.3.6  Functions as Abstractions</h3><p>Though it is very simple, <code>sum_squares</code> exemplifies the most powerful property of user-defined functions. The function <code>sum_squares</code> is defined in terms of the function <code>square</code>, but relies only on the relationship that <code>square</code> defines between its input arguments and its output values.</p>
<p>We can write <code>sum_squares</code> without concerning ourselves with <em>how</em> to square a number. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far as <code>sum_squares</code> is concerned, <code>square</code> is not a particular function body, but rather an abstraction of a function, a so-called functional abstraction. At this level of abstraction, any function that computes the square is equally good.</p>
<p>Thus, considering only the values they return, the following two functions for squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return mul(x, x)</span><br><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return mul(x, x-1) + x</span><br></pre></td></tr></table></figure>
<p>In other words, a function definition should be able to suppress details. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a “black box”. A programmer should not need to know how the function is implemented in order to use it. The Python Library has this property. Many developers use the functions defined there, but few ever inspect their implementation.</p>
<p><strong>Aspects of a functional abstraction.</strong> To master the use of a functional abstraction, it is often useful to consider its three core attributes. The <em>domain</em> of a function is the set of arguments it can take. The <em>range</em>of a function is the set of values it can return. The <em>intent</em> of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.</p>
<p>For example, any <code>square</code> function that we use to implement <code>sum_squares</code> should have these attributes:</p>
<ul>
<li>The <em>domain</em> is any single real number.</li>
<li>The <em>range</em> is any non-negative real number.</li>
<li>The <em>intent</em> is that the output is the square of the input.</li>
</ul>
<p>These attributes do not specify how the intent is carried out; that detail is abstracted away.</p>
<h3 id="1-3-7-Operators"><a href="#1-3-7-Operators" class="headerlink" title="1.3.7  Operators"></a>1.3.7  Operators</h3><p><strong>Video:</strong> Show Hide</p>
<p>Mathematical operators (such as <code>+</code> and <code>-</code>) provided our first example of a method of combination, but we have yet to define an evaluation procedure for expressions that contain these operators.</p>
<p>Python expressions with infix operators each have their own evaluation procedures, but you can often think of them as short-hand for call expressions. When you see</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>simply consider it to be short-hand for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(2, 3)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Infix notation can be nested, just like call expressions. Python applies the normal mathematical rules of operator precedence, which dictate how to interpret a compound expression with multiple operators.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 3 * 4 + 5</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p>evaluates to the same result as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(add(2, mul(3, 4)), 5)</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p>The nesting in the call expression is more explicit than the operator version, but also harder to read. Python also allows subexpression grouping with parentheses, to override the normal precedence rules or make the nested structure of an expression more explicit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (2 + 3) * (4 + 5)</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>evaluates to the same result as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mul(add(2, 3), add(4, 5))</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>When it comes to division, Python provides two infix operators: <code>/</code> and <code>//</code>. The former is normal division, so that it results in a <em>floating point</em>, or decimal value, even if the divisor evenly divides the dividend:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 &#x2F; 4</span><br><span class="line">1.25</span><br><span class="line">&gt;&gt;&gt; 8 &#x2F; 4</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<p>The <code>//</code> operator, on the other hand, rounds the result down to an integer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 &#x2F;&#x2F; 4</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -5 &#x2F;&#x2F; 4</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<p>These two operators are shorthand for the <code>truediv</code> and <code>floordiv</code> functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import truediv, floordiv</span><br><span class="line">&gt;&gt;&gt; truediv(5, 4)</span><br><span class="line">1.25</span><br><span class="line">&gt;&gt;&gt; floordiv(5, 4)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>You should feel free to use infix operators and parentheses in your programs. Idiomatic Python prefers operators over call expressions for simple mathematical operations.</p>
<h2 id="1-4-Designing-Functions"><a href="#1-4-Designing-Functions" class="headerlink" title="1.4  Designing Functions"></a>1.4  Designing Functions</h2><p><strong>Video:</strong> Show Hide</p>
<p>Functions are an essential ingredient of all programs, large and small, and serve as our primary medium to express computational processes in a programming language. So far, we have discussed the formal properties of functions and how they are applied. We now turn to the topic of what makes a good function. Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions.</p>
<ul>
<li>Each function should have exactly one job. That job should be identifiable with a short name and characterizable in a single line of text. Functions that perform multiple jobs in sequence should be divided into multiple functions.</li>
<li><em>Don’t repeat yourself</em> is a central tenet of software engineering. The so-called DRY principle states that multiple fragments of code should not describe redundant logic. Instead, that logic should be implemented once, given a name, and applied multiple times. If you find yourself copying and pasting a block of code, you have probably found an opportunity for functional abstraction.</li>
<li>Functions should be defined generally. Squaring is not in the Python Library precisely because it is a special case of the <code>pow</code> function, which raises numbers to arbitrary powers.</li>
</ul>
<p>These guidelines improve the readability of code, reduce the number of errors, and often minimize the total amount of code written. Decomposing a complex task into concise functions is a skill that takes experience to master. Fortunately, Python provides several features to support your efforts.</p>
<h3 id="1-4-1-Documentation"><a href="#1-4-1-Documentation" class="headerlink" title="1.4.1  Documentation"></a>1.4.1  Documentation</h3><p>A function definition will often include documentation describing the function, called a <em>docstring</em>, which must be indented along with the function body. Docstrings are conventionally triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pressure(v, t, n):</span><br><span class="line">        &quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="line"></span><br><span class="line">        Applies the ideal gas law: http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ideal_gas_law</span><br><span class="line"></span><br><span class="line">        v -- volume of gas, in cubic meters</span><br><span class="line">        t -- absolute temperature in degrees kelvin</span><br><span class="line">        n -- particles of gas</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        k &#x3D; 1.38e-23  # Boltzmann&#39;s constant</span><br><span class="line">        return n * k * t &#x2F; v</span><br></pre></td></tr></table></figure>
<p>When you call <code>help</code> with the name of a function as an argument, you see its docstring (type <code>q</code> to quit Python help).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure>
<p>When writing Python programs, include docstrings for all but the simplest functions. Remember, code is written only once, but often read many times. The Python docs include <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">docstring guidelines</a> that maintain consistency across different Python projects.</p>
<p><strong>Comments</strong>. Comments in Python can be attached to the end of a line following the <code>#</code> symbol. For example, the comment <code>Boltzmann&#39;s constant</code> above describes <code>k</code>. These comments don’t ever appear in Python’s <code>help</code>, and they are ignored by the interpreter. They exist for humans alone.</p>
<h3 id="1-4-2-Default-Argument-Values"><a href="#1-4-2-Default-Argument-Values" class="headerlink" title="1.4.2  Default Argument Values"></a>1.4.2  Default Argument Values</h3><p>A consequence of defining general functions is the introduction of additional arguments. Functions with many arguments can be awkward to call and difficult to read.</p>
<p>In Python, we can provide default values for the arguments of a function. When calling that function, arguments with default values are optional. If they are not provided, then the default value is bound to the formal parameter name instead. For instance, if an application commonly computes pressure for one mole of particles, this value can be provided as a default:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pressure(v, t, n&#x3D;6.022e23):</span><br><span class="line">        &quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="line"></span><br><span class="line">        v -- volume of gas, in cubic meters</span><br><span class="line">        t -- absolute temperature in degrees kelvin</span><br><span class="line">        n -- particles of gas (default: one mole)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        k &#x3D; 1.38e-23  # Boltzmann&#39;s constant</span><br><span class="line">        return n * k * t &#x2F; v</span><br></pre></td></tr></table></figure>
<p>The <code>=</code> symbol means two different things in this example, depending on the context in which it is used. In the <code>def</code> statement header, <code>=</code> does not perform assignment, but instead indicates a default value to use when the <code>pressure</code> function is called. By contrast, the assignment statement to <code>k</code> in the body of the function binds the name <code>k</code> to an approximation of Boltzmann’s constant.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pressure(1, 273.15)</span><br><span class="line">2269.974834</span><br><span class="line">&gt;&gt;&gt; pressure(1, 273.15, 3 * 6.022e23)</span><br><span class="line">6809.924502</span><br></pre></td></tr></table></figure>
<p>The <code>pressure</code> function is defined to take three arguments, but only two are provided in the first call expression above. In this case, the value for <code>n</code> is taken from the <code>def</code> statement default. If a third argument is provided, the default is ignored.</p>
<p>As a guideline, most data values used in a function’s body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant <code>k</code>, can be bound in the function body or in the global frame.</p>
<h2 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5  Control"></a>1.5  Control</h2><p>The expressive power of the functions that we can define at this point is very limited, because we have not introduced a way to make comparisons and to perform different operations depending on the result of a comparison. <em>Control statements</em> will give us this ability. They are statements that control the flow of a program’s execution based on the results of logical comparisons.</p>
<p>Statements differ fundamentally from the expressions that we have studied so far. They have no value. Instead of computing something, executing a control statement determines what the interpreter should do next.</p>
<h3 id="1-5-1-Statements"><a href="#1-5-1-Statements" class="headerlink" title="1.5.1  Statements"></a>1.5.1  Statements</h3><p>So far, we have primarily considered how to evaluate expressions. However, we have seen three kinds of statements already: assignment, <code>def</code>, and <code>return</code> statements. These lines of Python code are not themselves expressions, although they all contain expressions as components.</p>
<p>Rather than being evaluated, statements are <em>executed</em>. Each statement describes some change to the interpreter state, and executing a statement applies that change. As we have seen for <code>return</code> and assignment statements, executing statements can involve evaluating subexpressions contained within them.</p>
<p>Expressions can also be executed as statements, in which case they are evaluated, but their value is discarded. Executing a pure function has no effect, but executing a non-pure function can cause effects as a consequence of function application.</p>
<p>Consider, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        mul(x, x) # Watch out! This call doesn&#39;t return a value.</span><br></pre></td></tr></table></figure>
<p>This example is valid Python, but probably not what was intended. The body of the function consists of an expression. An expression by itself is a valid statement, but the effect of the statement is that the <code>mul</code>function is called, and the result is discarded. If you want to do something with the result of an expression, you need to say so: you might store it with an assignment statement or return it with a return statement:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return mul(x, x)</span><br></pre></td></tr></table></figure>
<p>Sometimes it does make sense to have a function whose body is an expression, when a non-pure function like <code>print</code> is called.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_square(x):</span><br><span class="line">        print(square(x))</span><br></pre></td></tr></table></figure>
<p>At its highest level, the Python interpreter’s job is to execute programs, composed of statements. However, much of the interesting work of computation comes from evaluating expressions. Statements govern the relationship among different expressions in a program and what happens to their results.</p>
<h3 id="1-5-2-Compound-Statements"><a href="#1-5-2-Compound-Statements" class="headerlink" title="1.5.2  Compound Statements"></a>1.5.2  Compound Statements</h3><p>In general, Python code is a sequence of statements. A simple statement is a single line that doesn’t end in a colon. A compound statement is so called because it is composed of other statements (simple and compound). Compound statements typically span multiple lines and start with a one-line header ending in a colon, which identifies the type of statement. Together, a header and an indented suite of statements is called a clause. A compound statement consists of one or more clauses:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;separating header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>We can understand the statements we have already introduced in these terms.</p>
<ul>
<li>Expressions, return statements, and assignment statements are simple statements.</li>
<li>A <code>def</code> statement is a compound statement. The suite that follows the <code>def</code> header defines the function body.</li>
</ul>
<p>Specialized evaluation rules for each kind of header dictate when and if the statements in its suite are executed. We say that the header controls its suite. For example, in the case of <code>def</code> statements, we saw that the return expression is not evaluated immediately, but instead stored for later use when the defined function is eventually called.</p>
<p>We can also understand multi-line programs now.</p>
<ul>
<li>To execute a sequence of statements, execute the first statement. If that statement does not redirect control, then proceed to execute the rest of the sequence of statements, if any remain.</li>
</ul>
<p>This definition exposes the essential structure of a recursively defined <em>sequence</em>: a sequence can be decomposed into its first element and the rest of its elements. The “rest” of a sequence of statements is itself a sequence of statements! Thus, we can recursively apply this execution rule. This view of sequences as recursive data structures will appear again in later chapters.</p>
<p>The important consequence of this rule is that statements are executed in order, but later statements may never be reached, because of redirected control.</p>
<p><strong>Practical Guidance.</strong> When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.</p>
<h3 id="1-5-3-Defining-Functions-II-Local-Assignment"><a href="#1-5-3-Defining-Functions-II-Local-Assignment" class="headerlink" title="1.5.3  Defining Functions II: Local Assignment"></a>1.5.3  Defining Functions II: Local Assignment</h3><p>Originally, we stated that the body of a user-defined function consisted only of a <code>return</code> statement with a single return expression. In fact, functions can define a sequence of operations that extends beyond a single expression.</p>
<p>Whenever a user-defined function is applied, the sequence of clauses in the suite of its definition is executed in a local environment — an environment starting with a local frame created by calling that function. A <code>return</code> statement redirects control: the process of function application terminates whenever the first <code>return</code> statement is executed, and the value of the <code>return</code> expression is the returned value of the function being applied.</p>
<p>Assignment statements can appear within a function body. For instance, this function returns the absolute difference between two quantities as a percentage of the first, using a two-step calculation:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">percent_difference</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    difference = abs(x-y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * difference / x</span><br><span class="line">result = percent_difference(<span class="number">40</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206220110429.png" alt="image-20200206220110429" style="zoom:50%;"></p>
<p>The effect of an assignment statement is to bind a name to a value in the <em>first</em> frame of the current environment. As a consequence, assignment statements within a function body cannot affect the global frame. The fact that functions can only manipulate their local environment is critical to creating <em>modular</em>programs, in which pure functions interact only via the values they take and return.</p>
<p>Of course, the <code>percent_difference</code> function could be written as a single expression, as shown below, but the return expression is more complex.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def percent_difference(x, y):</span><br><span class="line">        return 100 * abs(x-y) &#x2F; x</span><br><span class="line">&gt;&gt;&gt; percent_difference(40, 50)</span><br><span class="line">25.0</span><br></pre></td></tr></table></figure>
<p>So far, local assignment hasn’t increased the expressive power of our function definitions. It will do so, when combined with other control statements. In addition, local assignment also plays a critical role in clarifying the meaning of complex expressions by assigning names to intermediate quantities.</p>
<h3 id="1-5-4-Conditional-Statements"><a href="#1-5-4-Conditional-Statements" class="headerlink" title="1.5.4  Conditional Statements"></a>1.5.4  Conditional Statements</h3><p><strong>Video:</strong> Show Hide</p>
<p>Python has a built-in function for computing absolute values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-2)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>We would like to be able to implement such a function ourselves, but we have no obvious way to define a function that has a comparison and a choice. We would like to express that if <code>x</code> is positive, <code>abs(x)</code>returns <code>x</code>. Furthermore, if <code>x</code> is 0, <code>abs(x)</code> returns 0. Otherwise, <code>abs(x)</code> returns <code>-x</code>. In Python, we can express this choice with a conditional statement.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">absolute_value</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Compute abs(x)."""</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">result = absolute_value(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206220138044.png" alt="image-20200206220138044" style="zoom:50%;"></p>
<p>This implementation of <code>absolute_value</code> raises several important issues:</p>
<p><strong>Conditional statements</strong>. A conditional statement in Python consists of a series of headers and suites: a required <code>if</code> clause, an optional sequence of <code>elif</code> clauses, and finally an optional <code>else</code> clause:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line">elif &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.</p>
<ol>
<li>Evaluate the header’s expression.</li>
<li>If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.</li>
</ol>
<p>If the <code>else</code> clause is reached (which only happens if all <code>if</code> and <code>elif</code> expressions evaluate to false values), its suite is executed.</p>
<p><strong>Boolean contexts</strong>. Above, the execution procedures mention “a false value” and “a true value.” The expressions inside the header statements of conditional blocks are said to be in <em>boolean contexts</em>: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including 0, <code>None</code>, and the <em>boolean</em> value <code>False</code>. All other numbers are true values. In Chapter 2, we will see that every built-in kind of data in Python has both true and false values.</p>
<p><strong>Boolean values</strong>. Python has two boolean values, called <code>True</code> and <code>False</code>. Boolean values represent truth values in logical expressions. The built-in comparison operations, <code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>, return these values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 4 &lt; 2</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt;&#x3D; 5</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>This second example reads “5 is greater than or equal to 5”, and corresponds to the function <code>ge</code> in the <code>operator</code> module.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0 &#x3D;&#x3D; -0</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>This final example reads “0 equals -0”, and corresponds to <code>eq</code> in the <code>operator</code> module. Notice that Python distinguishes assignment (<code>=</code>) from equality comparison (<code>==</code>), a convention shared across many programming languages.</p>
<p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; True or False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; not False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>Logical expressions have corresponding evaluation procedures. These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called <em>short-circuiting</em>.</p>
<p>To evaluate the expression <code>and</code>:</p>
<ol>
<li>Evaluate the subexpression ``.</li>
<li>If the result is a false value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression ``.</li>
</ol>
<p>To evaluate the expression <code>or</code>:</p>
<ol>
<li>Evaluate the subexpression ``.</li>
<li>If the result is a true value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression ``.</li>
</ol>
<p>To evaluate the expression <code>not</code>:</p>
<ol>
<li>Evaluate <code>`; The value is</code>True<code>if the result is a false value, and</code>False` otherwise.</li>
</ol>
<p>These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with <code>is</code>, not followed by an underscore (e.g., <code>isfinite</code>, <code>isdigit</code>, <code>isinstance</code>, etc.).</p>
<h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5  Iteration"></a>1.5.5  Iteration</h3><p><strong>Video:</strong> Show Hide</p>
<p>In addition to selecting which statements to execute, control statements are used to express repetition. If each line of code we wrote were only executed once, programming would be a very unproductive exercise. Only through repeated execution of statements do we unlock the full potential of computers. We have already seen one form of repetition: a function can be applied many times, although it is only defined once. Iterative control structures are another mechanism for executing the same statements many times.</p>
<p>Consider the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, ...</span><br></pre></td></tr></table></figure>
<p>Each value is constructed by repeatedly applying the sum-previous-two rule. The first and second are fixed to 0 and 1. For instance, the eighth Fibonacci number is 13.</p>
<p>We can use a <code>while</code> statement to enumerate <code>n</code> Fibonacci numbers. We need to track how many values we’ve created (<code>k</code>), along with the kth value (<code>curr</code>) and its predecessor (<code>pred</code>). Step through this function and observe how the Fibonacci numbers evolve one by one, bound to <code>curr</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""Compute the nth Fibonacci number, for n &gt;= 2."""</span></span><br><span class="line">    pred, curr = <span class="number">0</span>, <span class="number">1</span>   <span class="comment"># Fibonacci numbers 1 and 2</span></span><br><span class="line">    k = <span class="number">2</span>               <span class="comment"># Which Fib number is curr?</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        pred, curr = curr, pred + curr</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">result = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206220209651.png" alt="image-20200206220209651" style="zoom:50%;"></p>
<p>Remember that commas seperate multiple names and values in an assignment statement. The line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred, curr &#x3D; curr, pred + curr</span><br></pre></td></tr></table></figure>
<p>has the effect of rebinding the name <code>pred</code> to the value of <code>curr</code>, and simultaneously rebinding <code>curr</code> to the value of <code>pred + curr</code>. All of the expressions to the right of <code>=</code> are evaluated before any rebinding takes place.</p>
<p>This order of events — evaluating everything on the right of <code>=</code> before updating any bindings on the left — is essential for correctness of this function.</p>
<p>A <code>while</code> clause contains a header expression followed by a suite:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>To execute a <code>while</code> clause:</p>
<ol>
<li>Evaluate the header’s expression.</li>
<li>If it is a true value, execute the suite, then return to step 1.</li>
</ol>
<p>In step 2, the entire suite of the <code>while</code> clause is executed before the header expression is evaluated again.</p>
<p>In order to prevent the suite of a <code>while</code> clause from being executed indefinitely, the suite should always change some binding in each pass.</p>
<p>A <code>while</code> statement that does not terminate is called an infinite loop. Press <code>-C</code> to force Python to stop looping.</p>
<h3 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6  Testing"></a>1.5.6  Testing</h3><p><em>Testing</em> a function is the act of verifying that the function’s behavior matches expectations. Our language of functions is now sufficiently complex that we need to start testing our implementations.</p>
<p>A <em>test</em> is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.</p>
<p><strong>Assertions.</strong> Programmers use <code>assert</code> statements to verify expectations, such as the output of a function being tested. An <code>assert</code> statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; assert fib(8) &#x3D;&#x3D; 13, &#39;The 8th Fibonacci number should be 13&#39;</span><br></pre></td></tr></table></figure>
<p>When the expression being asserted evaluates to a true value, executing an assert statement has no effect. When it is a false value, <code>assert</code> causes an error that halts execution.</p>
<p>A test function for <code>fib</code> should test several arguments, including extreme values of <code>n</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib_test():</span><br><span class="line">        assert fib(2) &#x3D;&#x3D; 1, &#39;The 2nd Fibonacci number should be 1&#39;</span><br><span class="line">        assert fib(3) &#x3D;&#x3D; 1, &#39;The 3rd Fibonacci number should be 1&#39;</span><br><span class="line">        assert fib(50) &#x3D;&#x3D; 7778742049, &#39;Error at the 50th Fibonacci number&#39;</span><br></pre></td></tr></table></figure>
<p>When writing Python in files, rather than directly into the interpreter, tests are typically written in the same file or a neighboring file with the suffix <code>_test.py</code>.</p>
<p><strong>Doctests.</strong> Python provides a convenient method for placing simple tests directly in the docstring of a function. The first line of a docstring should contain a one-line description of the function, followed by a blank line. A detailed description of arguments and behavior may follow. In addition, the docstring may include a sample interactive session that calls the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_naturals(n):</span><br><span class="line">        &quot;&quot;&quot;Return the sum of the first n natural numbers.</span><br><span class="line"></span><br><span class="line">        &gt;&gt;&gt; sum_naturals(10)</span><br><span class="line">        55</span><br><span class="line">        &gt;&gt;&gt; sum_naturals(100)</span><br><span class="line">        5050</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        total, k &#x3D; 0, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total + k, k + 1</span><br><span class="line">        return total</span><br></pre></td></tr></table></figure>
<p>Then, the interaction can be verified via the <a href="http://docs.python.org/py3k/library/doctest.html" target="_blank" rel="noopener">doctest module</a>. Below, the <code>globals</code> function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from doctest import testmod</span><br><span class="line">&gt;&gt;&gt; testmod()</span><br><span class="line">TestResults(failed&#x3D;0, attempted&#x3D;2)</span><br></pre></td></tr></table></figure>
<p>To verify the doctest interactions for only a single function, we use a <code>doctest</code> function called <code>run_docstring_examples</code>. This function is (unfortunately) a bit complicated to call. Its first argument is the function to test. The second should always be the result of the expression <code>globals()</code>, a built-in function that returns the global environment. The third argument is <code>True</code> to indicate that we would like “verbose” output: a catalog of all tests run.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from doctest import run_docstring_examples</span><br><span class="line">&gt;&gt;&gt; run_docstring_examples(sum_naturals, globals(), True)</span><br><span class="line">Finding tests in NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(10)</span><br><span class="line">Expecting:</span><br><span class="line">    55</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(100)</span><br><span class="line">Expecting:</span><br><span class="line">    5050</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>When the return value of a function does not match the expected result, the <code>run_docstring_examples</code>function will report this problem as a test failure.</p>
<p>When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></table></figure>
<p>The key to effective testing is to write (and run) tests immediately after implementing new functions. It is even good practice to write some tests before you implement, in order to have some example inputs and outputs in your mind. A test that applies a single function is called a <em>unit test</em>. Exhaustive unit testing is a hallmark of good program design.</p>
<h2 id="1-6-Higher-Order-Functions"><a href="#1-6-Higher-Order-Functions" class="headerlink" title="1.6  Higher-Order Functions"></a>1.6  Higher-Order Functions</h2><p><strong>Video:</strong> Show Hide</p>
<p>We have seen that functions are a method of abstraction that describe compound operations independent of the particular values of their arguments. That is, in <code>square</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return x * x</span><br></pre></td></tr></table></figure>
<p>we are not talking about the square of a particular number, but rather about a method for obtaining the square of any number. Of course, we could get along without ever defining this function, by always writing expressions such as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 * 3</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 5 * 5</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>and never mentioning <code>square</code> explicitly. This practice would suffice for simple computations such as <code>square</code>, but would become arduous for more complex examples such as <code>abs</code> or <code>fib</code>. In general, lacking function definition would put us at the disadvantage of forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute squares, but our language would lack the ability to express the concept of squaring.</p>
<p>One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the names directly. Functions provide this ability. As we will see in the following examples, there are common programming patterns that recur in code, but are used with a number of different functions. These patterns can also be abstracted, by giving them names.</p>
<p>To express certain general patterns as named concepts, we will need to construct functions that can accept other functions as arguments or return functions as values. Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p>
<h3 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1  Functions as Arguments"></a>1.6.1  Functions as Arguments</h3><p>Consider the following three functions, which all compute summations. The first, <code>sum_naturals</code>, computes the sum of natural numbers up to <code>n</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_naturals(n):</span><br><span class="line">        total, k &#x3D; 0, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total + k, k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; sum_naturals(100)</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>
<p>The second, <code>sum_cubes</code>, computes the sum of the cubes of natural numbers up to <code>n</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_cubes(n):</span><br><span class="line">        total, k &#x3D; 0, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total + k*k*k, k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; sum_cubes(100)</span><br><span class="line">25502500</span><br></pre></td></tr></table></figure>
<p>The third, <code>pi_sum</code>, computes the sum of terms in the series</p>
<p><img src="http://composingprograms.com/img/pi_sum.png" alt="img"></p>
<p>which converges to pi very slowly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pi_sum(n):</span><br><span class="line">        total, k &#x3D; 0, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total + 8 &#x2F; ((4*k-3) * (4*k-1)), k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; pi_sum(100)</span><br><span class="line">3.1365926848388144</span><br></pre></td></tr></table></figure>
<p>These three functions clearly share a common underlying pattern. They are for the most part identical, differing only in name and the function of <code>k</code> used to compute the term to be added. We could generate each of the functions by filling in slots in the same template:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def &lt;name&gt;(n):</span><br><span class="line">    total, k &#x3D; 0, 1</span><br><span class="line">    while k &lt;&#x3D; n:</span><br><span class="line">        total, k &#x3D; total + &lt;term&gt;(k), k + 1</span><br><span class="line">    return total</span><br></pre></td></tr></table></figure>
<p>The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Each of these functions is a summation of terms. As program designers, we would like our language to be powerful enough so that we can write a function that expresses the concept of summation itself rather than only functions that compute particular sums. We can do so readily in Python by taking the common template shown above and transforming the “slots” into formal parameters:</p>
<p>In the example below, <code>summation</code> takes as its two arguments the upper bound <code>n</code> together with the function <code>term</code> that computes the kth term. We can use <code>summation</code> just as we would any function, and it expresses summations succinctly. Take the time to step through this example, and notice how binding<code>cube</code> to the local names <code>term</code> ensures that the result <code>1*1*1 + 2*2*2 + 3*3*3 = 36</code> is computed correctly. In this example, frames which are no longer needed are removed to save space.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">summation</span><span class="params">(n, term)</span>:</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cubes</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> summation(n, cube)</span><br><span class="line"></span><br><span class="line">result = sum_cubes(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206221358578.png" alt="image-20200206221358578" style="zoom:50%;"></p>
<p>Using an <code>identity</code> function that returns its argument, we can also sum natural numbers using exactly the same <code>summation</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def summation(n, term):</span><br><span class="line">        total, k &#x3D; 0, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total + term(k), k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; def identity(x):</span><br><span class="line">        return x</span><br><span class="line">&gt;&gt;&gt; def sum_naturals(n):</span><br><span class="line">        return summation(n, identity)</span><br><span class="line">&gt;&gt;&gt; sum_naturals(10)</span><br><span class="line">55</span><br></pre></td></tr></table></figure>
<p>The <code>summation</code> function can also be called directly, without definining another function for a specific sequence.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; summation(10, square)</span><br><span class="line">385</span><br></pre></td></tr></table></figure>
<p>We can define <code>pi_sum</code> using our <code>summation</code> abstraction by defining a function <code>pi_term</code> to compute each term. We pass the argument <code>1e6</code>, a shorthand for <code>1 * 10^6 = 1000000</code>, to generate a close approximation to pi.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pi_term(x):</span><br><span class="line">        return 8 &#x2F; ((4*x-3) * (4*x-1))</span><br><span class="line">&gt;&gt;&gt; def pi_sum(n):</span><br><span class="line">        return summation(n, pi_term)</span><br><span class="line">&gt;&gt;&gt; pi_sum(1e6)</span><br><span class="line">3.141592153589902</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-Functions-as-General-Methods"><a href="#1-6-2-Functions-as-General-Methods" class="headerlink" title="1.6.2  Functions as General Methods"></a>1.6.2  Functions as General Methods</h3><p><strong>Video:</strong> Show Hide</p>
<p>We introduced user-defined functions as a mechanism for abstracting patterns of numerical operations so as to make them independent of the particular numbers involved. With higher-order functions, we begin to see a more powerful kind of abstraction: some functions express general methods of computation, independent of the particular functions they call.</p>
<p>Despite this conceptual extension of what a function means, our environment model of how to evaluate a call expression extends gracefully to the case of higher-order functions, without change. When a user-defined function is applied to some arguments, the formal parameters are bound to the values of those arguments (which may be functions) in a new local frame.</p>
<p>Consider the following example, which implements a general method for iterative improvement and uses it to compute the <a href="http://www.geom.uiuc.edu/~demo5337/s97b/art.htm" target="_blank" rel="noopener">golden ratio</a>. The golden ratio, often called “phi”, is a number near 1.6 that appears frequently in nature, art, and architecture.</p>
<p>An iterative improvement algorithm begins with a <code>guess</code> of a solution to an equation. It repeatedly applies an <code>update</code> function to improve that guess, and applies a <code>close</code> comparison to check whether the current <code>guess</code> is “close enough” to be considered correct.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def improve(update, close, guess&#x3D;1):</span><br><span class="line">        while not close(guess):</span><br><span class="line">            guess &#x3D; update(guess)</span><br><span class="line">        return guess</span><br></pre></td></tr></table></figure>
<p>This <code>improve</code> function is a general expression of repetitive refinement. It doesn’t specify what problem is being solved: those details are left to the <code>update</code> and <code>close</code> functions passed in as arguments.</p>
<p>Among the well-known properties of the golden ratio are that it can be computed by repeatedly summing the inverse of any positive number with 1, and that it is one less than its square. We can express these properties as functions to be used with <code>improve</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def golden_update(guess):</span><br><span class="line">        return 1&#x2F;guess + 1</span><br><span class="line">&gt;&gt;&gt; def square_close_to_successor(guess):</span><br><span class="line">        return approx_eq(guess * guess, guess + 1)</span><br></pre></td></tr></table></figure>
<p>Above, we introduce a call to <code>approx_eq</code> that is meant to return <code>True</code> if its arguments are approximately equal to each other. To implement, <code>approx_eq</code>, we can compare the absolute value of the difference between two numbers to a small tolerance value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def approx_eq(x, y, tolerance&#x3D;1e-15):</span><br><span class="line">        return abs(x - y) &lt; tolerance</span><br></pre></td></tr></table></figure>
<p>Calling <code>improve</code> with the arguments <code>golden_update</code> and <code>square_close_to_successor</code> will compute a finite approximation to the golden ratio.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; improve(golden_update, square_close_to_successor)</span><br><span class="line">1.6180339887498951</span><br></pre></td></tr></table></figure>
<p>By tracing through the steps of evaluation, we can see how this result is computed. First, a local frame for <code>improve</code> is constructed with bindings for <code>update</code>, <code>close</code>, and <code>guess</code>. In the body of <code>improve</code>, the name<code>close</code> is bound to <code>square_close_to_successor</code>, which is called on the initial value of <code>guess</code>. Trace through the rest of the steps to see the computational process that evolves to compute the golden ratio.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span><span class="params">(update, close, guess=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">golden_update</span><span class="params">(guess)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_close_to_successor</span><span class="params">(guess)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess,</span><br><span class="line">                     guess + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span><span class="params">(x, y, tolerance=<span class="number">1e-3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x - y) &lt; tolerance</span><br><span class="line"></span><br><span class="line">phi = improve(golden_update,</span><br><span class="line">              square_close_to_successor)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206221447372.png" alt="image-20200206221447372" style="zoom:50%;"></p>
<p>This example illustrates two related big ideas in computer science. First, naming and functions allow us to abstract away a vast amount of complexity. While each function definition has been trivial, the computational process set in motion by our evaluation procedure is quite intricate. Second, it is only by virtue of the fact that we have an extremely general evaluation procedure for the Python language that small components can be composed into complex processes. Understanding the procedure of interpreting programs allows us to validate and inspect the process we have created.</p>
<p>As always, our new general method <code>improve</code> needs a test to check its correctness. The golden ratio can provide such a test, because it also has an exact closed-form solution, which we can compare to this iterative result.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import sqrt</span><br><span class="line">&gt;&gt;&gt; phi &#x3D; 1&#x2F;2 + sqrt(5)&#x2F;2</span><br><span class="line">&gt;&gt;&gt; def improve_test():</span><br><span class="line">        approx_phi &#x3D; improve(golden_update, square_close_to_successor)</span><br><span class="line">        assert approx_eq(phi, approx_phi), &#39;phi differs from its approximation&#39;</span><br><span class="line">&gt;&gt;&gt; improve_test()</span><br></pre></td></tr></table></figure>
<p>For this test, no news is good news: <code>improve_test</code> returns <code>None</code> after its <code>assert</code> statement is executed successfully.</p>
<h3 id="1-6-3-Defining-Functions-III-Nested-Definitions"><a href="#1-6-3-Defining-Functions-III-Nested-Definitions" class="headerlink" title="1.6.3  Defining Functions III: Nested Definitions"></a>1.6.3  Defining Functions III: Nested Definitions</h3><p>The above examples demonstrate how the ability to pass functions as arguments significantly enhances the expressive power of our programming language. Each general concept or equation maps onto its own short function. One negative consequence of this approach is that the global frame becomes cluttered with names of small functions, which must all be unique. Another problem is that we are constrained by particular function signatures: the <code>update</code> argument to <code>improve</code> must take exactly one argument. Nested function definitions address both of these problems, but require us to enrich our environment model.</p>
<p>Let’s consider a new problem: computing the square root of a number. In programming languages, “square root” is often abbreviated as <code>sqrt</code>. Repeated application of the following update converges to the square root of <code>a</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def average(x, y):</span><br><span class="line">        return (x + y)&#x2F;2</span><br><span class="line">&gt;&gt;&gt; def sqrt_update(x, a):</span><br><span class="line">        return average(x, a&#x2F;x)</span><br></pre></td></tr></table></figure>
<p>This two-argument update function is incompatible with <code>improve</code> (it takes two arguments, not one), and it provides only a single update, while we really care about taking square roots by repeated updates. The solution to both of these issues is to place function definitions inside the body of other definitions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a&#x2F;x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>
<p>Like local assignment, local <code>def</code> statements only affect the current local frame. These functions are only in scope while <code>sqrt</code> is being evaluated. Consistent with our evaluation procedure, these local <code>def</code>statements don’t even get evaluated until <code>sqrt</code> is called.</p>
<p><strong>Lexical scope.</strong> Locally defined functions also have access to the name bindings in the scope in which they are defined. In this example, <code>sqrt_update</code> refers to the name <code>a</code>, which is a formal parameter of its enclosing function <code>sqrt</code>. This discipline of sharing names among nested definitions is called <em>lexical scoping</em>. Critically, the inner functions have access to the names in the environment where they are defined (not where they are called).</p>
<p>We require two extensions to our environment model to enable lexical scoping.</p>
<ol>
<li>Each user-defined function has a parent environment: the environment in which it was defined.</li>
<li>When a user-defined function is called, its local frame extends its parent environment.</li>
</ol>
<p>Previous to <code>sqrt</code>, all functions were defined in the global environment, and so they all had the same parent: the global environment. By contrast, when Python evaluates the first two clauses of <code>sqrt</code>, it create functions that are associated with a local environment. In the call</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqrt(256)</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure>
<p>the environment first adds a local frame for <code>sqrt</code> and evaluates the <code>def</code> statements for <code>sqrt_update</code> and <code>sqrt_close</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x + y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span><span class="params">(update, close, guess=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approx_eq</span><span class="params">(x, y, tolerance=<span class="number">1e-3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x - y) &lt; tolerance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrt_update</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> average(x, a/x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrt_close</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line">    <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br><span class="line"></span><br><span class="line">result = sqrt(<span class="number">256</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206221544486.png" alt="image-20200206221544486" style="zoom:50%;"></p>
<p>Function values each have a new annotation that we will include in environment diagrams from now on, a <em>parent</em>. The parent of a function value is the first frame of the environment in which that function was defined. Functions without parent annotations were defined in the global environment. When a user-defined function is called, the frame created has the same parent as that function.</p>
<p>Subsequently, the name <code>sqrt_update</code> resolves to this newly defined function, which is passed as an argument to <code>improve</code>. Within the body of <code>improve</code>, we must apply our <code>update</code> function (bound to <code>sqrt_update</code>) to the initial guess <code>x</code> of 1. This final application creates an environment for <code>sqrt_update</code> that begins with a local frame containing only <code>x</code>, but with the parent frame <code>sqrt</code> still containing a binding for <code>a</code>.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206221753026.png" alt="image-20200206221753026" style="zoom:50%;"></p>
<p>The most critical part of this evaluation procedure is the transfer of the parent for <code>sqrt_update</code> to the frame created by calling <code>sqrt_update</code>. This frame is also annotated with <code>[parent=f1]</code>.</p>
<p><strong>Extended Environments</strong>. An environment can consist of an arbitrarily long chain of frames, which always concludes with the global frame. Previous to this <code>sqrt</code> example, environments had at most two frames: a local frame and the global frame. By calling functions that were defined within other functions, via nested <code>def</code> statements, we can create longer chains. The environment for this call to <code>sqrt_update</code>consists of three frames: the local <code>sqrt_update</code> frame, the <code>sqrt</code> frame in which <code>sqrt_update</code> was defined (labeled <code>f1</code>), and the global frame.</p>
<p>The return expression in the body of <code>sqrt_update</code> can resolve a value for <code>a</code> by following this chain of frames. Looking up a name finds the first value bound to that name in the current environment. Python checks first in the <code>sqrt_update</code> frame — no <code>a</code> exists. Python checks next in the parent frame, <code>f1</code>, and finds a binding for <code>a</code> to 256.</p>
<p>Hence, we realize two key advantages of lexical scoping in Python.</p>
<ul>
<li>The names of a local function do not interfere with names external to the function in which it is defined, because the local function name will be bound in the current local environment in which it was defined, rather than the global environment.</li>
<li>A local function can access the environment of the enclosing function, because the body of the local function is evaluated in an environment that extends the evaluation environment in which it was defined.</li>
</ul>
<p>The <code>sqrt_update</code> function carries with it some data: the value for <code>a</code> referenced in the environment in which it was defined. Because they “enclose” information in this way, locally defined functions are often called <em>closures</em>.</p>
<h3 id="1-6-4-Functions-as-Returned-Values"><a href="#1-6-4-Functions-as-Returned-Values" class="headerlink" title="1.6.4  Functions as Returned Values"></a>1.6.4  Functions as Returned Values</h3><p><strong>Video:</strong> Show Hide</p>
<p>We can achieve even more expressive power in our programs by creating functions whose returned values are themselves functions. An important feature of lexically scoped programming languages is that locally defined functions maintain their parent environment when they are returned. The following example illustrates the utility of this feature.</p>
<p>Once many simple functions are defined, function <em>composition</em> is a natural method of combination to include in our programming language. That is, given two functions <code>f(x)</code> and <code>g(x)</code>, we might want to define <code>h(x) = f(g(x))</code>. We can define function composition using our existing tools:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def compose1(f, g):</span><br><span class="line">        def h(x):</span><br><span class="line">            return f(g(x))</span><br><span class="line">        return h</span><br></pre></td></tr></table></figure>
<p>The environment diagram for this example shows how the names <code>f</code> and <code>g</code> are resolved correctly, even in the presence of conflicting names.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose1</span><span class="params">(f, g)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Never called."""</span></span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">square_successor = compose1(square, successor)</span><br><span class="line">result = square_successor(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206221834025.png" alt="image-20200206221834025" style="zoom:50%;"></p>
<p>The 1 in <code>compose1</code> is meant to signify that the composed functions all take a single argument. This naming convention is not enforced by the interpreter; the 1 is just part of the function name.</p>
<p>At this point, we begin to observe the benefits of our effort to define precisely the environment model of computation. No modification to our environment model is required to explain our ability to return functions in this way.</p>
<h3 id="1-6-5-Example-Newton’s-Method"><a href="#1-6-5-Example-Newton’s-Method" class="headerlink" title="1.6.5  Example: Newton’s Method"></a>1.6.5  Example: Newton’s Method</h3><p><strong>Video:</strong> Show Hide</p>
<p>This extended example shows how function return values and local definitions can work together to express general ideas concisely. We will implement an algorithm that is used broadly in machine learning, scientific computing, hardware design, and optimization.</p>
<p>Newton’s method is a classic iterative approach to finding the arguments of a mathematical function that yield a return value of 0. These values are called the <em>zeros</em> of the function. Finding a zero of a function is often equivalent to solving some other problem of interest, such as computing a square root.</p>
<p>A motivating comment before we proceed: it is easy to take for granted the fact that we know how to compute square roots. Not just Python, but your phone, web browser, or pocket calculator can do so for you. However, part of learning computer science is understanding how quantities like these can be computed, and the general approach presented here is applicable to solving a large class of equations beyond those built into Python.</p>
<p>Newton’s method is an iterative improvement algorithm: it improves a guess of the zero for any function that is <em>differentiable</em>, which means that it can be approximated by a straight line at any point. Newton’s method follows these linear approximations to find function zeros.</p>
<p>Imagine a line through the point (x,f(x))(x,f(x)) that has the same slope as the curve for function f(x)f(x) at that point. Such a line is called the <em>tangent</em>, and its slope is called the <em>derivative</em> of ff at xx.</p>
<p>This line’s slope is the ratio of the change in function value to the change in function argument. Hence, translating xx by f(x)f(x) divided by the slope will give the argument value at which this tangent line touches 0.</p>
<p><img src="http://composingprograms.com/img/newton.png" alt="img"></p>
<p>A <code>newton_update</code> expresses the computational process of following this tangent line to 0, for a function <code>f</code>and its derivative <code>df</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def newton_update(f, df):</span><br><span class="line">        def update(x):</span><br><span class="line">            return x - f(x) &#x2F; df(x)</span><br><span class="line">        return update</span><br></pre></td></tr></table></figure>
<p>Finally, we can define the <code>find_root</code> function in terms of <code>newton_update</code>, our <code>improve</code> algorithm, and a comparison to see if f(x)f(x) is near 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def find_zero(f, df):</span><br><span class="line">        def near_zero(x):</span><br><span class="line">            return approx_eq(f(x), 0)</span><br><span class="line">        return improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></table></figure>
<p><strong>Computing Roots.</strong> Using Newton’s method, we can compute roots of arbitrary degree nn. The degree nn root of aa is xx such that x⋅x⋅x…x=ax⋅x⋅x…x=a with xx repeated nn times. For example,</p>
<ul>
<li>The square (second) root of 64 is 8, because 8⋅8=648⋅8=64.</li>
<li>The cube (third) root of 64 is 4, because 4⋅4⋅4=644⋅4⋅4=64.</li>
<li>The sixth root of 64 is 2, because 2⋅2⋅2⋅2⋅2⋅2=642⋅2⋅2⋅2⋅2⋅2=64.</li>
</ul>
<p>We can compute roots using Newton’s method with the following observations:</p>
<ul>
<li>The square root of 64 (written 64‾‾‾√64) is the value xx such that x2−64=0x2−64=0</li>
<li>More generally, the degree nn root of aa (written a‾√nan) is the value xx such that xn−a=0xn−a=0</li>
</ul>
<p>If we can find a zero of this last equation, then we can compute degree nn roots. By plotting the curves for nn equal to 2, 3, and 6 and aa equal to 64, we can visualize this relationship.</p>
<p><img src="http://composingprograms.com/img/curves.png" alt="img"></p>
<p><strong>Video:</strong> Show Hide</p>
<p>We first implement <code>square_root</code> by defining <code>f</code> and its derivative <code>df</code>. We use from calculus the fact that the derivative of f(x)=x2−af(x)=x2−a is the linear function df(x)=2xdf(x)=2x.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_root_newton(a):</span><br><span class="line">        def f(x):</span><br><span class="line">            return x * x - a</span><br><span class="line">        def df(x):</span><br><span class="line">            return 2 * x</span><br><span class="line">        return find_zero(f, df)</span><br><span class="line">&gt;&gt;&gt; square_root_newton(64)</span><br><span class="line">8.0</span><br></pre></td></tr></table></figure>
<p>Generalizing to roots of arbitrary degree nn, we compute f(x)=xn−af(x)=xn−a and its derivative df(x)=n⋅xn−1df(x)=n⋅xn−1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power(x, n):</span><br><span class="line">        &quot;&quot;&quot;Return x * x * x * ... * x for x repeated n times.&quot;&quot;&quot;</span><br><span class="line">        product, k &#x3D; 1, 0</span><br><span class="line">        while k &lt; n:</span><br><span class="line">            product, k &#x3D; product * x, k + 1</span><br><span class="line">        return product</span><br><span class="line">&gt;&gt;&gt; def nth_root_of_a(n, a):</span><br><span class="line">        def f(x):</span><br><span class="line">            return power(x, n) - a</span><br><span class="line">        def df(x):</span><br><span class="line">            return n * power(x, n-1)</span><br><span class="line">        return find_zero(f, df)</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(2, 64)</span><br><span class="line">8.0</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(3, 64)</span><br><span class="line">4.0</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(6, 64)</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<p>The approximation error in all of these computations can be reduced by changing the <code>tolerance</code> in <code>approx_eq</code> to a smaller number.</p>
<p>As you experiment with Newton’s method, be aware that it will not always converge. The initial guess of <code>improve</code> must be sufficiently close to the zero, and various conditions about the function must be met. Despite this shortcoming, Newton’s method is a powerful general computational method for solving differentiable equations. Very fast algorithms for logarithms and large integer division employ variants of the technique in modern computers.</p>
<h3 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6  Currying"></a>1.6.6  Currying</h3><p><strong>Video:</strong> Show Hide</p>
<p>We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument. More specifically, given a function <code>f(x, y)</code>, we can define a function <code>g</code> such that <code>g(x)(y)</code> is equivalent to <code>f(x, y)</code>. Here, <code>g</code> is a higher-order function that takes in a single argument <code>x</code> and returns another function that takes in a single argument <code>y</code>. This transformation is called <em>currying</em>.</p>
<p>As an example, we can define a curried version of the <code>pow</code> function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def curried_pow(x):</span><br><span class="line">        def h(y):</span><br><span class="line">            return pow(x, y)</span><br><span class="line">        return h</span><br><span class="line">&gt;&gt;&gt; curried_pow(2)(3)</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>Some programming languages, such as Haskell, only allow functions that take a single argument, so the programmer must curry all multi-argument procedures. In more general languages such as Python, currying is useful when we require a function that takes in only a single argument. For example, the <em>map</em>pattern applies a single-argument function to a sequence of values. In later chapters, we will see more general examples of the map pattern, but for now, we can implement the pattern in a function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def map_to_range(start, end, f):</span><br><span class="line">        while start &lt; end:</span><br><span class="line">            print(f(start))</span><br><span class="line">            start &#x3D; start + 1</span><br></pre></td></tr></table></figure>
<p>We can use <code>map_to_range</code> and <code>curried_pow</code> to compute the first ten powers of two, rather than specifically writing a function to do so:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map_to_range(0, 10, curried_pow(2))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">512</span><br></pre></td></tr></table></figure>
<p>We can similarly use the same two functions to compute powers of other numbers. Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.</p>
<p>In the above examples, we manually performed the currying transformation on the <code>pow</code> function to obtain <code>curried_pow</code>. Instead, we can define functions to automate currying, as well as the inverse <em>uncurrying</em>transformation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def curry2(f):</span><br><span class="line">        &quot;&quot;&quot;Return a curried version of the given two-argument function.&quot;&quot;&quot;</span><br><span class="line">        def g(x):</span><br><span class="line">            def h(y):</span><br><span class="line">                return f(x, y)</span><br><span class="line">            return h</span><br><span class="line">        return g</span><br><span class="line">&gt;&gt;&gt; def uncurry2(g):</span><br><span class="line">        &quot;&quot;&quot;Return a two-argument version of the given curried function.&quot;&quot;&quot;</span><br><span class="line">        def f(x, y):</span><br><span class="line">            return g(x)(y)</span><br><span class="line">        return f</span><br><span class="line">&gt;&gt;&gt; pow_curried &#x3D; curry2(pow)</span><br><span class="line">&gt;&gt;&gt; pow_curried(2)(5)</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; map_to_range(0, 10, pow_curried(2))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">512</span><br></pre></td></tr></table></figure>
<p>The <code>curry2</code> function takes in a two-argument function <code>f</code> and returns a single-argument function <code>g</code>. When <code>g</code> is applied to an argument <code>x</code>, it returns a single-argument function <code>h</code>. When <code>h</code> is applied to <code>y</code>, it calls <code>f(x, y)</code>. Thus, <code>curry2(f)(x)(y)</code> is equivalent to <code>f(x, y)</code>. The <code>uncurry2</code> function reverses the currying transformation, so that <code>uncurry2(curry2(f))</code> is equivalent to <code>f</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; uncurry2(pow_curried)(2, 5)</span><br><span class="line">32</span><br></pre></td></tr></table></figure>
<h3 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7  Lambda Expressions"></a>1.6.7  Lambda Expressions</h3><p><strong>Video:</strong> Show Hide</p>
<p>So far, each time we have wanted to define a new function, we needed to give it a name. But for other types of expressions, we don’t need to associate intermediate values with a name. That is, we can compute <code>a*b + c*d</code> without having to name the subexpressions <code>a*b</code> or <code>c*d</code>, or the full expression. In Python, we can create function values on the fly using <code>lambda</code> expressions, which evaluate to unnamed functions. A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def compose1(f, g):</span><br><span class="line">        return lambda x: f(g(x))</span><br></pre></td></tr></table></figure>
<p>We can understand the structure of a <code>lambda</code> expression by constructing a corresponding English sentence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     lambda            x            :          f(g(x))</span><br><span class="line">&quot;A function that    takes x    and returns     f(g(x))&quot;</span><br></pre></td></tr></table></figure>
<p>The result of a lambda expression is called a lambda function. It has no intrinsic name (and so Python prints `` for the name), but otherwise it behaves like any other function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; s(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure>
<p>In an environment diagram, the result of a lambda expression is a function as well, named with the greek letter λ (lambda). Our compose example can be expressed quite compactly with lambda expressions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose1</span><span class="params">(f, g)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line"></span><br><span class="line">f = compose1(<span class="keyword">lambda</span> x: x * x,</span><br><span class="line">             <span class="keyword">lambda</span> y: y + <span class="number">1</span>)</span><br><span class="line">result = f(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222006416.png" alt="image-20200206222006416" style="zoom:50%;"></p>
<p>Some programmers find that using unnamed functions from lambda expressions to be shorter and more direct. However, compound <code>lambda</code> expressions are notoriously illegible, despite their brevity. The following definition is correct, but many programmers have trouble understanding it quickly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; compose1 &#x3D; lambda f,g: lambda x: f(g(x))</span><br></pre></td></tr></table></figure>
<p>In general, Python style prefers explicit <code>def</code> statements to lambda expressions, but allows them in cases where a simple function is needed as an argument or return value.</p>
<p>Such stylistic rules are merely guidelines; you can program any way you wish. However, as you write programs, think about the audience of people who might read your program one day. When you can make your program easier to understand, you do those people a favor.</p>
<p>The term <em>lambda</em> is a historical accident resulting from the incompatibility of written mathematical notation and the constraints of early type-setting systems.</p>
<blockquote>
<p>It may seem perverse to use lambda to introduce a procedure/function. The notation goes back to Alonzo Church, who in the 1930’s started with a “hat” symbol; he wrote the square function as “ŷ . y × y”. But frustrated typographers moved the hat to the left of the parameter and changed it to a capital lambda: “Λy . y × y”; from there the capital lambda was changed to lowercase, and now we see “λy . y × y” in math books and <code>(lambda (y) (* y y))</code> in Lisp.</p>
<p>—Peter Norvig (norvig.com/lispy2.html)</p>
</blockquote>
<p>Despite their unusual etymology, <code>lambda</code> expressions and the corresponding formal language for function application, the <em>lambda calculus</em>, are fundamental computer science concepts shared far beyond the Python programming community. We will revisit this topic when we study the design of interpreters in Chapter 3.</p>
<h3 id="1-6-8-Abstractions-and-First-Class-Functions"><a href="#1-6-8-Abstractions-and-First-Class-Functions" class="headerlink" title="1.6.8  Abstractions and First-Class Functions"></a>1.6.8  Abstractions and First-Class Functions</h3><p><strong>Video:</strong> Show Hide</p>
<p>We began this section with the observation that user-defined functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we’ve seen how higher-order functions permit us to manipulate these general methods to create further abstractions.</p>
<p>As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs, build upon them, and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>
<p>In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the “rights and privileges” of first-class elements are:</p>
<ol>
<li>They may be bound to names.</li>
<li>They may be passed as arguments to functions.</li>
<li>They may be returned as the results of functions.</li>
<li>They may be included in data structures.</li>
</ol>
<p>Python awards functions full first-class status, and the resulting gain in expressive power is enormous.</p>
<h3 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9  Function Decorators"></a>1.6.9  Function Decorators</h3><p><strong>Video:</strong> Show Hide</p>
<p>Python provides special syntax to apply higher-order functions as part of executing a <code>def</code> statement, called a decorator. Perhaps the most common example is a trace.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def trace(fn):</span><br><span class="line">        def wrapped(x):</span><br><span class="line">            print(&#39;-&gt; &#39;, fn, &#39;(&#39;, x, &#39;)&#39;)</span><br><span class="line">            return fn(x)</span><br><span class="line">        return wrapped</span><br><span class="line">&gt;&gt;&gt; @trace</span><br><span class="line">    def triple(x):</span><br><span class="line">        return 3 * x</span><br><span class="line">&gt;&gt;&gt; triple(12)</span><br><span class="line">-&gt;  &lt;function triple at 0x102a39848&gt; ( 12 )</span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<p>In this example, A higher-order function <code>trace</code> is defined, which returns a function that precedes a call to its argument with a <code>print</code> statement that outputs the argument. The <code>def</code> statement for <code>triple</code> has an annotation, <code>@trace</code>, which affects the execution rule for <code>def</code>. As usual, the function <code>triple</code> is created. However, the name <code>triple</code> is not bound to this function. Instead, the name <code>triple</code> is bound to the returned function value of calling <code>trace</code> on the newly defined <code>triple</code> function. In code, this decorator is equivalent to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def triple(x):</span><br><span class="line">        return 3 * x</span><br><span class="line">&gt;&gt;&gt; triple &#x3D; trace(triple)</span><br></pre></td></tr></table></figure>
<p>In the projects associated with this text, decorators are used for tracing, as well as selecting which functions to call when a program is run from the command line.</p>
<p><strong>Extra for experts.</strong> The decorator symbol <code>@</code> may also be followed by a call expression. The expression following <code>@</code> is evaluated first (just as the name <code>trace</code> was evaluated above), the <code>def</code> statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the <code>def</code> statement. A <a href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html" target="_blank" rel="noopener">short tutorial on decorators</a> by Ariel Ortiz gives further examples for interested students.</p>
<h2 id="1-7-Recursive-Functions"><a href="#1-7-Recursive-Functions" class="headerlink" title="1.7  Recursive Functions"></a>1.7  Recursive Functions</h2><p><strong>Video:</strong> Show Hide</p>
<p>A function is called <em>recursive</em> if the body of the function calls the function itself, either directly or indirectly. That is, the process of executing the body of a recursive function may in turn require applying that function again. Recursive functions do not use any special syntax in Python, but they do require some effort to understand and create.</p>
<p>We’ll begin with an example problem: write a function that sums the digits of a natural number. When designing recursive functions, we look for ways in which a problem can be broken down into simpler problems. In this case, the operators <code>%</code> and <code>//</code> can be used to separate a number into two parts: its last digit and all but its last digit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 18117 % 10</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; 18117 &#x2F;&#x2F; 10</span><br><span class="line">1811</span><br></pre></td></tr></table></figure>
<p>The sum of the digits of 18117 is <code>1+8+1+1+7 = 18</code>. Just as we can separate the number, we can separate this sum into the last digit, 7, and the sum of all but the last digit, <code>1+8+1+1 = 11</code>. This separation gives us an algorithm: to sum the digits of a number <code>n</code>, add its last digit <code>n % 10</code> to the sum of the digits of <code>n // 10</code>. There’s one special case: if a number has only one digit, then the sum of its digits is itself. This algorithm can be implemented as a recursive function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_digits(n):</span><br><span class="line">        &quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;</span><br><span class="line">        if n &lt; 10:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            all_but_last, last &#x3D; n &#x2F;&#x2F; 10, n % 10</span><br><span class="line">            return sum_digits(all_but_last) + last</span><br></pre></td></tr></table></figure>
<p>This definition of <code>sum_digits</code> is both complete and correct, even though the <code>sum_digits</code> function is called within its own body. The problem of summing the digits of a number is broken down into two steps: summing all but the last digit, then adding the last digit. Both of these steps are simpler than the original problem. The function is recursive because the first step is the same kind of problem as the original problem. That is, <code>sum_digits</code> is exactly the function we need in order to implement <code>sum_digits</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum_digits(9)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; sum_digits(18117)</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; sum_digits(9437184)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; sum_digits(11408855402054064613470328848384)</span><br><span class="line">126</span><br></pre></td></tr></table></figure>
<p>We can understand precisely how this recursive function applies successfully using our environment model of computation. No new rules are required.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_digits</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        all_but_last, last = n // <span class="number">10</span>, n % <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum_digits(all_but_last) + last</span><br><span class="line"></span><br><span class="line">sum_digits(<span class="number">738</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222107575.png" alt="image-20200206222107575" style="zoom:50%;"></p>
<p>When the <code>def</code> statement is executed, the name <code>sum_digits</code> is bound to a new function, but the body of that function is not yet executed. Therefore, the circular nature of <code>sum_digits</code> is not a problem yet. Then, <code>sum_digits</code> is called on 738:</p>
<ol>
<li>A local frame for <code>sum_digits</code> with <code>n</code> bound to 738 is created, and the body of <code>sum_digits</code> is executed in the environment that starts with that frame.</li>
<li>Since 738 is not less than 10, the assignment statement on line 4 is executed, splitting 738 into 73 and 8.</li>
<li><p>In the following return statement, <code>sum_digits</code> is called on 73, the value of <code>all_but_last</code> in the current environment.</p>
</li>
<li><p>Another local frame for <code>sum_digits</code> is created, this time with <code>n</code> bound to 73. The body of <code>sum_digits</code> is again executed in the new environment that starts with this frame.</p>
</li>
<li>Since 73 is also not less than 10, 73 is split into 7 and 3 and <code>sum_digits</code> is called on 7, the value of <code>all_but_last</code> evaluated in this frame.</li>
<li>A third local frame for <code>sum_digits</code> is created, with <code>n</code> bound to 7.</li>
<li>In the environment starting with this frame, it is true that <code>n &lt; 10</code>, and therefore 7 is returned.</li>
<li>In the second local frame, this return value 7 is summed with 3, the value of <code>last</code>, to return 10.</li>
<li>In the first local frame, this return value 10 is summed with 8, the value of <code>last</code>, to return 18.</li>
</ol>
<p>This recursive function applies correctly, despite its circular character, because it is applied twice, but with a different argument each time. Moreover, the second application was a simpler instance of the digit summing problem than the first. Generate the environment diagram for the call <code>sum_digits(18117)</code> to see that each successive call to <code>sum_digits</code> takes a smaller argument than the last, until eventually a single-digit input is reached.</p>
<p>This example also illustrates how functions with simple bodies can evolve complex computational processes by using recursion.</p>
<h3 id="1-7-1-The-Anatomy-of-Recursive-Functions"><a href="#1-7-1-The-Anatomy-of-Recursive-Functions" class="headerlink" title="1.7.1  The Anatomy of Recursive Functions"></a>1.7.1  The Anatomy of Recursive Functions</h3><p><strong>Video:</strong> Show Hide</p>
<p>A common pattern can be found in the body of many recursive functions. The body begins with a <em>base case</em>, a conditional statement that defines the behavior of the function for the inputs that are simplest to process. In the case of <code>sum_digits</code>, the base case is any single-digit argument, and we simply return that argument. Some recursive functions will have multiple base cases.</p>
<p>The base cases are then followed by one or more <em>recursive calls</em>. Recursive calls always have a certain character: they simplify the original problem. Recursive functions express computation by simplifying problems incrementally. For example, summing the digits of 7 is simpler than summing the digits of 73, which in turn is simpler than summing the digits of 738. For each subsequent call, there is less work left to be done.</p>
<p>Recursive functions often solve problems in a different way than the iterative approaches that we have used previously. Consider a function <code>fact</code> to compute <code>n</code> factorial, where for example <code>fact(4)</code> computes 4!=4⋅3⋅2⋅1=244!=4⋅3⋅2⋅1=24.</p>
<p>A natural implementation using a <code>while</code> statement accumulates the total by multiplying together each positive integer up to <code>n</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fact_iter(n):</span><br><span class="line">        total, k &#x3D; 1, 1</span><br><span class="line">        while k &lt;&#x3D; n:</span><br><span class="line">            total, k &#x3D; total * k, k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; fact_iter(4)</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<p>On the other hand, a recursive implementation of factorial can express <code>fact(n)</code> in terms of <code>fact(n-1)</code>, a simpler problem. The base case of the recursion is the simplest form of the problem: <code>fact(1)</code> is 1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">fact(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222210261.png" alt="image-20200206222210261" style="zoom:50%;"></p>
<p>These two factorial functions differ conceptually. The iterative function constructs the result from the base case of 1 to the final total by successively multiplying in each term. The recursive function, on the other hand, constructs the result directly from the final term, <code>n</code>, and the result of the simpler problem, <code>fact(n-1)</code>.</p>
<p>As the recursion “unwinds” through successive applications of the <em>fact</em> function to simpler and simpler problem instances, the result is eventually built starting from the base case. The recursion ends by passing the argument 1 to <code>fact</code>; the result of each call depends on the next until the base case is reached.</p>
<p>The correctness of this recursive function is easy to verify from the standard definition of the mathematical function for factorial:</p>
<p>(n−1)!n!n!=(n−1)⋅(n−2)⋅⋯⋅1=n⋅(n−1)⋅(n−2)⋅⋯⋅1=n⋅(n−1)!(n−1)!=(n−1)⋅(n−2)⋅⋯⋅1n!=n⋅(n−1)⋅(n−2)⋅⋯⋅1n!=n⋅(n−1)!</p>
<p>While we can unwind the recursion using our model of computation, it is often clearer to think about recursive calls as functional abstractions. That is, we should not care about how <code>fact(n-1)</code> is implemented in the body of <code>fact</code>; we should simply trust that it computes the factorial of <code>n-1</code>. Treating a recursive call as a functional abstraction has been called a <em>recursive leap of faith</em>. We define a function in terms of itself, but simply trust that the simpler cases will work correctly when verifying the correctness of the function. In this example, we trust that <code>fact(n-1)</code> will correctly compute <code>(n-1)!</code>; we must only check that <code>n!</code> is computed correctly if this assumption holds. In this way, verifying the correctness of a recursive function is a form of proof by induction.</p>
<p>The functions <em>fact_iter</em> and <em>fact</em> also differ because the former must introduce two additional names, <code>total</code> and <code>k</code>, that are not required in the recursive implementation. In general, iterative functions must maintain some local state that changes throughout the course of computation. At any point in the iteration, that state characterizes the result of completed work and the amount of work remaining. For example, when <code>k</code> is 3 and total is 2, there are still two terms remaining to be processed, 3 and 4. On the other hand, <em>fact</em> is characterized by its single argument <code>n</code>. The state of the computation is entirely contained within the structure of the environment, which has return values that take the role of <code>total</code>, and binds <code>n</code> to different values in different frames rather than explicitly tracking <code>k</code>.</p>
<p>Recursive functions leverage the rules of evaluating call expressions to bind names to values, often avoiding the nuisance of correctly assigning local names during iteration. For this reason, recursive functions can be easier to define correctly. However, learning to recognize the computational processes evolved by recursive functions certainly requires practice.</p>
<h3 id="1-7-2-Mutual-Recursion"><a href="#1-7-2-Mutual-Recursion" class="headerlink" title="1.7.2  Mutual Recursion"></a>1.7.2  Mutual Recursion</h3><p><strong>Video:</strong> Show Hide</p>
<p>When a recursive procedure is divided among two functions that call each other, the functions are said to be <em>mutually recursive</em>. As an example, consider the following definition of even and odd for non-negative integers:</p>
<ul>
<li>a number is even if it is one more than an odd number</li>
<li>a number is odd if it is one more than an even number</li>
<li>0 is even</li>
</ul>
<p>Using this definition, we can implement mutually recursive functions to determine whether a number is even or odd:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1def is_even(n):2  if n == 0:3    return True4  else:5    return is_odd(n-1)67def is_odd(n):8  if n == 0:9    return False10  else:11    return is_even(n-1)1213result = is_even(4)<a href="http://composingprograms.com/tutor.html#code=def+is_even(n" target="_blank" rel="noopener">Edit code in Online Python Tutor</a>%3A ++++if+n+%3D%3D+0%3A ++++++++return+True ++++else%3A ++++++++return+is_odd(n-1) def+is_odd(n)%3A ++++if+n+%3D%3D+0%3A ++++++++return+False ++++else%3A ++++++++return+is_even(n-1) result+%3D+is_even(4))&lt; Back Step 1 of 18 Forward &gt; line that has just executed next line to execute</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>Mutually recursive functions can be turned into a single recursive function by breaking the abstraction boundary between the two functions. In this example, the body of <code>is_odd</code> can be incorporated into that of <code>is_even</code>, making sure to replace <code>n</code> with <code>n-1</code> in the body of <code>is_odd</code> to reflect the argument passed into it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def is_even(n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            if (n-1) &#x3D;&#x3D; 0:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                return is_even((n-1)-1)</span><br></pre></td></tr></table></figure>
<p>As such, mutual recursion is no more mysterious or powerful than simple recursion, and it provides a mechanism for maintaining abstraction within a complicated recursive program.</p>
<h3 id="1-7-3-Printing-in-Recursive-Functions"><a href="#1-7-3-Printing-in-Recursive-Functions" class="headerlink" title="1.7.3  Printing in Recursive Functions"></a>1.7.3  Printing in Recursive Functions</h3><p><strong>Video:</strong> Show Hide</p>
<p>The computational process evolved by a recursive function can often be visualized using calls to <code>print</code>. As an example, we will implement a function <code>cascade</code> that prints all prefixes of a number from largest to smallest to largest.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def cascade(n):</span><br><span class="line">        &quot;&quot;&quot;Print a cascade of prefixes of n.&quot;&quot;&quot;</span><br><span class="line">        if n &lt; 10:</span><br><span class="line">            print(n)</span><br><span class="line">        else:</span><br><span class="line">            print(n)</span><br><span class="line">            cascade(n&#x2F;&#x2F;10)</span><br><span class="line">            print(n)</span><br><span class="line">&gt;&gt;&gt; cascade(2013)</span><br><span class="line">2013</span><br><span class="line">201</span><br><span class="line">20</span><br><span class="line">2</span><br><span class="line">20</span><br><span class="line">201</span><br><span class="line">2013</span><br></pre></td></tr></table></figure>
<p>In this recursive function, the base case is a single-digit number, which is printed. Otherwise, a recursive call is placed between two calls to <code>print</code>.</p>
<p><strong>Video:</strong> Show Hide</p>
<p>It is not a rigid requirement that base cases be expressed before recursive calls. In fact, this function can be expressed more compactly by observing that <code>print(n)</code> is repeated in both clauses of the conditional statement, and therefore can precede it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def cascade(n):</span><br><span class="line">        &quot;&quot;&quot;Print a cascade of prefixes of n.&quot;&quot;&quot;</span><br><span class="line">        print(n)</span><br><span class="line">        if n &gt;&#x3D; 10:</span><br><span class="line">            cascade(n&#x2F;&#x2F;10)</span><br><span class="line">            print(n)</span><br></pre></td></tr></table></figure>
<p>As another example of mutual recursion, consider a two-player game in which there are <code>n</code> initial pebbles on a table. The players take turns, removing either one or two pebbles from the table, and the player who removes the final pebble wins. Suppose that Alice and Bob play this game, each using a simple strategy:</p>
<ul>
<li>Alice always removes a single pebble</li>
<li>Bob removes two pebbles if an even number of pebbles is on the table, and one otherwise</li>
</ul>
<p>Given <code>n</code> initial pebbles and Alice starting, who wins the game?</p>
<p>A natural decomposition of this problem is to encapsulate each strategy in its own function. This allows us to modify one strategy without affecting the other, maintaining the abstraction barrier between the two. In order to incorporate the turn-by-turn nature of the game, these two functions call each other at the end of each turn.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def play_alice(n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            print(&quot;Bob wins!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            play_bob(n-1)</span><br><span class="line">&gt;&gt;&gt; def play_bob(n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            print(&quot;Alice wins!&quot;)</span><br><span class="line">        elif is_even(n):</span><br><span class="line">            play_alice(n-2)</span><br><span class="line">        else:</span><br><span class="line">            play_alice(n-1)</span><br><span class="line">&gt;&gt;&gt; play_alice(20)</span><br><span class="line">Bob wins!</span><br></pre></td></tr></table></figure>
<p>In <code>play_bob</code>, we see that multiple recursive calls may appear in the body of a function. However, in this example, each call to <code>play_bob</code> calls <code>play_alice</code> at most once. In the next section, we consider what happens when a single function call makes multiple direct recursive calls.</p>
<h3 id="1-7-4-Tree-Recursion"><a href="#1-7-4-Tree-Recursion" class="headerlink" title="1.7.4  Tree Recursion"></a>1.7.4  Tree Recursion</h3><p><strong>Video:</strong> Show Hide</p>
<p>Another common pattern of computation is called tree recursion, in which a function calls itself more than once. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">result = fib(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222305459.png" alt="image-20200206222305459" style="zoom:50%;"></p>
<p>This recursive definition is tremendously appealing relative to our previous attempts: it exactly mirrors the familiar definition of Fibonacci numbers. A function with multiple recursive calls is said to be <em>tree recursive</em>because each call branches into multiple smaller calls, each of which branches into yet smaller calls, just as the branches of a tree become smaller but more numerous as they extend from the trunk.</p>
<p>We were already able to define a function to compute Fibonacci numbers without tree recursion. In fact, our previous attempts were more efficient, a topic discussed later in the text. Next, we consider a problem for which the tree recursive solution is substantially simpler than any iterative alternative.</p>
<h3 id="1-7-5-Example-Partitions"><a href="#1-7-5-Example-Partitions" class="headerlink" title="1.7.5  Example: Partitions"></a>1.7.5  Example: Partitions</h3><p><strong>Video:</strong> Show Hide</p>
<p>The number of partitions of a positive integer <code>n</code>, using parts up to size <code>m</code>, is the number of ways in which <code>n</code> can be expressed as the sum of positive integer parts up to <code>m</code> in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.</p>
<ol>
<li><code>6 = 2 + 4</code></li>
<li><code>6 = 1 + 1 + 4</code></li>
<li><code>6 = 3 + 3</code></li>
<li><code>6 = 1 + 2 + 3</code></li>
<li><code>6 = 1 + 1 + 1 + 3</code></li>
<li><code>6 = 2 + 2 + 2</code></li>
<li><code>6 = 1 + 1 + 2 + 2</code></li>
<li><code>6 = 1 + 1 + 1 + 1 + 2</code></li>
<li><code>6 = 1 + 1 + 1 + 1 + 1 + 1</code></li>
</ol>
<p>We will define a function <code>count_partitions(n, m)</code> that returns the number of different partitions of <code>n</code>using parts up to <code>m</code>. This function has a simple solution as a tree-recursive function, based on the following observation:</p>
<p>The number of ways to partition <code>n</code> using integers up to <code>m</code> equals</p>
<ol>
<li>the number of ways to partition <code>n-m</code> using integers up to <code>m</code>, and</li>
<li>the number of ways to partition <code>n</code> using integers up to <code>m-1</code>.</li>
</ol>
<p>To see why this is true, observe that all the ways of partitioning <code>n</code> can be divided into two groups: those that include at least one <code>m</code> and those that do not. Moreover, each partition in the first group is a partition of <code>n-m</code>, followed by <code>m</code> added at the end. In the example above, the first two partitions contain 4, and the rest do not.</p>
<p>Therefore, we can recursively reduce the problem of partitioning <code>n</code> using integers up to <code>m</code> into two simpler problems: (1) partition a smaller number <code>n-m</code>, and (2) partition with smaller components up to <code>m-1</code>.</p>
<p>To complete the implementation, we need to specify the following base cases:</p>
<ol>
<li>There is one way to partition 0: include no parts.</li>
<li>There are 0 ways to partition a negative <code>n</code>.</li>
<li>There are 0 ways to partition any <code>n</code> greater than 0 using parts of size 0 or less.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count_partitions(n, m):</span><br><span class="line">        &quot;&quot;&quot;Count the ways to partition n using parts up to m.&quot;&quot;&quot;</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return 1</span><br><span class="line">        elif n &lt; 0:</span><br><span class="line">            return 0</span><br><span class="line">        elif m &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            return count_partitions(n-m, m) + count_partitions(n, m-1)</span><br><span class="line">&gt;&gt;&gt; count_partitions(6, 4)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; count_partitions(5, 5)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; count_partitions(10, 10)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; count_partitions(15, 15)</span><br><span class="line">176</span><br><span class="line">&gt;&gt;&gt; count_partitions(20, 20)</span><br><span class="line">627</span><br></pre></td></tr></table></figure>
<p>We can think of a tree-recursive function as exploring different possibilities. In this case, we explore the possibility that we use a part of size <code>m</code> and the possibility that we do not. The first and second recursive calls correspond to these possibilities.</p>
<p>Implementing this function without recursion would be substantially more involved. Interested readers are encouraged to try.</p>
<h1 id="Chapter-2-Building-Abstractions-with-Data"><a href="#Chapter-2-Building-Abstractions-with-Data" class="headerlink" title="Chapter 2: Building Abstractions with Data"></a>Chapter 2: Building Abstractions with Data</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1  Introduction"></a>2.1  Introduction</h2><p>We concentrated in Chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic), how to form compound functions through composition and control, and how to create functional abstractions by giving names to processes. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason, in terms of general methods of computation. This is much of the essence of programming.</p>
<p>This chapter focuses on data. The techniques we investigate here will allow us to represent and manipulate information about many different domains. Due to the explosive growth of the Internet, a vast amount of structured information is freely available to all of us online, and computation can be applied to a vast range of different problems. Effective use of built-in and user-defined data types are fundamental to data processing applications.</p>
<h3 id="2-1-1-Native-Data-Types"><a href="#2-1-1-Native-Data-Types" class="headerlink" title="2.1.1  Native Data Types"></a>2.1.1  Native Data Types</h3><p>Every value in Python has a <em>class</em> that determines what type of value it is. Values that share a class also share behavior. For example, the integers <code>1</code> and <code>2</code> are both instances of the <code>int</code> class. These two values can be treated similarly. For example, they can both be negated or added to another integer. The built-in <code>type</code> function allows us to inspect the class of any value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(2)</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>The values we have used so far are instances of a small number of <em>native</em> data types that are built into the Python language. Native data types have the following properties:</p>
<ol>
<li>There are expressions that evaluate to values of native types, called <em>literals</em>.</li>
<li>There are built-in functions and operators to manipulate values of native types.</li>
</ol>
<p>The <code>int</code> class is the native data type used to represent integers. Integer literals (sequences of adjacent numerals) evaluate to <code>int</code> values, and mathematical operators manipulate these values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 12 + 3000000000000000000000000</span><br><span class="line">3000000000000000000000012</span><br></pre></td></tr></table></figure>
<p>Python includes three native numeric types: integers (<code>int</code>), real numbers (<code>float</code>), and complex numbers (<code>complex</code>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1.5)</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(1+1j)</span><br><span class="line">&lt;class &#39;complex&#39;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Floats.</strong> The name <code>float</code> comes from the way in which real numbers are represented in Python and many other programming languages: a “floating point” representation. While the details of how numbers are represented is not a topic for this text, some high-level differences between <code>int</code> and <code>float</code> objects are important to know. In particular, <code>int</code> objects represent integers exactly, without any approximation or limits on their size. On the other hand, <code>float</code> objects can represent a wide range of fractional numbers, but not all numbers can be represented exactly, and there are minimum and maximum values. Therefore, <code>float</code> values should be treated as approximations to real values. These approximations have only a finite amount of precision. Combining <code>float</code> values can lead to approximation errors; both of the following expressions would evaluate to <code>7</code> if not for approximation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 7 &#x2F; 3 * 3</span><br><span class="line">7.0</span><br><span class="line">&gt;&gt;&gt; 1 &#x2F; 3 * 7 * 3</span><br><span class="line">6.999999999999999</span><br></pre></td></tr></table></figure>
<p>Although <code>int</code> values are combined above, dividing one <code>int</code> by another yields a <code>float</code> value: a truncated finite approximation to the actual ratio of the two integers divided.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1&#x2F;3)</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; 1&#x2F;3</span><br><span class="line">0.3333333333333333</span><br></pre></td></tr></table></figure>
<p>Problems with this approximation appear when we conduct equality tests.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1&#x2F;3 &#x3D;&#x3D; 0.333333333333333312345  # Beware of float approximation</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>These subtle differences between the <code>int</code> and <code>float</code> class have wide-ranging consequences for writing programs, and so they are details that must be memorized by programmers. Fortunately, there are only a handful of native data types, limiting the amount of memorization required to become proficient in a programming language. Moreover, these same details are consistent across many programming languages, enforced by community guidelines such as the <a href="http://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="noopener">IEEE 754 floating point standard</a>.</p>
<p><strong>Non-numeric types.</strong> Values can represent many other types of data, such as sounds, images, locations, web addresses, network connections, and more. A few are represented by native data types, such as the <code>bool</code> class for values <code>True</code> and <code>False</code>. The type for most values must be defined by programmers using the means of combination and abstraction that we will develop in this chapter.</p>
<p>The following sections introduce more of Python’s native data types, focusing on the role they play in creating useful data abstractions. For those interested in further details, a chapter on <a href="http://getpython3.com/diveintopython3/native-datatypes.html" target="_blank" rel="noopener">native data types</a> in the online book Dive Into Python 3 gives a pragmatic overview of all Python’s native data types and how to manipulate them, including numerous usage examples and practical tips.</p>
<h2 id="2-2-Data-Abstraction"><a href="#2-2-Data-Abstraction" class="headerlink" title="2.2  Data Abstraction"></a>2.2  Data Abstraction</h2><p>As we consider the wide set of things in the world that we would like to represent in our programs, we find that most of them have compound structure. For example, a geographic position has latitude and longitude coordinates. To represent positions, we would like our programming language to have the capacity to couple together a latitude and longitude to form a pair, a <em>compound data</em> value that our programs can manipulate as a single conceptual unit, but which also has two parts that can be considered individually.</p>
<p>The use of compound data enables us to increase the modularity of our programs. If we can manipulate geographic positions as whole values, then we can shield parts of our program that compute using positions from the details of how those positions are represented. The general technique of isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulated is a powerful design methodology called <em>data abstraction</em>. Data abstraction makes programs much easier to design, maintain, and modify.</p>
<p>Data abstraction is similar in character to functional abstraction. When we create a functional abstraction, the details of how a function is implemented can be suppressed, and the particular function itself can be replaced by any other function with the same overall behavior. In other words, we can make an abstraction that separates the way the function is used from the details of how the function is implemented. Analogously, data abstraction isolates how a compound data value is used from the details of how it is constructed.</p>
<p>The basic idea of data abstraction is to structure programs so that they operate on abstract data. That is, our programs should use data in such a way as to make as few assumptions about the data as possible. At the same time, a concrete data representation is defined as an independent part of the program.</p>
<p>These two parts of a program, the part that operates on abstract data and the part that defines a concrete representation, are connected by a small set of functions that implement abstract data in terms of the concrete representation. To illustrate this technique, we will consider how to design a set of functions for manipulating rational numbers.</p>
<h3 id="2-2-1-Example-Rational-Numbers"><a href="#2-2-1-Example-Rational-Numbers" class="headerlink" title="2.2.1  Example: Rational Numbers"></a>2.2.1  Example: Rational Numbers</h3><p>A rational number is a ratio of integers, and rational numbers constitute an important sub-class of real numbers. A rational number such as <code>1/3</code> or <code>17/29</code> is typically written as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;numerator&gt;&#x2F;&lt;denominator&gt;</span><br></pre></td></tr></table></figure>
<p>where both the <code>and</code> are placeholders for integer values. Both parts are needed to exactly characterize the value of the rational number. Actually dividing integers produces a <code>float</code> approximation, losing the exact precision of integers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1&#x2F;3</span><br><span class="line">0.3333333333333333</span><br><span class="line">&gt;&gt;&gt; 1&#x2F;3 &#x3D;&#x3D; 0.333333333333333300000  # Dividing integers yields an approximation</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>However, we can create an exact representation for rational numbers by combining together the numerator and denominator.</p>
<p>We know from using functional abstractions that we can start programming productively before we have an implementation of some parts of our program. Let us begin by assuming that we already have a way of constructing a rational number from a numerator and a denominator. We also assume that, given a rational number, we have a way of selecting its numerator and its denominator component. Let us further assume that the constructor and selectors are available as the following three functions:</p>
<ul>
<li><code>rational(n, d)</code> returns the rational number with numerator <code>n</code> and denominator <code>d</code>.</li>
<li><code>numer(x)</code> returns the numerator of the rational number <code>x</code>.</li>
<li><code>denom(x)</code> returns the denominator of the rational number <code>x</code>.</li>
</ul>
<p>We are using here a powerful strategy for designing programs: <em>wishful thinking</em>. We haven’t yet said how a rational number is represented, or how the functions <code>numer</code>, <code>denom</code>, and <code>rational</code> should be implemented. Even so, if we did define these three functions, we could then add, multiply, print, and test equality of rational numbers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_rationals(x, y):</span><br><span class="line">        nx, dx &#x3D; numer(x), denom(x)</span><br><span class="line">        ny, dy &#x3D; numer(y), denom(y)</span><br><span class="line">        return rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line">&gt;&gt;&gt; def mul_rationals(x, y):</span><br><span class="line">        return rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line">&gt;&gt;&gt; def print_rational(x):</span><br><span class="line">        print(numer(x), &#39;&#x2F;&#39;, denom(x))</span><br><span class="line">&gt;&gt;&gt; def rationals_are_equal(x, y):</span><br><span class="line">        return numer(x) * denom(y) &#x3D;&#x3D; numer(y) * denom(x)</span><br></pre></td></tr></table></figure>
<p>Now we have the operations on rational numbers defined in terms of the selector functions <code>numer</code> and <code>denom</code>, and the constructor function <code>rational</code>, but we haven’t yet defined these functions. What we need is some way to glue together a numerator and a denominator into a compound value.</p>
<h3 id="2-2-2-Pairs"><a href="#2-2-2-Pairs" class="headerlink" title="2.2.2  Pairs"></a>2.2.2  Pairs</h3><p>To enable us to implement the concrete level of our data abstraction, Python provides a compound structure called a <code>list</code>, which can be constructed by placing expressions within square brackets separated by commas. Such an expression is called a list literal.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [10, 20]</span><br><span class="line">[10, 20]</span><br></pre></td></tr></table></figure>
<p>The elements of a list can be accessed in two ways. The first way is via our familiar method of multiple assignment, which unpacks a list into its elements and binds each element to a different name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pair &#x3D; [10, 20]</span><br><span class="line">&gt;&gt;&gt; pair</span><br><span class="line">[10, 20]</span><br><span class="line">&gt;&gt;&gt; x, y &#x3D; pair</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>A second method for accessing the elements in a list is by the element selection operator, also expressed using square brackets. Unlike a list literal, a square-brackets expression directly following another expression does not evaluate to a <code>list</code> value, but instead selects an element from the value of the preceding expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pair[0]</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; pair[1]</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>Lists in Python (and sequences in most other programming languages) are 0-indexed, meaning that the index 0 selects the first element, index 1 selects the second, and so on. One intuition that supports this indexing convention is that the index represents how far an element is offset from the beginning of the list.</p>
<p>The equivalent function for the element selection operator is called <code>getitem</code>, and it also uses 0-indexed positions to select elements from a list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import getitem</span><br><span class="line">&gt;&gt;&gt; getitem(pair, 0)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; getitem(pair, 1)</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>Two-element lists are not the only method of representing pairs in Python. Any way of bundling two values together into one can be considered a pair. Lists are a common method to do so. Lists can also contain more than two elements, as we will explore later in the chapter.</p>
<p><strong>Representing Rational Numbers.</strong> We can now represent a rational number as a pair of two integers: a numerator and a denominator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def rational(n, d):</span><br><span class="line">        return [n, d]</span><br><span class="line">&gt;&gt;&gt; def numer(x):</span><br><span class="line">        return x[0]</span><br><span class="line">&gt;&gt;&gt; def denom(x):</span><br><span class="line">        return x[1]</span><br></pre></td></tr></table></figure>
<p>Together with the arithmetic operations we defined earlier, we can manipulate rational numbers with the functions we have defined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; half &#x3D; rational(1, 2)</span><br><span class="line">&gt;&gt;&gt; print_rational(half)</span><br><span class="line">1 &#x2F; 2</span><br><span class="line">&gt;&gt;&gt; third &#x3D; rational(1, 3)</span><br><span class="line">&gt;&gt;&gt; print_rational(mul_rationals(half, third))</span><br><span class="line">1 &#x2F; 6</span><br><span class="line">&gt;&gt;&gt; print_rational(add_rationals(third, third))</span><br><span class="line">6 &#x2F; 9</span><br></pre></td></tr></table></figure>
<p>As the example above shows, our rational number implementation does not reduce rational numbers to lowest terms. We can remedy this flaw by changing the implementation of <code>rational</code>. If we have a function for computing the greatest common denominator of two integers, we can use it to reduce the numerator and the denominator to lowest terms before constructing the pair. As with many useful tools, such a function already exists in the Python Library.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from fractions import gcd</span><br><span class="line">&gt;&gt;&gt; def rational(n, d):</span><br><span class="line">        g &#x3D; gcd(n, d)</span><br><span class="line">        return (n&#x2F;&#x2F;g, d&#x2F;&#x2F;g)</span><br></pre></td></tr></table></figure>
<p>The floor division operator, <code>//</code>, expresses integer division, which rounds down the fractional part of the result of division. Since we know that <code>g</code> divides both <code>n</code> and <code>d</code> evenly, integer division is exact in this case. This revised <code>rational</code> implementation ensures that rationals are expressed in lowest terms.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print_rational(add_rationals(third, third))</span><br><span class="line">2 &#x2F; 3</span><br></pre></td></tr></table></figure>
<p>This improvement was accomplished by changing the constructor without changing any of the functions that implement the actual arithmetic operations.</p>
<h3 id="2-2-3-Abstraction-Barriers"><a href="#2-2-3-Abstraction-Barriers" class="headerlink" title="2.2.3  Abstraction Barriers"></a>2.2.3  Abstraction Barriers</h3><p>Before continuing with more examples of compound data and data abstraction, let us consider some of the issues raised by the rational number example. We defined operations in terms of a constructor <code>rational</code> and selectors <code>numer</code> and <code>denom</code>. In general, the underlying idea of data abstraction is to identify a basic set of operations in terms of which all manipulations of values of some kind will be expressed, and then to use only those operations in manipulating the data. By restricting the use of operations in this way, it is much easier to change the representation of abstract data without changing the behavior of a program.</p>
<p>For rational numbers, different parts of the program manipulate rational numbers using different operations, as described in this table.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Parts of the program that…</strong></th>
<th style="text-align:left"><strong>Treat rationals as…</strong></th>
<th style="text-align:left"><strong>Using only…</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Use rational numbers to perform computation</td>
<td style="text-align:left">whole data values</td>
<td style="text-align:left"><code>add_rational, mul_rational, rationals_are_equal, print_rational</code></td>
</tr>
<tr>
<td style="text-align:left">Create rationals or implement rational operations</td>
<td style="text-align:left">numerators and denominators</td>
<td style="text-align:left"><code>rational, numer, denom</code></td>
</tr>
<tr>
<td style="text-align:left">Implement selectors and constructor for rationals</td>
<td style="text-align:left">two-element lists</td>
<td style="text-align:left">list literals and element selection</td>
</tr>
</tbody>
</table>
</div>
<p>In each layer above, the functions in the final column enforce an abstraction barrier. These functions are called by a higher level and implemented using a lower level of abstraction.</p>
<p>An abstraction barrier violation occurs whenever a part of the program that can use a higher level function instead uses a function in a lower level. For example, a function that computes the square of a rational number is best implemented in terms of <code>mul_rational</code>, which does not assume anything about the implementation of a rational number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure>
<p>Referring directly to numerators and denominators would violate one abstraction barrier.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational_violating_once(x):</span><br><span class="line">        return rational(numer(x) * numer(x), denom(x) * denom(x))</span><br></pre></td></tr></table></figure>
<p>Assuming that rationals are represented as two-element lists would violate two abstraction barriers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational_violating_twice(x):</span><br><span class="line">        return [x[0] * x[0], x[1] * x[1]]</span><br></pre></td></tr></table></figure>
<p>Abstraction barriers make programs easier to maintain and to modify. The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation. All of these implementations of <code>square_rational</code> have the correct behavior, but only the first is robust to future changes. The <code>square_rational</code> function would not require updating even if we altered the representation of rational numbers. By contrast, <code>square_rational_violating_once</code> would need to be changed whenever the selector or constructor signatures changed, and<code>square_rational_violating_twice</code> would require updating whenever the implementation of rational numbers changed.</p>
<h3 id="2-2-4-The-Properties-of-Data"><a href="#2-2-4-The-Properties-of-Data" class="headerlink" title="2.2.4  The Properties of Data"></a>2.2.4  The Properties of Data</h3><p>Abstraction barriers shape the way in which we think about data. A valid representation of a rational number is not restricted to any particular implementation (such as a two-element list); it is a value returned by <code>rational</code> that can be passed to <code>numer</code>, and <code>denom</code>. In addition, the appropriate relationship must hold among the constructor and selectors. That is, if we construct a rational number <code>x</code> from integers <code>n</code> and <code>d</code>, then it should be the case that <code>numer(x)/denom(x)</code> is equal to <code>n/d</code>.</p>
<p>In general, we can express abstract data using a collection of selectors and constructors, together with some behavior conditions. As long as the behavior conditions are met (such as the division property above), the selectors and constructors constitute a valid representation of a kind of data. The implementation details below an abstraction barrier may change, but if the behavior does not, then the data abstraction remains valid, and any program written using this data abstraction will remain correct.</p>
<p>This point of view can be applied broadly, including to the pair values that we used to implement rational numbers. We never actually said much about what a pair was, only that the language supplied the means to create and manipulate lists with two elements. The behavior we require to implement a pair is that it glues two values together. Stated as a behavior condition,</p>
<ul>
<li>If a pair <code>p</code> was constructed from values <code>x</code> and <code>y</code>, then <code>select(p, 0)</code> returns <code>x</code>, and <code>select(p, 1)</code>returns <code>y</code>.</li>
</ul>
<p>We don’t actually need the <code>list</code> type to create pairs. Instead, we can implement two functions <code>pair</code> and <code>select</code> that fulfill this description just as well as a two-element list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pair(x, y):</span><br><span class="line">        &quot;&quot;&quot;Return a function that represents a pair.&quot;&quot;&quot;</span><br><span class="line">        def get(index):</span><br><span class="line">            if index &#x3D;&#x3D; 0:</span><br><span class="line">                return x</span><br><span class="line">            elif index &#x3D;&#x3D; 1:</span><br><span class="line">                return y</span><br><span class="line">        return get</span><br><span class="line">&gt;&gt;&gt; def select(p, i):</span><br><span class="line">        &quot;&quot;&quot;Return the element at index i of pair p.&quot;&quot;&quot;</span><br><span class="line">        return p(i)</span><br></pre></td></tr></table></figure>
<p>With this implementation, we can create and manipulate pairs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; pair(20, 14)</span><br><span class="line">&gt;&gt;&gt; select(p, 0)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; select(p, 1)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>This use of higher-order functions corresponds to nothing like our intuitive notion of what data should be. Nevertheless, these functions suffice to represent pairs in our programs. Functions are sufficient to represent compound data.</p>
<p>The point of exhibiting the functional representation of a pair is not that Python actually works this way (lists are implemented more directly, for efficiency reasons) but that it could work this way. The functional representation, although obscure, is a perfectly adequate way to represent pairs, since it fulfills the only conditions that pairs need to fulfill. The practice of data abstraction allows us to switch among representations easily.</p>
<h2 id="2-3-Sequences"><a href="#2-3-Sequences" class="headerlink" title="2.3  Sequences"></a>2.3  Sequences</h2><p>A sequence is an ordered collection of values. The sequence is a powerful, fundamental abstraction in computer science. Sequences are not instances of a particular built-in type or abstract data representation, but instead a collection of behaviors that are shared among several different types of data. That is, there are many kinds of sequences, but they all share common behavior. In particular,</p>
<p><strong>Length.</strong> A sequence has a finite length. An empty sequence has length 0.</p>
<p><strong>Element selection.</strong> A sequence has an element corresponding to any non-negative integer index less than its length, starting at 0 for the first element.</p>
<p>Python includes several native data types that are sequences, the most important of which is the <code>list</code>.</p>
<h3 id="2-3-1-Lists"><a href="#2-3-1-Lists" class="headerlink" title="2.3.1  Lists"></a>2.3.1  Lists</h3><p>A <code>list</code> value is a sequence that can have arbitrary length. Lists have a large set of built-in behaviors, along with specific syntax to express those behaviors. We have already seen the list literal, which evaluates to a <code>list</code> instance, as well as an element selection expression that evaluates to a value in the list. The built-in <code>len</code> function returns the length of a sequence. Below, <code>digits</code> is a list with four elements. The element at index 3 is 8.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits &#x3D; [1, 8, 2, 8]</span><br><span class="line">&gt;&gt;&gt; len(digits)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; digits[3]</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>Additionally, lists can be added together and multiplied by integers. For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves. That is, the <code>add</code> function in the <code>operator</code> module (and the <code>+</code> operator) yields a list that is the concatenation of the added arguments. The <code>mul</code> function in <code>operator</code> (and the <code>*</code> operator) can take a list and an integer <code>k</code> to return the list that consists of <code>k</code> repetitions of the original list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [2, 7] + digits * 2</span><br><span class="line">[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span><br></pre></td></tr></table></figure>
<p>Any values can be included in a list, including another list. Element selection can be applied multiple times in order to select a deeply nested element in a list containing lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pairs &#x3D; [[10, 20], [30, 40]]</span><br><span class="line">&gt;&gt;&gt; pairs[1]</span><br><span class="line">[30, 40]</span><br><span class="line">&gt;&gt;&gt; pairs[1][0]</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-Sequence-Iteration"><a href="#2-3-2-Sequence-Iteration" class="headerlink" title="2.3.2  Sequence Iteration"></a>2.3.2  Sequence Iteration</h3><p>In many cases, we would like to iterate over the elements of a sequence and perform some computation for each element in turn. This pattern is so common that Python has an additional control statement to process sequential data: the <code>for</code> statement.</p>
<p>Consider the problem of counting how many times a value appears in a sequence. We can implement a function to compute this count using a <code>while</code> loop.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count(s, value):</span><br><span class="line">        &quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br><span class="line">        total, index &#x3D; 0, 0</span><br><span class="line">        while index &lt; len(s):</span><br><span class="line">            if s[index] &#x3D;&#x3D; value:</span><br><span class="line">                total &#x3D; total + 1</span><br><span class="line">            index &#x3D; index + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; count(digits, 8)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>The Python <code>for</code> statement can simplify this function body by iterating over the element values directly without introducing the name <code>index</code> at all.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count(s, value):</span><br><span class="line">        &quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br><span class="line">        total &#x3D; 0</span><br><span class="line">        for elem in s:</span><br><span class="line">            if elem &#x3D;&#x3D; value:</span><br><span class="line">                total &#x3D; total + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; count(digits, 8)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>A <code>for</code> statement consists of a single clause with the form:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &lt;name&gt; in &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>A <code>for</code> statement is executed by the following procedure:</p>
<ol>
<li>Evaluate the header ``, which must yield an iterable value.</li>
<li>For each element value in that iterable value, in order:<ol>
<li>Bind `` to that value in the current frame.</li>
<li>Execute the ``.</li>
</ol>
</li>
</ol>
<p>This execution procedure refers to <em>iterable values</em>. Lists are a type of sequence, and sequences are iterable values. Their elements are considered in their sequential order. Python includes other iterable types, but we will focus on sequences for now; the general definition of the term “iterable” appears in the section on iterators in Chapter 4.</p>
<p>An important consequence of this evaluation procedure is that <code>` will be bound to the last element of the sequence after the</code>for<code>statement is executed. The</code>for` loop introduces yet another way in which the environment can be updated by a statement.</p>
<p><strong>Sequence unpacking.</strong> A common pattern in programs is to have a sequence of elements that are themselves sequences, but all of a fixed length. A <code>for</code> statement may include multiple names in its header to “unpack” each element sequence into its respective elements. For example, we may have a list of two-element lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pairs &#x3D; [[1, 2], [2, 2], [2, 3], [4, 4]]</span><br></pre></td></tr></table></figure>
<p>and wish to find the number of these pairs that have the same first and second element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; same_count &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>The following <code>for</code> statement with two names in its header will bind each name <code>x</code> and <code>y</code> to the first and second elements in each pair, respectively.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x, y in pairs:</span><br><span class="line">        if x &#x3D;&#x3D; y:</span><br><span class="line">            same_count &#x3D; same_count + 1</span><br><span class="line">&gt;&gt;&gt; same_count</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>This pattern of binding multiple names to multiple values in a fixed-length sequence is called <em>sequence unpacking</em>; it is the same pattern that we see in assignment statements that bind multiple names to multiple values.</p>
<p><strong>Ranges.</strong> A <code>range</code> is another built-in type of sequence in Python, which represents a range of integers. Ranges are created with <code>range</code>, which takes two integer arguments: the first number and one beyond the last number in the desired range.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(1, 10)  # Includes 1, but not 10</span><br><span class="line">range(1, 10)</span><br></pre></td></tr></table></figure>
<p>Calling the <code>list</code> constructor on a range evaluates to a list with the same elements as the range, so that the elements can be easily inspected.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5, 8))</span><br><span class="line">[5, 6, 7]</span><br></pre></td></tr></table></figure>
<p>If only one argument is given, it is interpreted as one beyond the last value for a range that starts at 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(4))</span><br><span class="line">[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>Ranges commonly appear as the expression in a <code>for</code> header to specify the number of times that the suite should be executed: A common convention is to use a single underscore character for the name in the <code>for</code> header if the name is unused in the suite:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#39;Go Bears!&#39;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>
<p>This underscore is just another name in the environment as far as the interpreter is concerned, but has a conventional meaning among programmers that indicates the name will not appear in any future expressions.</p>
<h3 id="2-3-3-Sequence-Processing"><a href="#2-3-3-Sequence-Processing" class="headerlink" title="2.3.3  Sequence Processing"></a>2.3.3  Sequence Processing</h3><p>Sequences are such a common form of compound data that whole programs are often organized around this single abstraction. Modular components that have sequences as both inputs and outputs can be mixed and matched to perform data processing. Complex components can be defined by chaining together a pipeline of sequence processing operations, each of which is simple and focused.</p>
<p><strong>List Comprehensions.</strong> Many sequence processing operations can be expressed by evaluating a fixed expression for each element in a sequence and collecting the resulting values in a result sequence. In Python, a list comprehension is an expression that performs such a computation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; odds &#x3D; [1, 3, 5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; [x+1 for x in odds]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>
<p>The <code>for</code> keyword above is not part of a <code>for</code> statement, but instead part of a list comprehension because it is contained within square brackets. The sub-expression <code>x+1</code> is evaluated with <code>x</code> bound to each element of <code>odds</code> in turn, and the resulting values are collected into a list.</p>
<p>Another common sequence processing operation is to select a subset of values that satisfy some condition. List comprehensions can also express this pattern, for instance selecting all elements of <code>odds</code>that evenly divide <code>25</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in odds if 25 % x &#x3D;&#x3D; 0]</span><br><span class="line">[1, 5]</span><br></pre></td></tr></table></figure>
<p>The general form of a list comprehension is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;]</span><br></pre></td></tr></table></figure>
<p>To evaluate a list comprehension, Python evaluates the <code>, which must return an iterable value. Then, for each element in order, the element value is bound to</code>, the filter expression is evaluated, and if it yields a true value, the map expression is evaluated. The values of the map expression are collected into a list.</p>
<p><strong>Aggregation.</strong> A third common pattern in sequence processing is to aggregate all values in a sequence into a single value. The built-in functions <code>sum</code>, <code>min</code>, and <code>max</code> are all examples of aggregation functions.</p>
<p>By combining the patterns of evaluating an expression for each element, selecting a subset of elements, and aggregating elements, we can solve problems using a sequence processing approach.</p>
<p>A perfect number is a positive integer that is equal to the sum of its divisors. The divisors of <code>n</code> are positive integers less than <code>n</code> that divide evenly into <code>n</code>. Listing the divisors of <code>n</code> can be expressed with a list comprehension.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divisors(n):</span><br><span class="line">        return [1] + [x for x in range(2, n) if n % x &#x3D;&#x3D; 0]</span><br><span class="line">&gt;&gt;&gt; divisors(4)</span><br><span class="line">[1, 2]</span><br><span class="line">&gt;&gt;&gt; divisors(12)</span><br><span class="line">[1, 2, 3, 4, 6]</span><br></pre></td></tr></table></figure>
<p>Using <code>divisors</code>, we can compute all perfect numbers from 1 to 1000 with another list comprehension. (1 is typically considered to be a perfect number as well, but it does not qualify under our definition of <code>divisors</code>.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [n for n in range(1, 1000) if sum(divisors(n)) &#x3D;&#x3D; n]</span><br><span class="line">[6, 28, 496]</span><br></pre></td></tr></table></figure>
<p>We can reuse our definition of <code>divisors</code> to solve another problem, finding the minimum perimeter of a rectangle with integer side lengths, given its area. The area of a rectangle is its height times its width. Therefore, given the area and height, we can compute the width. We can assert that both the width and height evenly divide the area to ensure that the side lengths are integers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def width(area, height):</span><br><span class="line">        assert area % height &#x3D;&#x3D; 0</span><br><span class="line">        return area &#x2F;&#x2F; height</span><br></pre></td></tr></table></figure>
<p>The perimeter of a rectangle is the sum of its side lengths.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def perimeter(width, height):</span><br><span class="line">        return 2 * width + 2 * height</span><br></pre></td></tr></table></figure>
<p>The height of a rectangle with integer side lengths must be a divisor of its area. We can compute the minimum perimeter by considering all heights.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def minimum_perimeter(area):</span><br><span class="line">        heights &#x3D; divisors(area)</span><br><span class="line">        perimeters &#x3D; [perimeter(width(area, h), h) for h in heights]</span><br><span class="line">        return min(perimeters)</span><br><span class="line">&gt;&gt;&gt; area &#x3D; 80</span><br><span class="line">&gt;&gt;&gt; width(area, 5)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; perimeter(16, 5)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; perimeter(10, 8)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; minimum_perimeter(area)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; [minimum_perimeter(n) for n in range(1, 10)]</span><br><span class="line">[4, 6, 8, 8, 12, 10, 16, 12, 12]</span><br></pre></td></tr></table></figure>
<p><strong>Higher-Order Functions.</strong> The common patterns we have observed in sequence processing can be expressed using higher-order functions. First, evaluating an expression for each element in a sequence can be expressed by applying a function to each element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def apply_to_all(map_fn, s):</span><br><span class="line">        return [map_fn(x) for x in s]</span><br></pre></td></tr></table></figure>
<p>Selecting only elements for which some expression is true can be expressed by applying a function to each element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def keep_if(filter_fn, s):</span><br><span class="line">        return [x for x in s if filter_fn(x)]</span><br></pre></td></tr></table></figure>
<p>Finally, many forms of aggregation can be expressed as repeatedly applying a two-argument function to the <code>reduced</code> value so far and each element in turn.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def reduce(reduce_fn, s, initial):</span><br><span class="line">        reduced &#x3D; initial</span><br><span class="line">        for x in s:</span><br><span class="line">            reduced &#x3D; reduce_fn(reduced, x)</span><br><span class="line">        return reduced</span><br></pre></td></tr></table></figure>
<p>For example, <code>reduce</code> can be used to multiply together all elements of a sequence. Using <code>mul</code> as the <code>reduce_fn</code> and 1 as the <code>initial</code> value, <code>reduce</code> can be used to multiply together a sequence of numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>We can find perfect numbers using these higher-order functions as well.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divisors_of(n):</span><br><span class="line">        divides_n &#x3D; lambda x: n % x &#x3D;&#x3D; 0</span><br><span class="line">        return [1] + keep_if(divides_n, range(2, n))</span><br><span class="line">&gt;&gt;&gt; divisors_of(12)</span><br><span class="line">[1, 2, 3, 4, 6]</span><br><span class="line">&gt;&gt;&gt; from operator import add</span><br><span class="line">&gt;&gt;&gt; def sum_of_divisors(n):</span><br><span class="line">        return reduce(add, divisors_of(n), 0)</span><br><span class="line">&gt;&gt;&gt; def perfect(n):</span><br><span class="line">        return sum_of_divisors(n) &#x3D;&#x3D; n</span><br><span class="line">&gt;&gt;&gt; keep_if(perfect, range(1, 1000))</span><br><span class="line">[1, 6, 28, 496]</span><br></pre></td></tr></table></figure>
<p><strong>Conventional Names.</strong> In the computer science community, the more common name for <code>apply_to_all</code>is <code>map</code> and the more common name for <code>keep_if</code> is <code>filter</code>. In Python, the built-in <code>map</code> and <code>filter</code> are generalizations of these functions that do not return lists. These functions are discussed in Chapter 4. The definitions above are equivalent to applying the <code>list</code> constructor to the result of built-in <code>map</code> and <code>filter</code> calls.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; apply_to_all &#x3D; lambda map_fn, s: list(map(map_fn, s))</span><br><span class="line">&gt;&gt;&gt; keep_if &#x3D; lambda filter_fn, s: list(filter(filter_fn, s))</span><br></pre></td></tr></table></figure>
<p>The <code>reduce</code> function is built into the <code>functools</code> module of the Python standard library. In this version, the <code>initial</code> argument is optional.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def product(s):</span><br><span class="line">        return reduce(mul, s)</span><br><span class="line">&gt;&gt;&gt; product([1, 2, 3, 4, 5])</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p>In Python programs, it is more common to use list comprehensions directly rather than higher-order functions, but both approaches to sequence processing are widely used.</p>
<h3 id="2-3-4-Sequence-Abstraction"><a href="#2-3-4-Sequence-Abstraction" class="headerlink" title="2.3.4  Sequence Abstraction"></a>2.3.4  Sequence Abstraction</h3><p>We have introduced two native data types that satisfy the sequence abstraction: lists and ranges. Both satisfy the conditions with which we began this section: length and element selection. Python includes two more behaviors of sequence types that extend the sequence abstraction.</p>
<p><strong>Membership.</strong> A value can be tested for membership in a sequence. Python has two operators <code>in</code> and <code>not in</code> that evaluate to <code>True</code> or <code>False</code> depending on whether an element appears in a sequence.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits</span><br><span class="line">[1, 8, 2, 8]</span><br><span class="line">&gt;&gt;&gt; 2 in digits</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 1828 not in digits</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><strong>Slicing.</strong> Sequences contain smaller sequences within them. A <em>slice</em> of a sequence is any contiguous span of the original sequence, designated by a pair of integers. As with the <code>range</code> constructor, the first integer indicates the starting index of the slice and the second indicates one beyond the ending index.</p>
<p>In Python, sequence slicing is expressed similarly to element selection, using square brackets. A colon separates the starting and ending indices. Any bound that is omitted is assumed to be an extreme value: 0 for the starting index, and the length of the sequence for the ending index.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits[0:2]</span><br><span class="line">[1, 8]</span><br><span class="line">&gt;&gt;&gt; digits[1:]</span><br><span class="line">[8, 2, 8]</span><br></pre></td></tr></table></figure>
<p>Enumerating these additional behaviors of the Python sequence abstraction gives us an opportunity to reflect upon what constitutes a useful data abstraction in general. The richness of an abstraction (that is, how many behaviors it includes) has consequences. For users of an abstraction, additional behaviors can be helpful. On the other hand, satisfying the requirements of a rich abstraction with a new data type can be challenging. Another negative consequence of rich abstractions is that they take longer for users to learn.</p>
<p>Sequences have a rich abstraction because they are so ubiquitous in computing that learning a few complex behaviors is justified. In general, most user-defined abstractions should be kept as simple as possible.</p>
<p><strong>Further reading.</strong> Slice notation admits a variety of special cases, such as negative starting values, ending values, and step sizes. A complete description appears in the subsection called <a href="http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists" target="_blank" rel="noopener">slicing a list</a> in Dive Into Python 3. In this chapter, we will only use the basic features described above.</p>
<h3 id="2-3-5-Strings"><a href="#2-3-5-Strings" class="headerlink" title="2.3.5  Strings"></a>2.3.5  Strings</h3><p>Text values are perhaps more fundamental to computer science than even numbers. As a case in point, Python programs are written and stored as text. The native data type for text in Python is called a string, and corresponds to the constructor <code>str</code>.</p>
<p>There are many details of how strings are represented, expressed, and manipulated in Python. Strings are another example of a rich abstraction, one that requires a substantial commitment on the part of the programmer to master. This section serves as a condensed introduction to essential string behaviors.</p>
<p>String literals can express arbitrary text, surrounded by either single or double quotation marks.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;I am string!&#39;</span><br><span class="line">&#39;I am string!&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;I&#39;ve got an apostrophe&quot;</span><br><span class="line">&quot;I&#39;ve got an apostrophe&quot;</span><br><span class="line">&gt;&gt;&gt; &#39;您好&#39;</span><br><span class="line">&#39;您好&#39;</span><br></pre></td></tr></table></figure>
<p>We have seen strings already in our code, as docstrings, in calls to <code>print</code>, and as error messages in <code>assert</code> statements.</p>
<p>Strings satisfy the two basic conditions of a sequence that we introduced at the beginning of this section: they have a length and they support element selection.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; city &#x3D; &#39;Berkeley&#39;</span><br><span class="line">&gt;&gt;&gt; len(city)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; city[3]</span><br><span class="line">&#39;k&#39;</span><br></pre></td></tr></table></figure>
<p>The elements of a string are themselves strings that have only a single character. A character is any single letter of the alphabet, punctuation mark, or other symbol. Unlike many other programming languages, Python does not have a separate character type; any text is a string, and strings that represent single characters have a length of 1.</p>
<p>Like lists, strings can also be combined via addition and multiplication.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Berkeley&#39; + &#39;, CA&#39;</span><br><span class="line">&#39;Berkeley, CA&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;Shabu &#39; * 2</span><br><span class="line">&#39;Shabu Shabu &#39;</span><br></pre></td></tr></table></figure>
<p><strong>Membership.</strong> The behavior of strings diverges from other sequence types in Python. The string abstraction does not conform to the full sequence abstraction that we described for lists and ranges. In particular, the membership operator <code>in</code> applies to strings, but has an entirely different behavior than when it is applied to sequences. It matches substrings rather than elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;here&#39; in &quot;Where&#39;s Waldo?&quot;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><strong>Multiline Literals.</strong> Strings aren’t limited to a single line. Triple quotes delimit string literals that span multiple lines. We have used this triple quoting extensively already for docstrings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&quot;&quot;The Zen of Python</span><br><span class="line">claims, Readability counts.</span><br><span class="line">Read more: import this.&quot;&quot;&quot;</span><br><span class="line">&#39;The Zen of Python\nclaims, &quot;Readability counts.&quot;\nRead more: import this.&#39;</span><br></pre></td></tr></table></figure>
<p>In the printed result above, the <code>\n</code> (pronounced “<em>backslash en</em>“) is a single element that represents a new line. Although it appears as two characters (backslash and “n”), it is considered a single character for the purposes of length and element selection.</p>
<p><strong>String Coercion.</strong> A string can be created from any object in Python by calling the <code>str</code> constructor function with an object value as its argument. This feature of strings is useful for constructing descriptive strings from objects of various types.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(2) + &#39; is an element of &#39; + str(digits)</span><br><span class="line">&#39;2 is an element of [1, 8, 2, 8]&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Further reading.</strong> Encoding text in computers is a complex topic. In this chapter, we will abstract away the details of how strings are represented. However, for many applications, the particular details of how strings are encoded by computers is essential knowledge. <a href="http://getpython3.com/diveintopython3/strings.html" target="_blank" rel="noopener">The strings chapter of Dive Into Python 3</a>provides a description of character encodings and Unicode.</p>
<h3 id="2-3-6-Trees"><a href="#2-3-6-Trees" class="headerlink" title="2.3.6  Trees"></a>2.3.6  Trees</h3><p>Our ability to use lists as the elements of other lists provides a new means of combination in our programming language. This ability is called a <em>closure property</em> of a data type. In general, a method for combining data values has a closure property if the result of combination can itself be combined using the same method. Closure is the key to power in any means of combination because it permits us to create hierarchical structures — structures made up of parts, which themselves are made up of parts, and so on.</p>
<p>We can visualize lists in environment diagrams using <em>box-and-pointer</em> notation. A list is depicted as adjacent boxes that contain the elements of the list. Primitive values such as numbers, strings, boolean values, and <code>None</code> appear within an element box. Composite values, such as function values and other lists, are indicated by an arrow.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one_two = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nested = [[<span class="number">1</span>, <span class="number">2</span>], [],</span><br><span class="line">         [[<span class="number">3</span>, <span class="literal">False</span>, <span class="literal">None</span>],</span><br><span class="line">          [<span class="number">4</span>, <span class="keyword">lambda</span>: <span class="number">5</span>]]]</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222713997.png" alt="image-20200206222713997" style="zoom:50%;"></p>
<p>Nesting lists within lists can introduce complexity. The <em>tree</em> is a fundamental data abstraction that imposes regularity on how hierarchical values are structured and manipulated.</p>
<p>A tree has a root label and a sequence of branches. Each branch of a tree is a tree. A tree with no branches is called a leaf. Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.</p>
<p>The data abstraction for a tree consists of the constructor <code>tree</code> and the selectors <code>label</code> and <code>branches</code>. We begin with a simplified version.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def tree(root_label, branches&#x3D;[]):</span><br><span class="line">        for branch in branches:</span><br><span class="line">            assert is_tree(branch), &#39;branches must be trees&#39;</span><br><span class="line">        return [root_label] + list(branches)</span><br><span class="line">&gt;&gt;&gt; def label(tree):</span><br><span class="line">        return tree[0]</span><br><span class="line">&gt;&gt;&gt; def branches(tree):</span><br><span class="line">        return tree[1:]</span><br></pre></td></tr></table></figure>
<p>A tree is well-formed only if it has a root label and all branches are also trees. The <code>is_tree</code> function is applied in the <code>tree</code> constructor to verify that all branches are well-formed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def is_tree(tree):</span><br><span class="line">        if type(tree) !&#x3D; list or len(tree) &lt; 1:</span><br><span class="line">            return False</span><br><span class="line">        for branch in branches(tree):</span><br><span class="line">            if not is_tree(branch):</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<p>The <code>is_leaf</code> function checks whether or not a tree has branches.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def is_leaf(tree):</span><br><span class="line">        return not branches(tree)</span><br></pre></td></tr></table></figure>
<p>Trees can be constructed by nested expressions. The following tree <code>t</code> has root label 3 and two branches.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; tree(3, [tree(1), tree(2, [tree(1), tree(1)])])</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">[3, [1], [2, [1], [1]]]</span><br><span class="line">&gt;&gt;&gt; label(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; branches(t)</span><br><span class="line">[[1], [2, [1], [1]]]</span><br><span class="line">&gt;&gt;&gt; label(branches(t)[1])</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; is_leaf(t)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; is_leaf(branches(t)[0])</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>Tree-recursive functions can be used to construct trees. For example, the nth Fibonacci tree has a root label of the nth Fibonacci number and, for <code>n &gt; 1</code>, two branches that are also Fibonacci trees. A Fibonacci tree illustrates the tree-recursive computation of a Fibonacci number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib_tree(n):</span><br><span class="line">        if n &#x3D;&#x3D; 0 or n &#x3D;&#x3D; 1:</span><br><span class="line">            return tree(n)</span><br><span class="line">        else:</span><br><span class="line">            left, right &#x3D; fib_tree(n-2), fib_tree(n-1)</span><br><span class="line">            fib_n &#x3D; label(left) + label(right)</span><br><span class="line">            return tree(fib_n, [left, right])</span><br><span class="line">&gt;&gt;&gt; fib_tree(5)</span><br><span class="line">[5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]</span><br></pre></td></tr></table></figure>
<p>Tree-recursive functions are also used to process trees. For example, the <code>count_leaves</code> function counts the leaves of a tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count_leaves(tree):</span><br><span class="line">      if is_leaf(tree):</span><br><span class="line">          return 1</span><br><span class="line">      else:</span><br><span class="line">          branch_counts &#x3D; [count_leaves(b) for b in branches(tree)]</span><br><span class="line">          return sum(branch_counts)</span><br><span class="line">&gt;&gt;&gt; count_leaves(fib_tree(5))</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p><strong>Partition trees.</strong> Trees can also be used to represent the partitions of an integer. A partition tree for <code>n</code>using parts up to size <code>m</code> is a binary (two branch) tree that represents the choices taken during computation. In a non-leaf partition tree:</p>
<ul>
<li>the left (index 0) branch contains all ways of partitioning <code>n</code> using at least one <code>m</code>,</li>
<li>the right (index 1) branch contains partitions using parts up to <code>m-1</code>, and</li>
<li>the root label is <code>m</code>.</li>
</ul>
<p>The labels at the leaves of a partition tree express whether the path from the root of the tree to the leaf represents a successful partition of <code>n</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def partition_tree(n, m):</span><br><span class="line">        &quot;&quot;&quot;Return a partition tree of n using parts of up to m.&quot;&quot;&quot;</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return tree(True)</span><br><span class="line">        elif n &lt; 0 or m &#x3D;&#x3D; 0:</span><br><span class="line">            return tree(False)</span><br><span class="line">        else:</span><br><span class="line">            left &#x3D; partition_tree(n-m, m)</span><br><span class="line">            right &#x3D; partition_tree(n, m-1)</span><br><span class="line">            return tree(m, [left, right])</span><br><span class="line">&gt;&gt;&gt; partition_tree(2, 2)</span><br><span class="line">[2, [True], [1, [1, [True], [False]], [False]]]</span><br></pre></td></tr></table></figure>
<p>Printing the partitions from a partition tree is another tree-recursive process that traverses the tree, constructing each partition as a list. Whenever a <code>True</code> leaf is reached, the partition is printed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_parts(tree, partition&#x3D;[]):</span><br><span class="line">        if is_leaf(tree):</span><br><span class="line">            if label(tree):</span><br><span class="line">                print(&#39; + &#39;.join(partition))</span><br><span class="line">        else:</span><br><span class="line">            left, right &#x3D; branches(tree)</span><br><span class="line">            m &#x3D; str(label(tree))</span><br><span class="line">            print_parts(left, partition + [m])</span><br><span class="line">            print_parts(right, partition)</span><br><span class="line">&gt;&gt;&gt; print_parts(partition_tree(6, 4))</span><br><span class="line">4 + 2</span><br><span class="line">4 + 1 + 1</span><br><span class="line">3 + 3</span><br><span class="line">3 + 2 + 1</span><br><span class="line">3 + 1 + 1 + 1</span><br><span class="line">2 + 2 + 2</span><br><span class="line">2 + 2 + 1 + 1</span><br><span class="line">2 + 1 + 1 + 1 + 1</span><br><span class="line">1 + 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>
<p>Slicing can be used on the branches of a tree as well. For example, we may want to place a restriction on the number of branches in a tree. A binarized tree has at most two branches. A common tree transformation called <em>binarization</em> finds a binarized tree with the same labels as an original tree by grouping together branches.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def right_binarize(t):</span><br><span class="line">        &quot;&quot;&quot;Construct a right-branching binary tree.&quot;&quot;&quot;</span><br><span class="line">    return tree(label(t), binarize_branches(branches(t)))</span><br><span class="line">&gt;&gt;&gt; def binarize_branches(bs):</span><br><span class="line">        &quot;&quot;&quot;Binarize a list of branches.&quot;&quot;&quot;</span><br><span class="line">        if len(bs) &gt; 2:</span><br><span class="line">            first, rest &#x3D; bs[0], bs[1:]</span><br><span class="line">            return [right_binarize(first), binarize_branches(rest)]</span><br><span class="line">        else:</span><br><span class="line">            return [right_binarize(b) for b in bs]</span><br><span class="line">&gt;&gt;&gt; right_binarize(tree(0, [tree(x) for x in [1, 2, 3, 4, 5, 6, 7]]))</span><br><span class="line">[0, [1], [[2], [[3], [[4], [[5], [[6], [7]]]]]]]</span><br></pre></td></tr></table></figure>
<h3 id="2-3-7-Linked-Lists"><a href="#2-3-7-Linked-Lists" class="headerlink" title="2.3.7  Linked Lists"></a>2.3.7  Linked Lists</h3><p>So far, we have used only native types to represent sequences. However, we can also develop sequence representations that are not built into Python. A common representation of a sequence constructed from nested pairs is called a <em>linked list</em>. The environment diagram below illustrates the linked list representation of a four-element sequence containing 1, 2, 3, and 4.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">'empty'</span>]]]]</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222808554.png" alt="image-20200206222808554" style="zoom:50%;"></p>
<p>A linked list is a pair containing the first element of the sequence (in this case 1) and the rest of the sequence (in this case a representation of 2, 3, 4). The second element is also a linked list. The rest of the inner-most linked list containing only 4 is <code>&#39;empty&#39;</code>, a value that represents an empty linked list.</p>
<p>Linked lists have recursive structure: the rest of a linked list is a linked list or <code>&#39;empty&#39;</code>. We can define an abstract data representation to validate, construct, and select the components of linked lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; empty &#x3D; &#39;empty&#39;</span><br><span class="line">&gt;&gt;&gt; def is_link(s):</span><br><span class="line">        &quot;&quot;&quot;s is a linked list if it is empty or a (first, rest) pair.&quot;&quot;&quot;</span><br><span class="line">        return s &#x3D;&#x3D; empty or (len(s) &#x3D;&#x3D; 2 and is_link(s[1]))</span><br><span class="line">&gt;&gt;&gt; def link(first, rest):</span><br><span class="line">        &quot;&quot;&quot;Construct a linked list from its first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(rest), &quot;rest must be a linked list.&quot;</span><br><span class="line">        return [first, rest]</span><br><span class="line">&gt;&gt;&gt; def first(s):</span><br><span class="line">        &quot;&quot;&quot;Return the first element of a linked list s.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(s), &quot;first only applies to linked lists.&quot;</span><br><span class="line">        assert s !&#x3D; empty, &quot;empty linked list has no first element.&quot;</span><br><span class="line">        return s[0]</span><br><span class="line">&gt;&gt;&gt; def rest(s):</span><br><span class="line">        &quot;&quot;&quot;Return the rest of the elements of a linked list s.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(s), &quot;rest only applies to linked lists.&quot;</span><br><span class="line">        assert s !&#x3D; empty, &quot;empty linked list has no rest.&quot;</span><br><span class="line">        return s[1]</span><br></pre></td></tr></table></figure>
<p>Above, <code>link</code> is a constructor and <code>first</code> and <code>rest</code> are selectors for an abstract data representation of linked lists. The behavior condition for a linked list is that, like a pair, its constructor and selectors are inverse functions.</p>
<ul>
<li>If a linked list <code>s</code> was constructed from first element <code>f</code> and linked list <code>r</code>, then <code>first(s)</code> returns <code>f</code>, and <code>rest(s)</code> returns <code>r</code>.</li>
</ul>
<p>We can use the constructor and selectors to manipulate linked lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; four &#x3D; link(1, link(2, link(3, link(4, empty))))</span><br><span class="line">&gt;&gt;&gt; first(four)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; rest(four)</span><br><span class="line">[2, [3, [4, &#39;empty&#39;]]]</span><br></pre></td></tr></table></figure>
<p>Our implementation of this kind of abstract data uses pairs that are two-element <code>list</code> values. It is worth noting that we were also able to implement pairs using functions, and we can implement linked lists using any pairs, therefore we could implement linked lists using functions alone.</p>
<p>The linked list can store a sequence of values in order, but we have not yet shown that it satisfies the sequence abstraction. Using the abstract data representation we have defined, we can implement the two behaviors that characterize a sequence: length and element selection.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def len_link(s):</span><br><span class="line">        &quot;&quot;&quot;Return the length of linked list s.&quot;&quot;&quot;</span><br><span class="line">        length &#x3D; 0</span><br><span class="line">        while s !&#x3D; empty:</span><br><span class="line">            s, length &#x3D; rest(s), length + 1</span><br><span class="line">        return length</span><br><span class="line">&gt;&gt;&gt; def getitem_link(s, i):</span><br><span class="line">        &quot;&quot;&quot;Return the element at index i of linked list s.&quot;&quot;&quot;</span><br><span class="line">        while i &gt; 0:</span><br><span class="line">            s, i &#x3D; rest(s), i - 1</span><br><span class="line">        return first(s)</span><br></pre></td></tr></table></figure>
<p>Now, we can manipulate a linked list as a sequence using these functions. (We cannot yet use the built-in <code>len</code> function, element selection syntax, or <code>for</code> statement, but we will soon.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len_link(four)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; getitem_link(four, 1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>The series of environment diagrams below illustrate the iterative process by which <code>getitem_link</code> finds the element 2 at index 1 in a linked list. Below, we have defined the linked list <code>four</code> using Python primitives to simplify the diagrams. This implementation choice violates an abstraction barrier, but allows us to inspect the computational process more easily for this example.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rest</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getitem_link</span><span class="params">(s, i)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        s, i = rest(s), i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> first(s)</span><br><span class="line"></span><br><span class="line">four = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">'empty'</span>]]]]</span><br><span class="line">getitem_link(four, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222842994.png" alt="image-20200206222842994" style="zoom:50%;"></p>
<p>First, the function <code>getitem_link</code> is called, creating a local frame.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206222949749.png" alt="image-20200206222949749" style="zoom:50%;"></p>
<p>The expression in the <code>while</code> header evaluates to true, which causes the assignment statement in the <code>while</code> suite to be executed. The function <code>rest</code> returns the sublist starting with 2.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206223014148.png" alt="image-20200206223014148" style="zoom:50%;"></p>
<p>Next, the local name <code>s</code> will be updated to refer to the sub-list that begins with the second element of the original list. Evaluating the <code>while</code> header expression now yields a false value, and so Python evaluates the expression in the return statement on the final line of <code>getitem_link</code>.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206223040022.png" alt="image-20200206223040022" style="zoom:50%;"></p>
<p>This final environment diagram shows the local frame for the call to <code>first</code>, which contains the name <code>s</code>bound to that same sub-list. The <code>first</code> function selects the value 2 and returns it, which will also be returned from <code>getitem_link</code>.</p>
<p>This example demonstrates a common pattern of computation with linked lists, where each step in an iteration operates on an increasingly shorter suffix of the original list. This incremental processing to find the length and elements of a linked list does take some time to compute. Python’s built-in sequence types are implemented in a different way that does not have a large cost for computing the length of a sequence or retrieving its elements. The details of that representation are beyond the scope of this text.</p>
<p><strong>Recursive manipulation.</strong> Both <code>len_link</code> and <code>getitem_link</code> are iterative. They peel away each layer of nested pair until the end of the list (in <code>len_link</code>) or the desired element (in <code>getitem_link</code>) is reached. We can also implement length and element selection using recursion.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def len_link_recursive(s):</span><br><span class="line">        &quot;&quot;&quot;Return the length of a linked list s.&quot;&quot;&quot;</span><br><span class="line">        if s &#x3D;&#x3D; empty:</span><br><span class="line">            return 0</span><br><span class="line">        return 1 + len_link_recursive(rest(s))</span><br><span class="line">&gt;&gt;&gt; def getitem_link_recursive(s, i):</span><br><span class="line">        &quot;&quot;&quot;Return the element at index i of linked list s.&quot;&quot;&quot;</span><br><span class="line">        if i &#x3D;&#x3D; 0:</span><br><span class="line">            return first(s)</span><br><span class="line">        return getitem_link_recursive(rest(s), i - 1)</span><br><span class="line">&gt;&gt;&gt; len_link_recursive(four)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; getitem_link_recursive(four, 1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>These recursive implementations follow the chain of pairs until the end of the list (in <code>len_link_recursive</code>) or the desired element (in <code>getitem_link_recursive</code>) is reached.</p>
<p>Recursion is also useful for transforming and combining linked lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def extend_link(s, t):</span><br><span class="line">        &quot;&quot;&quot;Return a list with the elements of s followed by those of t.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(s) and is_link(t)</span><br><span class="line">        if s &#x3D;&#x3D; empty:</span><br><span class="line">            return t</span><br><span class="line">        else:</span><br><span class="line">            return link(first(s), extend_link(rest(s), t))</span><br><span class="line">&gt;&gt;&gt; extend_link(four, four)</span><br><span class="line">[1, [2, [3, [4, [1, [2, [3, [4, &#39;empty&#39;]]]]]]]]</span><br><span class="line">&gt;&gt;&gt; def apply_to_all_link(f, s):</span><br><span class="line">        &quot;&quot;&quot;Apply f to each element of s.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(s)</span><br><span class="line">        if s &#x3D;&#x3D; empty:</span><br><span class="line">            return s</span><br><span class="line">        else:</span><br><span class="line">            return link(f(first(s)), apply_to_all_link(f, rest(s)))</span><br><span class="line">&gt;&gt;&gt; apply_to_all_link(lambda x: x*x, four)</span><br><span class="line">[1, [4, [9, [16, &#39;empty&#39;]]]]</span><br><span class="line">&gt;&gt;&gt; def keep_if_link(f, s):</span><br><span class="line">        &quot;&quot;&quot;Return a list with elements of s for which f(e) is true.&quot;&quot;&quot;</span><br><span class="line">        assert is_link(s)</span><br><span class="line">        if s &#x3D;&#x3D; empty:</span><br><span class="line">            return s</span><br><span class="line">        else:</span><br><span class="line">            kept &#x3D; keep_if_link(f, rest(s))</span><br><span class="line">            if f(first(s)):</span><br><span class="line">                return link(first(s), kept)</span><br><span class="line">            else:</span><br><span class="line">                return kept</span><br><span class="line">&gt;&gt;&gt; keep_if_link(lambda x: x%2 &#x3D;&#x3D; 0, four)</span><br><span class="line">[2, [4, &#39;empty&#39;]]</span><br><span class="line">&gt;&gt;&gt; def join_link(s, separator):</span><br><span class="line">        &quot;&quot;&quot;Return a string of all elements in s separated by separator.&quot;&quot;&quot;</span><br><span class="line">        if s &#x3D;&#x3D; empty:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        elif rest(s) &#x3D;&#x3D; empty:</span><br><span class="line">            return str(first(s))</span><br><span class="line">        else:</span><br><span class="line">            return str(first(s)) + separator + join_link(rest(s), separator)</span><br><span class="line">&gt;&gt;&gt; join_link(four, &quot;, &quot;)</span><br><span class="line">&#39;1, 2, 3, 4&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Recursive Construction.</strong> Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.</p>
<p>The <code>count_partitions</code> function from Chapter 1 counted the number of ways to partition an integer <code>n</code>using parts up to size <code>m</code> via a tree-recursive process. With sequences, we can also enumerate these partitions explicitly using a similar process.</p>
<p>We follow the same recursive analysis of the problem as we did while counting: partitioning <code>n</code> using integers up to <code>m</code> involves either</p>
<ol>
<li>partitioning <code>n-m</code> using integers up to <code>m</code>, or</li>
<li>partitioning <code>n</code> using integers up to <code>m-1</code>.</li>
</ol>
<p>For base cases, we find that 0 has an empty partition, while partitioning a negative integer or using parts smaller than 1 is impossible.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def partitions(n, m):</span><br><span class="line">        &quot;&quot;&quot;Return a linked list of partitions of n using parts of up to m.</span><br><span class="line">        Each partition is represented as a linked list.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return link(empty, empty) # A list containing the empty partition</span><br><span class="line">        elif n &lt; 0 or m &#x3D;&#x3D; 0:</span><br><span class="line">            return empty</span><br><span class="line">        else:</span><br><span class="line">            using_m &#x3D; partitions(n-m, m)</span><br><span class="line">            with_m &#x3D; apply_to_all_link(lambda s: link(m, s), using_m)</span><br><span class="line">            without_m &#x3D; partitions(n, m-1)</span><br><span class="line">            return extend_link(with_m, without_m)</span><br></pre></td></tr></table></figure>
<p>In the recursive case, we construct two sublists of partitions. The first uses <code>m</code>, and so we prepend <code>m</code> to each element of the result <code>using_m</code> to form <code>with_m</code>.</p>
<p>The result of <code>partitions</code> is highly nested: a linked list of linked lists, and each linked list is represented as nested pairs that are <code>list</code> values. Using <code>join_link</code> with appropriate separators, we can display the partitions in a human-readable manner.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_partitions(n, m):</span><br><span class="line">        lists &#x3D; partitions(n, m)</span><br><span class="line">        strings &#x3D; apply_to_all_link(lambda s: join_link(s, &quot; + &quot;), lists)</span><br><span class="line">        print(join_link(strings, &quot;\n&quot;))</span><br><span class="line">&gt;&gt;&gt; print_partitions(6, 4)</span><br><span class="line">4 + 2</span><br><span class="line">4 + 1 + 1</span><br><span class="line">3 + 3</span><br><span class="line">3 + 2 + 1</span><br><span class="line">3 + 1 + 1 + 1</span><br><span class="line">2 + 2 + 2</span><br><span class="line">2 + 2 + 1 + 1</span><br><span class="line">2 + 1 + 1 + 1 + 1</span><br><span class="line">1 + 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Mutable-Data"><a href="#2-4-Mutable-Data" class="headerlink" title="2.4  Mutable Data"></a>2.4  Mutable Data</h2><p>We have seen how abstraction is vital in helping us to cope with the complexity of large systems. Effective programming also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems to be modular, meaning that they divide naturally into coherent parts that can be separately developed and maintained.</p>
<p>One powerful technique for creating modular programs is to incorporate data that may change state over time. In this way, a single data object can represent something that evolves independently of the rest of the program. The behavior of a changing object may be influenced by its history, just like an entity in the world. Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p>
<h3 id="2-4-1-The-Object-Metaphor"><a href="#2-4-1-The-Object-Metaphor" class="headerlink" title="2.4.1  The Object Metaphor"></a>2.4.1  The Object Metaphor</h3><p>In the beginning of this text, we distinguished between functions and data: functions performed operations and data were operated upon. When we included function values among our data, we acknowledged that data too can have behavior. Functions could be manipulated as data, but could also be called to perform computation.</p>
<p><em>Objects</em> combine data values with behavior. Objects represent information, but also <em>behave</em> like the things that they represent. The logic of how an object interacts with other objects is bundled along with the information that encodes the object’s value. When an object is printed, it knows how to spell itself out in text. If an object is composed of parts, it knows how to reveal those parts on demand. Objects are both information and processes, bundled together to represent the properties, interactions, and behaviors of complex things.</p>
<p>Object behavior is implemented in Python through specialized object syntax and associated terminology, which we can introduce by example. A date is a kind of object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import date</span><br></pre></td></tr></table></figure>
<p>The name <code>date</code> is bound to a <em>class</em>. As we have seen, a class represents a kind of value. Individual dates are called <em>instances</em> of that class. Instances can be <em>constructed</em> by calling the class on arguments that characterize the instance.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tues &#x3D; date(2014, 5, 13)</span><br></pre></td></tr></table></figure>
<p>While <code>tues</code> was constructed from primitive numbers, it behaves like a date. For instance, subtracting it from another date will give a time difference, which we can print.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(date(2014, 5, 19) - tues)</span><br><span class="line">6 days, 0:00:00</span><br></pre></td></tr></table></figure>
<p>Objects have <em>attributes</em>, which are named values that are part of the object. In Python, like many other programming languages, we use dot notation to designate an attribute of an object.</p>
<blockquote>
<p><expression> . <name></name></expression></p>
</blockquote>
<p>Above, the <code>evaluates to an object, and</code> is the name of an attribute for that object.</p>
<p>Unlike the names that we have considered so far, these attribute names are not available in the general environment. Instead, attribute names are particular to the object instance preceding the dot.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tues.year</span><br><span class="line">2014</span><br></pre></td></tr></table></figure>
<p>Objects also have <em>methods</em>, which are function-valued attributes. Metaphorically, we say that the object “knows” how to carry out those methods. By implementation, methods are functions that compute their results from both their arguments and their object. For example, The <code>strftime</code> method (a classic function name meant to evoke “string format of time”) of <code>tues</code> takes a single argument that specifies how to display a date (e.g., <code>%A</code> means that the day of the week should be spelled out in full).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tues.strftime(&#39;%A, %B %d&#39;)</span><br><span class="line">&#39;Tuesday, May 13&#39;</span><br></pre></td></tr></table></figure>
<p>Computing the return value of <code>strftime</code> requires two inputs: the string that describes the format of the output and the date information bundled into <code>tues</code>. Date-specific logic is applied within this method to yield this result. We never stated that the 13th of May, 2014, was a Tuesday, but knowing the corresponding weekday is part of what it means to be a date. By bundling behavior and information together, this Python object offers us a convincing, self-contained abstraction of a date.</p>
<p>Dates are objects, but numbers, strings, lists, and ranges are all objects as well. They represent values, but also behave in a manner that befits the values they represent. They also have attributes and methods. For instance, strings have an array of methods that facilitate text processing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;1234&#39;.isnumeric()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#39;rOBERT dE nIRO&#39;.swapcase()</span><br><span class="line">&#39;Robert De Niro&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;eyes&#39;.upper().endswith(&#39;YES&#39;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>In fact, all values in Python are objects. That is, all values have behavior and attributes. They act like the values they represent.</p>
<h3 id="2-4-2-Sequence-Objects"><a href="#2-4-2-Sequence-Objects" class="headerlink" title="2.4.2  Sequence Objects"></a>2.4.2  Sequence Objects</h3><p>Instances of primitive built-in values such as numbers are <em>immutable</em>. The values themselves cannot change over the course of program execution. Lists on the other hand are <em>mutable</em>.</p>
<p>Mutable objects are used to represent values that change over time. A person is the same person from one day to the next, despite having aged, received a haircut, or otherwise changed in some way. Similarly, an object may have changing properties due to <em>mutating</em> operations. For example, it is possible to change the contents of a list. Most changes are performed by invoking methods on list objects.</p>
<p>We can introduce many list modification operations through an example that illustrates the history of playing cards (drastically simplified). Comments in the examples describe the effect of each method invocation.</p>
<p>Playing cards were invented in China, perhaps around the 9th century. An early deck had three suits, which corresponded to denominations of money.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chinese &#x3D; [&#39;coin&#39;, &#39;string&#39;, &#39;myriad&#39;]  # A list literal</span><br><span class="line">&gt;&gt;&gt; suits &#x3D; chinese                         # Two names refer to the same list</span><br></pre></td></tr></table></figure>
<p>As cards migrated to Europe (perhaps through Egypt), only the suit of coins remained in Spanish decks (<em>oro</em>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits.pop()             # Remove and return the final element</span><br><span class="line">&#39;myriad&#39;</span><br><span class="line">&gt;&gt;&gt; suits.remove(&#39;string&#39;)  # Remove the first element that equals the argument</span><br></pre></td></tr></table></figure>
<p>Three more suits were added (they evolved in name and design over time),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits.append(&#39;cup&#39;)              # Add an element to the end</span><br><span class="line">&gt;&gt;&gt; suits.extend([&#39;sword&#39;, &#39;club&#39;])  # Add all elements of a sequence to the end</span><br></pre></td></tr></table></figure>
<p>and Italians called swords <em>spades</em>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits[2] &#x3D; &#39;spade&#39;  # Replace an element</span><br></pre></td></tr></table></figure>
<p>giving the suits of a traditional Italian deck of cards.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits</span><br><span class="line">[&#39;coin&#39;, &#39;cup&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br></pre></td></tr></table></figure>
<p>The French variant used today in the U.S. changes the first two suits:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits[0:2] &#x3D; [&#39;heart&#39;, &#39;diamond&#39;]  # Replace a slice</span><br><span class="line">&gt;&gt;&gt; suits</span><br><span class="line">[&#39;heart&#39;, &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br></pre></td></tr></table></figure>
<p>Methods also exist for inserting, sorting, and reversing lists. All of these mutation operations change the value of the list; they do not create new list objects.</p>
<p><strong>Sharing and Identity.</strong> Because we have been changing a single list rather than creating new lists, the object bound to the name <code>chinese</code> has also changed, because it is the same list object that was bound to <code>suits</code>!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chinese  # This name co-refers with &quot;suits&quot; to the same changing list</span><br><span class="line">[&#39;heart&#39;, &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br></pre></td></tr></table></figure>
<p>This behavior is new. Previously, if a name did not appear in a statement, then its value would not be affected by that statement. With mutable data, methods called on one name can affect another name at the same time.</p>
<p>The environment diagram for this example shows how the value bound to <code>chinese</code> is changed by statements involving only <code>suits</code>. Step through each line of the following example to observe these changes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chinese = [<span class="string">'coin'</span>, <span class="string">'string'</span>, <span class="string">'myriad'</span>]</span><br><span class="line">suits = chinese</span><br><span class="line">suits.pop()</span><br><span class="line">suits.remove(<span class="string">'string'</span>)</span><br><span class="line">suits.append(<span class="string">'cup'</span>)</span><br><span class="line">suits.extend([<span class="string">'sword'</span>, <span class="string">'club'</span>])</span><br><span class="line">suits[<span class="number">2</span>] = <span class="string">'spade'</span></span><br><span class="line">suits[<span class="number">0</span>:<span class="number">2</span>] = [<span class="string">'heart'</span>, <span class="string">'diamond'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225321275.png" alt="image-20200206225321275" style="zoom:50%;"></p>
<p>Lists can be copied using the <code>list</code> constructor function. Changes to one list do not affect another, unless they share structure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nest &#x3D; list(suits)  # Bind &quot;nest&quot; to a second list with the same elements</span><br><span class="line">&gt;&gt;&gt; nest[0] &#x3D; suits     # Create a nested list</span><br></pre></td></tr></table></figure>
<p>According to this environment, changing the list referenced by <code>suits</code> will affect the nested list that is the first element of <code>nest</code>, but not the other elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits.insert(2, &#39;Joker&#39;)  # Insert an element at index 2, shifting the rest</span><br><span class="line">&gt;&gt;&gt; nest</span><br><span class="line">[[&#39;heart&#39;, &#39;diamond&#39;, &#39;Joker&#39;, &#39;spade&#39;, &#39;club&#39;], &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br></pre></td></tr></table></figure>
<p>And likewise, undoing this change in the first element of <code>nest</code> will change <code>suit</code> as well.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nest[0].pop(2)</span><br><span class="line">&#39;Joker&#39;</span><br><span class="line">&gt;&gt;&gt; suits</span><br><span class="line">[&#39;heart&#39;, &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br></pre></td></tr></table></figure>
<p>Stepping through this example line by line will show the representation of a nested list.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suits = [<span class="string">'heart'</span>, <span class="string">'diamond'</span>, <span class="string">'spade'</span>, <span class="string">'club'</span>]</span><br><span class="line">nest = list(suits)</span><br><span class="line">nest[<span class="number">0</span>] = suits</span><br><span class="line">suits.insert(<span class="number">2</span>, <span class="string">'Joker'</span>)</span><br><span class="line">joke = nest[<span class="number">0</span>].pop(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>Because two lists may have the same contents but in fact be different lists, we require a means to test whether two objects are the same. Python includes two comparison operators, called <code>is</code> and <code>is not</code>, that test whether two expressions in fact evaluate to the identical object. Two objects are identical if they are equal in their current value, and any change to one will always be reflected in the other. Identity is a stronger condition than equality.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; suits is nest[0]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; suits is [&#39;heart&#39;, &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits &#x3D;&#x3D; [&#39;heart&#39;, &#39;diamond&#39;, &#39;spade&#39;, &#39;club&#39;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>The final two comparisons illustrate the difference between <code>is</code> and <code>==</code>. The former checks for identity, while the latter checks for the equality of contents.</p>
<p><strong>List Manipulation.</strong> The behavior of list functions and methods can best be understood in terms of object mutation and identity. Lists have a large number of built-in methods that are useful in many scenarios, and so learning their behavior is useful for programming productivity.</p>
<p>Slicing a list creates a new list and leaves the original list unchanged. A slice from the beginning to the end of the list is one way to copy the contents of a list.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">b = a[<span class="number">1</span>:]</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225457395.png" alt="image-20200206225457395" style="zoom:50%;"></p>
<p>Although the list is copied, the values contained within the list are not. Instead, a new list is constructed that contains a subset of the same values as the sliced list. Therefore, mutating a list within a sliced list will affect the original list.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">11</span>, [<span class="number">12</span>, <span class="number">13</span>], <span class="number">14</span>]</span><br><span class="line">b = a[:]</span><br><span class="line">b[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225624384.png" alt="image-20200206225624384" style="zoom:50%;"></p>
<p>The built-in <code>list</code> function creates a new list that contains the values of its argument, which must be an iterable value such as a sequence. Again, the values placed in this list are not copied. <code>list(s)</code> and <code>s[:]</code>are equivalent for a list <code>s</code>.</p>
<p>Adding two lists together creates a new list that contains the values of the first list, followed by the values in the second list. Therefore, <code>a+b</code> and <code>b+a</code> can result in different values for two lists <code>a</code> and <code>b</code>. However, the <code>+=</code> operator behaves differently for lists, and its behavior is described below along with the <code>extend</code>method.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">11</span>], <span class="number">12</span>]</span><br><span class="line">b = [<span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line">c = a + b</span><br><span class="line">d = b + a</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">15</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225705039.png" alt="image-20200206225705039" style="zoom:50%;"></p>
<p>The <code>append</code> method of a list takes one value as an argument and adds it to the end of the list. The argument can be any value, such as a number or another list. If the argument is a list, then that list (and not a copy) is added as an item in the list. The method always returns <code>None</code>, and it mutates the list by increasing its length by one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">b = [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">c = <span class="number">7</span></span><br><span class="line">a.append(b)</span><br><span class="line">a.append(c)</span><br><span class="line">b.append(c)</span><br><span class="line">d = a.append(a)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225806165.png" alt="image-20200206225806165" style="zoom:50%;"></p>
<p>The <code>extend</code> method of a list takes an iterable value as an argument and adds each of its elements to the end of the list. It mutates the list by increasing its length by the length of the iterable argument. The statement <code>x += y</code> for a list <code>x</code> and iterable <code>y</code> is equivalent to <code>x.extend(y)</code>, aside from some obscure and minor differences beyond the scope of this text. Passing any argument to <code>extend</code> that is not iterable will cause a <code>TypeError</code>. The method does not return anything, and it mutates the list.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">d = [<span class="number">3</span>, [<span class="number">4</span>]]</span><br><span class="line">a.extend(d)</span><br><span class="line">b += d</span><br><span class="line">c.append(d)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206225906416.png" alt="image-20200206225906416" style="zoom:50%;"></p>
<p>The <code>pop</code> method removes and returns the last element of the list. When given an integer argument <code>i</code>, it removes and returns the element at index <code>i</code> of the list. This method mutates the list, reducing its length by one. Attempting to pop from an empty list causes an <code>IndexError</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">b = a.pop(<span class="number">2</span>)</span><br><span class="line">c = a.pop()</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230004637.png" alt="image-20200206230004637" style="zoom:50%;"></p>
<p>The <code>remove</code> method takes one argument that must be equal to a value in the list. It removes the first item in the list that is equal to its argument. Calling <code>remove</code> on a value that is not equal to any item in the list causes a <code>ValueError</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">12</span>, [<span class="number">13</span>, <span class="number">14</span>]]</span><br><span class="line">a.remove([<span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">a.remove(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230054899.png" alt="image-20200206230054899" style="zoom:50%;"></p>
<p>The <code>index</code> method takes one argument that must be equal to a value in the list. It returns the index in the list of the first item that is equal to the argument. Calling <code>index</code> on a value that is not equal to any item in the list causes a <code>ValueError</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [13, 14, 13, 12, [13, 14], 15]</span><br><span class="line">&gt;&gt;&gt; a.index([13, 14])</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; a.index(13)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>The <code>insert</code> method takes two arguments: an index and a value to be inserted. The value is added to the list at the given index. All elements before the given index stay the same, but all elements after the index have their indices increased by one. This method mutates the list by increasing its size by one, then returns <code>None</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.insert(<span class="number">0</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">a.insert(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">a.insert(<span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230155509.png" alt="image-20200206230155509" style="zoom:50%;"></p>
<p>The <code>count</code> method of a list takes in an item as an argument and returns how many times an equal item apears in the list. If the argument is not equal to any element of the list, then <code>count</code> returns 0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, [2, 3], 1, [4, 5]]</span><br><span class="line">&gt;&gt;&gt; a.count([2, 3])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; a.count(1)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; a.count(5)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>List comprehensions.</strong> A list comprehension always creates a new list. For example, the <code>unicodedata</code>module tracks the official names of every character in the Unicode alphabet. We can look up the characters corresponding to names, including those for card suits.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from unicodedata import lookup</span><br><span class="line">&gt;&gt;&gt; [lookup(&#39;WHITE &#39; + s.upper() + &#39; SUIT&#39;) for s in suits]</span><br><span class="line">[&#39;♡&#39;, &#39;♢&#39;, &#39;♤&#39;, &#39;♧&#39;]</span><br></pre></td></tr></table></figure>
<p>This resulting list does not share any of its contents with <code>suits</code>, and evaluating the list comprehension does not modify the <code>suits</code> list.</p>
<p>You can read more about the Unicode standard for representing text in the <a href="http://getpython3.com/diveintopython3/strings.html#one-ring-to-rule-them-all" target="_blank" rel="noopener">Unicode section</a> of Dive into Python 3.</p>
<p><strong>Tuples.</strong> A tuple, an instance of the built-in <code>tuple</code> type, is an immutable sequence. Tuples are created using a tuple literal that separates element expressions by commas. Parentheses are optional but used commonly in practice. Any objects can be placed within tuples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1, 2 + 3</span><br><span class="line">(1, 5)</span><br><span class="line">&gt;&gt;&gt; (&quot;the&quot;, 1, (&quot;and&quot;, &quot;only&quot;))</span><br><span class="line">(&#39;the&#39;, 1, (&#39;and&#39;, &#39;only&#39;))</span><br><span class="line">&gt;&gt;&gt; type( (10, 20) )</span><br><span class="line">&lt;class &#39;tuple&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>Empty and one-element tuples have special literal syntax.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ()    # 0 elements</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; (10,) # 1 element</span><br><span class="line">(10,)</span><br></pre></td></tr></table></figure>
<p>Like lists, tuples have a finite length and support element selection. They also have a few methods that are also available for lists, such as <code>count</code> and <code>index</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; code &#x3D; (&quot;up&quot;, &quot;up&quot;, &quot;down&quot;, &quot;down&quot;) + (&quot;left&quot;, &quot;right&quot;) * 2</span><br><span class="line">&gt;&gt;&gt; len(code)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; code[3]</span><br><span class="line">&#39;down&#39;</span><br><span class="line">&gt;&gt;&gt; code.count(&quot;down&quot;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; code.index(&quot;left&quot;)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>However, the methods for manipulating the contents of a list are not available for tuples because tuples are immutable.</p>
<p>While it is not possible to change which elements are in a tuple, it is possible to change the value of a mutable element contained within a tuple.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nest = (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">nest[<span class="number">2</span>].pop()</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230251700.png" alt="image-20200206230251700" style="zoom:50%;"></p>
<p>Tuples are used implicitly in multiple assignment. An assignment of two values to two names creates a two-element tuple and then unpacks it.</p>
<p>attention to</p>
<h3 id="2-4-3-Dictionaries"><a href="#2-4-3-Dictionaries" class="headerlink" title="2.4.3  Dictionaries"></a>2.4.3  Dictionaries</h3><p>Dictionaries are Python’s built-in data type for storing and manipulating correspondence relationships. A dictionary contains key-value pairs, where both the keys and values are objects. The purpose of a dictionary is to provide an abstraction for storing and retrieving values that are indexed not by consecutive integers, but by descriptive keys.</p>
<p>Strings commonly serve as keys, because strings are our conventional representation for names of things. This dictionary literal gives the values of various Roman numerals.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numerals &#x3D; &#123;&#39;I&#39;: 1.0, &#39;V&#39;: 5, &#39;X&#39;: 10&#125;</span><br></pre></td></tr></table></figure>
<p>Looking up values by their keys uses the element selection operator that we previously applied to sequences.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numerals[&#39;X&#39;]</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>A dictionary can have at most one value for each key. Adding new key-value pairs and changing the existing value for a key can both be achieved with assignment statements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numerals[&#39;I&#39;] &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; numerals[&#39;L&#39;] &#x3D; 50</span><br><span class="line">&gt;&gt;&gt; numerals</span><br><span class="line">&#123;&#39;I&#39;: 1, &#39;X&#39;: 10, &#39;L&#39;: 50, &#39;V&#39;: 5&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that <code>&#39;L&#39;</code> was not added to the end of the output above. Dictionaries were unordered collections of key-value pairs until Python 3.6. Since Python 3.6, their contents will be ordered by insertion. Since dictionaries were historically unordered collections, it is safest not to assume anything about the order in which keys and values will be printed.</p>
<p>Dictionaries can appear in environment diagrams as well.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numerals = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>&#125;</span><br><span class="line">numerals[<span class="string">'L'</span>] = <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230344409.png" alt="image-20200206230344409" style="zoom:50%;"></p>
<p>The dictionary type also supports various methods of iterating over the contents of the dictionary as a whole. The methods <code>keys</code>, <code>values</code>, and <code>items</code> all return iterable values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(numerals.values())</span><br><span class="line">66</span><br></pre></td></tr></table></figure>
<p>A list of key-value pairs can be converted into a dictionary by calling the <code>dict</code> constructor function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(3, 9), (4, 16), (5, 25)])</span><br><span class="line">&#123;3: 9, 4: 16, 5: 25&#125;</span><br></pre></td></tr></table></figure>
<p>Dictionaries do have some restrictions:</p>
<ul>
<li>A key of a dictionary cannot be or contain a mutable value.</li>
<li>There can be at most one value for a given key.</li>
</ul>
<p>This first restriction is tied to the underlying implementation of dictionaries in Python. The details of this implementation are not a topic of this text. Intuitively, consider that the key tells Python where to find that key-value pair in memory; if the key changes, the location of the pair may be lost. Tuples are commonly used for keys in dictionaries because lists cannot be used.</p>
<p>The second restriction is a consequence of the dictionary abstraction, which is designed to store and retrieve values for keys. We can only retrieve <em>the</em> value for a key if at most one such value exists in the dictionary.</p>
<p>A useful method implemented by dictionaries is <code>get</code>, which returns either the value for a key, if the key is present, or a default value. The arguments to <code>get</code> are the key and the default value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numerals.get(&#39;A&#39;, 0)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; numerals.get(&#39;V&#39;, 0)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Dictionaries also have a comprehension syntax analogous to those of lists. A key expression and a value expression are separated by a colon. Evaluating a dictionary comprehension creates a new dictionary object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;x: x*x for x in range(3,6)&#125;</span><br><span class="line">&#123;3: 9, 4: 16, 5: 25&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-Local-State"><a href="#2-4-4-Local-State" class="headerlink" title="2.4.4  Local State"></a>2.4.4  Local State</h3><p>Lists and dictionaries have <em>local state</em>: they are changing values that have some particular contents at any point in the execution of a program. The word “state” implies an evolving process in which that state may change.</p>
<p>Functions can also have local state. For instance, let us define a function that models the process of withdrawing money from a bank account. We will create a function called <code>withdraw</code>, which takes as its argument an amount to be withdrawn. If there is enough money in the account to accommodate the withdrawal, then <code>withdraw</code> will return the balance remaining after the withdrawal. Otherwise, <code>withdraw</code> will return the message <code>&#39;Insufficient funds&#39;</code>. For example, if we begin with $100 in the account, we would like to obtain the following sequence of return values by calling withdraw:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; withdraw(25)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; withdraw(25)</span><br><span class="line">50</span><br><span class="line">&gt;&gt;&gt; withdraw(60)</span><br><span class="line">&#39;Insufficient funds&#39;</span><br><span class="line">&gt;&gt;&gt; withdraw(15)</span><br><span class="line">35</span><br></pre></td></tr></table></figure>
<p>Above, the expression <code>withdraw(25)</code>, evaluated twice, yields different values. Thus, this user-defined function is non-pure. Calling the function not only returns a value, but also has the side effect of changing the function in some way, so that the next call with the same argument will return a different result. This side effect is a result of <code>withdraw</code> making a change to a name-value binding outside of the current frame.</p>
<p>For <code>withdraw</code> to make sense, it must be created with an initial account balance. The function <code>make_withdraw</code> is a higher-order function that takes a starting balance as an argument. The function <code>withdraw</code> is its return value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; withdraw &#x3D; make_withdraw(100)</span><br></pre></td></tr></table></figure>
<p>An implementation of <code>make_withdraw</code> requires a new kind of statement: a <code>nonlocal</code> statement. When we call <code>make_withdraw</code>, we bind the name <code>balance</code> to the initial amount. We then define and return a local function, <code>withdraw</code>, which updates and returns the value of <code>balance</code> when called.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;Return a withdraw function that draws down balance with each call.&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # Declare the name &quot;balance&quot; nonlocal</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#39;Insufficient funds&#39;</span><br><span class="line">            balance &#x3D; balance - amount       # Re-bind the existing balance name</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure>
<p>The <code>nonlocal</code> statement declares that whenever we change the binding of the name <code>balance</code>, the binding is changed in the first frame in which <code>balance</code> is already bound. Recall that without the <code>nonlocal</code>statement, an assignment statement would always bind a name in the first frame of the current environment. The <code>nonlocal</code> statement indicates that the name appears somewhere in the environment other than the first (local) frame or the last (global) frame.</p>
<p>The following environment diagrams illustrate the effects of multiple calls to a function created by <code>make_withdraw</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_withdraw</span><span class="params">(balance)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br><span class="line">wd(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230449146.png" alt="image-20200206230449146" style="zoom:50%;"></p>
<p>The first def statement has the usual effect: it creates a new user-defined function and binds the name <code>make_withdraw</code> to that function in the global frame. The subsequent call to <code>make_withdraw</code> creates and returns a locally defined function <code>withdraw</code>. The name <code>balance</code> is bound in the parent frame of this function. Crucially, there will only be this single binding for the name <code>balance</code> throughout the rest of this example.</p>
<p>Next, we evaluate an expression that calls this function, bound to the name <code>wd</code>, on an amount 5. The body of <code>withdraw</code> is executed in a new environment that extends the environment in which <code>withdraw</code> was defined. Tracing the effect of evaluating <code>withdraw</code> illustrates the effect of a <code>nonlocal</code> statement in Python: a name outside of the first local frame can be changed by an assignment statement.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230538522.png" alt="image-20200206230538522" style="zoom:50%;"></p>
<p>The <code>nonlocal</code> statement changes all of the remaining assignment statements in the definition of <code>withdraw</code>. After executing <code>nonlocal balance</code>, any assignment statement with <code>balance</code> on the left-hand side of <code>=</code> will not bind <code>balance</code> in the first frame of the current environment. Instead, it will find the first frame in which <code>balance</code> was already defined and re-bind the name in that frame. If <code>balance</code> has not previously been bound to a value, then the <code>nonlocal</code> statement will give an error.</p>
<p>By virtue of changing the binding for <code>balance</code>, we have changed the <code>withdraw</code> function as well. The next time it is called, the name <code>balance</code> will evaluate to 15 instead of 20. Hence, when we call <code>withdraw</code> a second time, we see that its return value is 12 and not 17. The change to <code>balance</code> from the first call affects the result of the second call.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230748739.png" alt="image-20200206230748739" style="zoom:50%;"></p>
<p>The second call to <code>withdraw</code> does create a second local frame, as usual. However, both <code>withdraw</code> frames have the same parent. That is, they both extend the environment for <code>make_withdraw</code>, which contains the binding for <code>balance</code>. Hence, they share that particular name binding. Calling <code>withdraw</code> has the side effect of altering the environment that will be extended by future calls to <code>withdraw</code>. The <code>nonlocal</code> statement allows <code>withdraw</code> to change a name binding in the <code>make_withdraw</code> frame.</p>
<p>Ever since we first encountered nested <code>def</code> statements, we have observed that a locally defined function can look up names outside of its local frames. No <code>nonlocal</code> statement is required to <em>access</em> a non-local name. By contrast, only after a <code>nonlocal</code> statement can a function <em>change</em> the binding of names in these frames.</p>
<p>By introducing <code>nonlocal</code> statements, we have created a dual role for assignment statements. Either they change local bindings, or they change nonlocal bindings. In fact, assignment statements already had a dual role: they either created new bindings or re-bound existing names. Assignment can also change the contents of lists and dictionaries. The many roles of Python assignment can obscure the effects of executing an assignment statement. It is up to you as a programmer to document your code clearly so that the effects of assignment can be understood by others.</p>
<p><strong>Python Particulars.</strong> This pattern of non-local assignment is a general feature of programming languages with higher-order functions and lexical scope. Most other languages do not require a <code>nonlocal</code> statement at all. Instead, non-local assignment is often the default behavior of assignment statements.</p>
<p>Python also has an unusual restriction regarding the lookup of names: within the body of a function, all instances of a name must refer to the same frame. As a result, Python cannot look up the value of a name in a non-local frame, then bind that same name in the local frame, because the same name would be accessed in two different frames in the same function. This restriction allows Python to pre-compute which frame contains each name before executing the body of a function. When this restriction is violated, a confusing error message results. To demonstrate, the <code>make_withdraw</code> example is repeated below with the <code>nonlocal</code> statement removed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_withdraw</span><span class="params">(balance)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206230900314.png" alt="image-20200206230900314" style="zoom:50%;"></p>
<p>This <code>UnboundLocalError</code> appears because <code>balance</code> is assigned locally in line 5, and so Python assumes that all references to <code>balance</code> must appear in the local frame as well. This error occurs <em>before</em> line 5 is ever executed, implying that Python has considered line 5 in some way before executing line 3. As we study interpreter design, we will see that pre-computing facts about a function body before executing it is quite common. In this case, Python’s pre-processing restricted the frame in which <code>balance</code> could appear, and thus prevented the name from being found. Adding a <code>nonlocal</code> statement corrects this error. The <code>nonlocal</code> statement did not exist in Python 2.</p>
<h3 id="2-4-5-The-Benefits-of-Non-Local-Assignment"><a href="#2-4-5-The-Benefits-of-Non-Local-Assignment" class="headerlink" title="2.4.5  The Benefits of Non-Local Assignment"></a>2.4.5  The Benefits of Non-Local Assignment</h3><p>Non-local assignment is an important step on our path to viewing a program as a collection of independent and autonomous <em>objects</em>, which interact with each other but each manage their own internal state.</p>
<p>In particular, non-local assignment has given us the ability to maintain some state that is local to a function, but evolves over successive calls to that function. The <code>balance</code> associated with a particular withdraw function is shared among all calls to that function. However, the binding for balance associated with an instance of withdraw is inaccessible to the rest of the program. Only <code>wd</code> is associated with the frame for <code>make_withdraw</code> in which it was defined. If <code>make_withdraw</code> is called again, then it will create a separate frame with a separate binding for <code>balance</code>.</p>
<p>We can extend our example to illustrate this point. A second call to <code>make_withdraw</code> returns a second <code>withdraw</code> function that has a different parent. We bind this second function to the name <code>wd2</code> in the global frame.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_withdraw</span><span class="params">(balance)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd2 = make_withdraw(<span class="number">7</span>)</span><br><span class="line">wd2(<span class="number">6</span>)</span><br><span class="line">wd(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231021214.png" alt="image-20200206231021214" style="zoom:50%;"></p>
<p>Now, we see that there are in fact two bindings for the name <code>balance</code> in two different frames, and each <code>withdraw</code> function has a different parent. The name <code>wd</code> is bound to a function with a balance of 20, while<code>wd2</code> is bound to a different function with a balance of 7.</p>
<p>Calling <code>wd2</code> changes the binding of its non-local <code>balance</code> name, but does not affect the function bound to the name <code>withdraw</code>. A future call to <code>wd</code> is unaffected by the changing balance of <code>wd2</code>; its balance is still 20.</p>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231135959.png" alt="image-20200206231135959" style="zoom:50%;"></p>
<p>In this way, each instance of <code>withdraw</code> maintains its own balance state, but that state is inaccessible to any other function in the program. Viewing this situation at a higher level, we have created an abstraction of a bank account that manages its own internals but behaves in a way that models accounts in the world: it changes over time based on its own history of withdrawal requests.</p>
<h3 id="2-4-6-The-Cost-of-Non-Local-Assignment"><a href="#2-4-6-The-Cost-of-Non-Local-Assignment" class="headerlink" title="2.4.6  The Cost of Non-Local Assignment"></a>2.4.6  The Cost of Non-Local Assignment</h3><p>Our environment model of computation cleanly extends to explain the effects of non-local assignment. However, non-local assignment introduces some important nuances in the way we think about names and values.</p>
<p>Previously, our values did not change; only our names and bindings changed. When two names <code>a</code> and <code>b</code>were both bound to the value 4, it did not matter whether they were bound to the same 4 or different 4’s. As far as we could tell, there was only one 4 object that never changed.</p>
<p>However, functions with state do not behave this way. When two names <code>wd</code> and <code>wd2</code> are both bound to a <code>withdraw</code> function, it <em>does</em> matter whether they are bound to the same function or different instances of that function. Consider the following example, which contrasts the one we just analyzed. In this case, calling the function named by <code>wd2</code> did change the value of the function named by <code>wd</code>, because both names refer to the same function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_withdraw</span><span class="params">(balance)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">12</span>)</span><br><span class="line">wd2 = wd</span><br><span class="line">wd2(<span class="number">1</span>)</span><br><span class="line">wd(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231232752.png" alt="image-20200206231232752" style="zoom:50%;"></p>
<p>It is not unusual for two names to co-refer to the same value in the world, and so it is in our programs. But, as values change over time, we must be very careful to understand the effect of a change on other names that might refer to those values.</p>
<p>The key to correctly analyzing code with non-local assignment is to remember that only function calls can introduce new frames. Assignment statements always change bindings in existing frames. In this case, unless <code>make_withdraw</code> is called twice, there can be only one binding for <code>balance</code>.</p>
<p><strong>Sameness and change.</strong> These subtleties arise because, by introducing non-pure functions that change the non-local environment, we have changed the nature of expressions. An expression that contains only pure function calls is <em>referentially transparent</em>; its value does not change if we substitute one of its subexpression with the value of that subexpression.</p>
<p>Re-binding operations violate the conditions of referential transparency because they do more than return a value; they change the environment. When we introduce arbitrary re-binding, we encounter a thorny epistemological issue: what it means for two values to be the same. In our environment model of computation, two separately defined functions are not the same, because changes to one may not be reflected in the other.</p>
<p>In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces. For example, a rational number is determined by giving its numerator and its denominator. But this view is no longer valid in the presence of change, where a compound data object has an “identity” that is something different from the pieces of which it is composed. A bank account is still “the same” bank account even if we change the balance by making a withdrawal; conversely, we could have two bank accounts that happen to have the same balance, but are different objects.</p>
<p>Despite the complications it introduces, non-local assignment is a powerful tool for creating modular programs. Different parts of a program, which correspond to different environment frames, can evolve separately throughout program execution. Moreover, using functions with local state, we are able to implement mutable data types. In fact, we can implement abstract data types that are equivalent to the built-in <code>list</code> and <code>dict</code> types introduced above.</p>
<h3 id="2-4-7-Iterators"><a href="#2-4-7-Iterators" class="headerlink" title="2.4.7  Iterators"></a>2.4.7  Iterators</h3><p>Python and many other programming languages provide a unified way to process elements of a container value sequentially, called an iterator. An <em>iterator</em> is an object that provides sequential access to values, one by one.</p>
<p>The iterator abstraction has two components: a mechanism for retrieving the next element in the sequence being processed and a mechanism for signaling that the end of the sequence has been reached and no further elements remain. For any container, such as a list or range, an iterator can be obtained by calling the built-in <code>iter</code> function. The contents of the iterator can be accessed by calling the built-in <code>next</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; primes &#x3D; [2, 3, 5, 7]</span><br><span class="line">&gt;&gt;&gt; type(primes)</span><br><span class="line">&lt;class &#39;list&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; iterator &#x3D; iter(primes)</span><br><span class="line">&gt;&gt;&gt; type(iterator)</span><br><span class="line">&lt;class &#39;list_iterator&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Python signals that there are no more values available by raising a <code>StopIteration</code> exception when <code>next</code>is called. This exception can be handled using a <code>try</code> statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>An iterator maintains local state to represent its position in a sequence. Each time <code>next</code> is called, that position advances. Two separate iterators can track two different positions in the same sequence. However, two names for the same iterator will share a position because they share the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; range(3, 13)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; iter(r)  # 1st iterator over r</span><br><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t &#x3D; iter(r)  # 2nd iterator over r</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; u &#x3D; t        # Alternate name for the 2nd iterator</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>Advancing the second iterator does not affect the first. Since the last value returned from the first iterator was 4, it is positioned to return 5 next. On the other hand, the second iterator is positioned to return 7 next.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>Calling <code>iter</code> on an iterator will return that iterator, not a copy. This behavior is included in Python so that a programmer can call <code>iter</code> on a value to get an iterator without having to worry about whether it is an iterator or a container.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; v &#x3D; iter(t)  # Another alterante name for the 2nd iterator</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>The usefulness of iterators is derived from the fact that the underlying series of data for an iterator may not be represented explicitly in memory. An iterator provides a mechanism for considering each of a series of values in turn, but all of those elements do not need to be stored simultaneously. Instead, when the next element is requested from an iterator, that element may be computed on demand instead of being retrieved from an existing memory source.</p>
<p>Ranges are able to compute the elements of a sequence lazily because the sequence represented is uniform, and any element is easy to compute from the starting and ending bounds of the range. Iterators allow for lazy generation of a much broader class of underlying sequential datasets because they do not need to provide access to arbitrary elements of the underlying series. Instead, iterators are only required to compute the next element of the series, in order, each time another element is requested. While not as flexible as <em>random access</em> (accessing arbitrary elements of a sequence in any order), <em>sequential access</em>to sequential data is often sufficient for data processing applications.</p>
<h3 id="2-4-8-Iterables"><a href="#2-4-8-Iterables" class="headerlink" title="2.4.8  Iterables"></a>2.4.8  Iterables</h3><p>Any value that can produce iterators is called an <em>iterable</em> value. In Python, an iterable value is anything that can be passed to the built-in <code>iter</code> function. Iterables include sequence values such as strings and tuples, as well as other containers such as sets and dictionaries. Iterators are also iterables because they can be passed to the <code>iter</code> function.</p>
<p>Even unordered collections, such as dictionaries in Python 3.5 and earlier, must define an ordering over their contents when they produce iterators. Dictionaries and sets are unordered because the programmer has no control over the order of iteration, but Python does guarantee certain properties about their order in its specification.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;one&#39;: 1, &#39;three&#39;: 3, &#39;two&#39;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; k &#x3D; iter(d)</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">&#39;one&#39;</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">&#39;three&#39;</span><br><span class="line">&gt;&gt;&gt; v &#x3D; iter(d.values())</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>If a dictionary changes in structure because a key is added or removed, then all iterators become invalid, and future iterators may exhibit changes to the order of their contents. On the other hand, changing the value of an existing key does not invalidate iterators or change the order of their contents.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#39;two&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br></pre></td></tr></table></figure>
<p>A <code>for</code> statement can be used to iterate over the contents of any iterable or iterator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; range(3, 6)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; iter(r)</span><br><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; for x in s:</span><br><span class="line">        print(x)</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; list(s)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; for x in r:</span><br><span class="line">        print(x)</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="2-4-9-Built-in-Iterators"><a href="#2-4-9-Built-in-Iterators" class="headerlink" title="2.4.9  Built-in Iterators"></a>2.4.9  Built-in Iterators</h3><p>Several built-in functions take as arguments iterable values and return iterators. These functions are used extensively for lazy sequence processing.</p>
<p>The <code>map</code> function is lazy: calling it does not perform the computation required to compute elements of its result. Instead, an iterator object is created that can return results if queried using <code>next</code>. We can observe this fact in the following example, in which the call to <code>print</code> is delayed until the corresponding element is requested from the <code>doubled</code> iterator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#39;***&#39;, x, &#39;&#x3D;&gt;&#39;, 2*x, &#39;***&#39;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s &#x3D; range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled &#x3D; map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 &#x3D;&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 &#x3D;&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 &#x3D;&gt; 10 ***</span><br><span class="line">*** 6 &#x3D;&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>
<p>The <code>filter</code> function returns an iterator over a subset of the values in another iterable. The <code>zip</code> function returns an iterator over tuples of values that combine one value from each of multiple iterables.</p>
<h3 id="2-4-10-Generators"><a href="#2-4-10-Generators" class="headerlink" title="2.4.10  Generators"></a>2.4.10  Generators</h3><p>Generators allow us to define iterations over arbitrary sequences, even infinite sequences, by leveraging the features of the Python interpreter.</p>
<p>A <em>generator</em> is an iterator returned by a special class of function called a <em>generator function</em>. Generator functions are distinguished from regular functions in that rather than containing <code>return</code> statements in their body, they use <code>yield</code> statements to return elements of a series.</p>
<p>Generators do not use attributes of an object to track their progress through a series. Instead, they control the execution of the generator function, which runs until the next <code>yield</code> statement is executed each time <code>next</code> is called on the generator. For example, the <code>letters_generator</code> function below returns a generator over the letters a, b, c, and then d.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def letters_generator():</span><br><span class="line">        current &#x3D; &#39;a&#39;</span><br><span class="line">        while current &lt;&#x3D; &#39;d&#39;:</span><br><span class="line">            yield current</span><br><span class="line">            current &#x3D; chr(ord(current)+1)</span><br><span class="line">&gt;&gt;&gt; for letter in letters_generator():</span><br><span class="line">        print(letter)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>The <code>yield</code> statement indicates that we are defining a generator function, rather than a regular function. When called, a generator function doesn’t return a particular yielded value, but instead a <code>generator</code>(which is a type of iterator) that itself can return the yielded values. Calling <code>next</code> on the generator continues execution of the generator function from wherever it left off previously until another <code>yield</code>statement is executed.</p>
<p>The first time <code>next</code> is called, the program executes statements from the body of the <code>letters_generator</code>function until it encounters the <code>yield</code> statement. Then, it pauses and returns the value of <code>current</code>. <code>yield</code>statements do not destroy the newly created environment; they preserve it for later. When <code>next</code> is called again, execution resumes where it left off. The values of <code>current</code> and of any other bound names in the scope of <code>letters_generator</code> are preserved across subsequent calls to <code>next</code>.</p>
<p>We can walk through the generator by manually calling <code>next()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; letters &#x3D; letters_generator()</span><br><span class="line">&gt;&gt;&gt; type(letters)</span><br><span class="line">&lt;class &#39;generator&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;c&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;d&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>The generator does not start executing any of the body statements of its generator function until the first time <code>next</code> is called. The generator raises a <code>StopIteration</code> exception whenever its generator function returns.</p>
<h3 id="2-4-11-Implementing-Lists-and-Dictionaries"><a href="#2-4-11-Implementing-Lists-and-Dictionaries" class="headerlink" title="2.4.11  Implementing Lists and Dictionaries"></a>2.4.11  Implementing Lists and Dictionaries</h3><p>The Python language does not give us access to the implementation of lists, only to the sequence abstraction and mutation methods built into the language. To understand how a mutable list could be represented using functions with local state, we will now develop an implementation of a mutable linked list.</p>
<p>We will represent a mutable linked list by a function that has a linked list as its local state. Lists need to have an identity, like any mutable value. In particular, we cannot use <code>None</code> to represent an empty mutable list, because two empty lists are not identical values (e.g., appending to one does not append to the other), but <code>None is None</code>. On the other hand, two different functions that each have <code>empty</code> as their local state will suffice to distinguish two empty lists.</p>
<p>If a mutable linked list is a function, what arguments does it take? The answer exhibits a general pattern in programming: the function is a dispatch function and its arguments are first a message, followed by additional arguments to parameterize that method. This message is a string naming what the function should do. Dispatch functions are effectively many functions in one: the message determines the behavior of the function, and the additional arguments are used in that behavior.</p>
<p>Our mutable list will respond to five different messages: <code>len</code>, <code>getitem</code>, <code>push_first</code>, <code>pop_first</code>, and <code>str</code>. The first two implement the behaviors of the sequence abstraction. The next two add or remove the first element of the list. The final message returns a string representation of the whole linked list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mutable_link():</span><br><span class="line">        &quot;&quot;&quot;Return a functional implementation of a mutable linked list.&quot;&quot;&quot;</span><br><span class="line">        contents &#x3D; empty</span><br><span class="line">        def dispatch(message, value&#x3D;None):</span><br><span class="line">            nonlocal contents</span><br><span class="line">            if message &#x3D;&#x3D; &#39;len&#39;:</span><br><span class="line">                return len_link(contents)</span><br><span class="line">            elif message &#x3D;&#x3D; &#39;getitem&#39;:</span><br><span class="line">                return getitem_link(contents, value)</span><br><span class="line">            elif message &#x3D;&#x3D; &#39;push_first&#39;:</span><br><span class="line">                contents &#x3D; link(value, contents)</span><br><span class="line">            elif message &#x3D;&#x3D; &#39;pop_first&#39;:</span><br><span class="line">                f &#x3D; first(contents)</span><br><span class="line">                contents &#x3D; rest(contents)</span><br><span class="line">                return f</span><br><span class="line">            elif message &#x3D;&#x3D; &#39;str&#39;:</span><br><span class="line">                return join_link(contents, &quot;, &quot;)</span><br><span class="line">        return dispatch</span><br></pre></td></tr></table></figure>
<p>We can also add a convenience function to construct a functionally implemented linked list from any built-in sequence, simply by adding each element in reverse order.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def to_mutable_link(source):</span><br><span class="line">        &quot;&quot;&quot;Return a functional list with the same contents as source.&quot;&quot;&quot;</span><br><span class="line">        s &#x3D; mutable_link()</span><br><span class="line">        for element in reversed(source):</span><br><span class="line">            s(&#39;push_first&#39;, element)</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>
<p>In the definition above, the function <code>reversed</code> takes and returns an iterable value; it is another example of a function that processes sequences.</p>
<p>At this point, we can construct a functionally implemented mutable linked lists. Note that the linked list itself is a function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; to_mutable_link(suits)</span><br><span class="line">&gt;&gt;&gt; type(s)</span><br><span class="line">&lt;class &#39;function&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; print(s(&#39;str&#39;))</span><br><span class="line">heart, diamond, spade, club</span><br></pre></td></tr></table></figure>
<p>In addition, we can pass messages to the list <code>s</code> that change its contents, for instance removing the first element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s(&#39;pop_first&#39;)</span><br><span class="line">&#39;heart&#39;</span><br><span class="line">&gt;&gt;&gt; print(s(&#39;str&#39;))</span><br><span class="line">diamond, spade, club</span><br></pre></td></tr></table></figure>
<p>In principle, the operations <code>push_first</code> and <code>pop_first</code> suffice to make arbitrary changes to a list. We can always empty out the list entirely and then replace its old contents with the desired result.</p>
<p><strong>Message passing.</strong> Given some time, we could implement the many useful mutation operations of Python lists, such as <code>extend</code> and <code>insert</code>. We would have a choice: we could implement them all as functions, which use the existing messages <code>pop_first</code> and <code>push_first</code> to make all changes. Alternatively, we could add additional <code>elif</code> clauses to the body of <code>dispatch</code>, each checking for a message (e.g., <code>&#39;extend&#39;</code>) and applying the appropriate change to <code>contents</code> directly.</p>
<p>This second approach, which encapsulates the logic for all operations on a data value within one function that responds to different messages, is a discipline called message passing. A program that uses message passing defines dispatch functions, each of which may have local state, and organizes computation by passing “messages” as the first argument to those functions. The messages are strings that correspond to particular behaviors.</p>
<p><strong>Implementing Dictionaries.</strong> We can also implement a value with similar behavior to a dictionary. In this case, we use a list of key-value pairs to store the contents of the dictionary. Each pair is a two-element list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def dictionary():</span><br><span class="line">        &quot;&quot;&quot;Return a functional implementation of a dictionary.&quot;&quot;&quot;</span><br><span class="line">        records &#x3D; []</span><br><span class="line">        def getitem(key):</span><br><span class="line">            matches &#x3D; [r for r in records if r[0] &#x3D;&#x3D; key]</span><br><span class="line">            if len(matches) &#x3D;&#x3D; 1:</span><br><span class="line">                key, value &#x3D; matches[0]</span><br><span class="line">                return value</span><br><span class="line">        def setitem(key, value):</span><br><span class="line">            nonlocal records</span><br><span class="line">            non_matches &#x3D; [r for r in records if r[0] !&#x3D; key]</span><br><span class="line">            records &#x3D; non_matches + [[key, value]]</span><br><span class="line">        def dispatch(message, key&#x3D;None, value&#x3D;None):</span><br><span class="line">            if message &#x3D;&#x3D; &#39;getitem&#39;:</span><br><span class="line">                return getitem(key)</span><br><span class="line">            elif message &#x3D;&#x3D; &#39;setitem&#39;:</span><br><span class="line">                setitem(key, value)</span><br><span class="line">        return dispatch</span><br></pre></td></tr></table></figure>
<p>Again, we use the message passing method to organize our implementation. We have supported two messages: <code>getitem</code> and <code>setitem</code>. To insert a value for a key, we filter out any existing records with the given key, then add one. In this way, we are assured that each key appears only once in records. To look up a value for a key, we filter for the record that matches the given key. We can now use our implementation to store and retrieve values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dictionary()</span><br><span class="line">&gt;&gt;&gt; d(&#39;setitem&#39;, 3, 9)</span><br><span class="line">&gt;&gt;&gt; d(&#39;setitem&#39;, 4, 16)</span><br><span class="line">&gt;&gt;&gt; d(&#39;getitem&#39;, 3)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; d(&#39;getitem&#39;, 4)</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>This implementation of a dictionary is <em>not</em> optimized for fast record lookup, because each call must filter through all records. The built-in dictionary type is considerably more efficient. The way in which it is implemented is beyond the scope of this text.</p>
<h3 id="2-4-12-Dispatch-Dictionaries"><a href="#2-4-12-Dispatch-Dictionaries" class="headerlink" title="2.4.12  Dispatch Dictionaries"></a>2.4.12  Dispatch Dictionaries</h3><p>The dispatch function is a general method for implementing a message passing interface for abstract data. To implement message dispatch, we have thus far used conditional statements to compare the message string to a fixed set of known messages.</p>
<p>The built-in dictionary data type provides a general method for looking up a value for a key. Instead of using conditionals to implement dispatching, we can use dictionaries with string keys.</p>
<p>The mutable <code>account</code> data type below is implemented as a dictionary. It has a constructor <code>account</code> and selector <code>check_balance</code>, as well as functions to <code>deposit</code> or <code>withdraw</code> funds. Moreover, the local state of the account is stored in the dictionary alongside the functions that implement its behavior.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">account</span><span class="params">(initial_balance)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(amount)</span>:</span></span><br><span class="line">        dispatch[<span class="string">'balance'</span>] += amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">'balance'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(amount)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> amount &gt; dispatch[<span class="string">'balance'</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        dispatch[<span class="string">'balance'</span>] -= amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">'balance'</span>]</span><br><span class="line">    dispatch = &#123;<span class="string">'deposit'</span>:   deposit,</span><br><span class="line">                <span class="string">'withdraw'</span>:  withdraw,</span><br><span class="line">                <span class="string">'balance'</span>:   initial_balance&#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(account, amount)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'withdraw'</span>](amount)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(account, amount)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'deposit'</span>](amount)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_balance</span><span class="params">(account)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'balance'</span>]</span><br><span class="line"></span><br><span class="line">a = account(<span class="number">20</span>)</span><br><span class="line">deposit(a, <span class="number">5</span>)</span><br><span class="line">withdraw(a, <span class="number">17</span>)</span><br><span class="line">check_balance(a)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231349191.png" alt="image-20200206231349191" style="zoom:50%;"></p>
<p>The name <code>dispatch</code> within the body of the <code>account</code> constructor is bound to a dictionary that contains the messages accepted by an account as keys. The <em>balance</em> is a number, while the messages <em>deposit</em> and <em>withdraw</em> are bound to functions. These functions have access to the <code>dispatch</code> dictionary, and so they can read and change the balance. By storing the balance in the dispatch dictionary rather than in the <code>account</code> frame directly, we avoid the need for <code>nonlocal</code> statements in <code>deposit</code> and <code>withdraw</code>.</p>
<p>The operators <code>+=</code> and <code>-=</code> are shorthand in Python (and many other languages) for combined lookup and re-assignment. The last two lines below are equivalent.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; a &#x3D; a + 1</span><br><span class="line">&gt;&gt;&gt; a +&#x3D; 1</span><br></pre></td></tr></table></figure>
<h3 id="2-4-13-Propagating-Constraints"><a href="#2-4-13-Propagating-Constraints" class="headerlink" title="2.4.13  Propagating Constraints"></a>2.4.13  Propagating Constraints</h3><p>Mutable data allows us to simulate systems with change, but also allows us to build new kinds of abstractions. In this extended example, we combine nonlocal assignment, lists, and dictionaries to build a <em>constraint-based system</em> that supports computation in multiple directions. Expressing programs as constraints is a type of <em>declarative programming</em>, in which a programmer declares the structure of a problem to be solved, but abstracts away the details of exactly how the solution to the problem is computed.</p>
<p>Computer programs are traditionally organized as one-directional computations, which perform operations on pre-specified arguments to produce desired outputs. On the other hand, we often want to model systems in terms of relations among quantities. For example, we previously considered the ideal gas law, which relates the pressure (<code>p</code>), volume (<code>v</code>), quantity (<code>n</code>), and temperature (<code>t</code>) of an ideal gas via Boltzmann’s constant (<code>k</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p * v &#x3D; n * k * t</span><br></pre></td></tr></table></figure>
<p>Such an equation is not one-directional. Given any four of the quantities, we can use this equation to compute the fifth. Yet translating the equation into a traditional computer language would force us to choose one of the quantities to be computed in terms of the other four. Thus, a function for computing the pressure could not be used to compute the temperature, even though the computations of both quantities arise from the same equation.</p>
<p>In this section, we sketch the design of a general model of linear relationships. We define primitive constraints that hold between quantities, such as an <code>adder(a, b, c)</code> constraint that enforces the mathematical relationship <code>a + b = c</code>.</p>
<p>We also define a means of combination, so that primitive constraints can be combined to express more complex relations. In this way, our program resembles a programming language. We combine constraints by constructing a network in which constraints are joined by connectors. A connector is an object that “holds” a value and may participate in one or more constraints.</p>
<p>For example, we know that the relationship between Fahrenheit and Celsius temperatures is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 * c &#x3D; 5 * (f - 32)</span><br></pre></td></tr></table></figure>
<p>This equation is a complex constraint between <code>c</code> and <code>f</code>. Such a constraint can be thought of as a network consisting of primitive <code>adder</code>, <code>multiplier</code>, and <code>constant</code> constraints.</p>
<p><img src="http://composingprograms.com/img/constraints.png" alt="img"></p>
<p>In this figure, we see on the left a multiplier box with three terminals, labeled <code>a</code>, <code>b</code>, and <code>c</code>. These connect the multiplier to the rest of the network as follows: The <code>a</code> terminal is linked to a connector <code>celsius</code>, which will hold the Celsius temperature. The <code>b</code> terminal is linked to a connector <code>w</code>, which is also linked to a constant box that holds 9. The <code>c</code> terminal, which the multiplier box constrains to be the product of <code>a</code> and<code>b</code>, is linked to the <code>c</code> terminal of another multiplier box, whose <code>b</code> is connected to a constant 5 and whose <code>a</code>is connected to one of the terms in the sum constraint.</p>
<p>Computation by such a network proceeds as follows: When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on. For instance, in conversion between Celsius and Fahrenheit, <code>w</code>, <code>x</code>, and <code>y</code> are immediately set by the constant boxes to 9, 5, and 32, respectively. The connectors awaken the multipliers and the adder, which determine that there is not enough information to proceed. If the user (or some other part of the network) sets the <code>celsius</code>connector to a value (say 25), the leftmost multiplier will be awakened, and it will set <code>u</code> to <code>25 * 9 = 225</code>. Then <code>u</code> awakens the second multiplier, which sets <code>v</code> to 45, and <code>v</code> awakens the adder, which sets the <code>fahrenheit</code> connector to 77.</p>
<p><strong>Using the Constraint System.</strong> To use the constraint system to carry out the temperature computation outlined above, we first create two named connectors, <code>celsius</code> and <code>fahrenheit</code>, by calling the <code>connector</code> constructor.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius &#x3D; connector(&#39;Celsius&#39;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit &#x3D; connector(&#39;Fahrenheit&#39;)</span><br></pre></td></tr></table></figure>
<p>Then, we link these connectors into a network that mirrors the figure above. The function <code>converter</code>assembles the various connectors and constraints in the network.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;Connect c to f with constraints to convert from Celsius to Fahrenheit.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y &#x3D; [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure>
<p>We will use a message passing system to coordinate constraints and connectors. Constraints are dictionaries that do not hold local states themselves. Their responses to messages are non-pure functions that change the connectors that they constrain.</p>
<p>Connectors are dictionaries that hold a current value and respond to messages that manipulate that value. Constraints will not change the value of connectors directly, but instead will do so by sending messages, so that the connector can notify other constraints in response to the change. In this way, a connector represents a number, but also encapsulates connector behavior.</p>
<p>One message we can send to a connector is to set its value. Here, we (the <code>&#39;user&#39;</code>) set the value of <code>celsius</code> to 25.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#39;set_val&#39;](&#39;user&#39;, 25)</span><br><span class="line">Celsius &#x3D; 25</span><br><span class="line">Fahrenheit &#x3D; 77.0</span><br></pre></td></tr></table></figure>
<p>Not only does the value of <code>celsius</code> change to 25, but its value propagates through the network, and so the value of <code>fahrenheit</code> is changed as well. These changes are printed because we named these two connectors when we constructed them.</p>
<p>Now we can try to set <code>fahrenheit</code> to a new value, say 212.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#39;set_val&#39;](&#39;user&#39;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure>
<p>The connector complains that it has sensed a contradiction: Its value is 77.0, and someone is trying to set it to 212. If we really want to reuse the network with new values, we can tell <code>celsius</code> to forget its old value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#39;forget&#39;](&#39;user&#39;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure>
<p>The connector <code>celsius</code> finds that the <code>user</code>, who set its value originally, is now retracting that value, so <code>celsius</code> agrees to lose its value, and it informs the rest of the network of this fact. This information eventually propagates to <code>fahrenheit</code>, which now finds that it has no reason for continuing to believe that its own value is 77. Thus, it also gives up its value.</p>
<p>Now that <code>fahrenheit</code> has no value, we are free to set it to 212:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#39;set_val&#39;](&#39;user&#39;, 212)</span><br><span class="line">Fahrenheit &#x3D; 212</span><br><span class="line">Celsius &#x3D; 100.0</span><br></pre></td></tr></table></figure>
<p>This new value, when propagated through the network, forces <code>celsius</code> to have a value of 100. We have used the very same network to compute <code>celsius</code> given <code>fahrenheit</code> and to compute <code>fahrenheit</code> given <code>celsius</code>. This non-directionality of computation is the distinguishing feature of constraint-based systems.</p>
<p><strong>Implementing the Constraint System.</strong> As we have seen, connectors are dictionaries that map message names to function and data values. We will implement connectors that respond to the following messages:</p>
<ul>
<li><code>connector[&#39;set_val&#39;](source, value)</code> indicates that the <code>source</code> is requesting the connector to set its current value to <code>value</code>.</li>
<li><code>connector[&#39;has_val&#39;]()</code> returns whether the connector already has a value.</li>
<li><code>connector[&#39;val&#39;]</code> is the current value of the connector.</li>
<li><code>connector[&#39;forget&#39;](source)</code> tells the connector that the <code>source</code> is requesting it to forget its value.</li>
<li><code>connector[&#39;connect&#39;](source)</code> tells the connector to participate in a new constraint, the <code>source</code>.</li>
</ul>
<p>Constraints are also dictionaries, which receive information from connectors by means of two messages:</p>
<ul>
<li><code>constraint[&#39;new_val&#39;]()</code> indicates that some connector that is connected to the constraint has a new value.</li>
<li><code>constraint[&#39;forget&#39;]()</code> indicates that some connector that is connected to the constraint has forgotten its value.</li>
</ul>
<p>When constraints receive these messages, they propagate them appropriately to other connectors.</p>
<p>The <code>adder</code> function constructs an adder constraint over three connectors, where the first two must add to the third: <code>a + b = c</code>. To support multidirectional constraint propagation, the adder must also specify that it subtracts <code>a</code> from <code>c</code> to get <code>b</code> and likewise subtracts <code>b</code> from <code>c</code> to get <code>a</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;The constraint that a + b &#x3D; c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure>
<p>We would like to implement a generic ternary (three-way) constraint, which uses the three connectors and three functions from <code>adder</code> to create a constraint that accepts <code>new_val</code> and <code>forget</code> messages. The response to messages are local functions, which are placed in a dictionary called <code>constraint</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;The constraint that ab(a,b)&#x3D;c and ca(c,a)&#x3D;b and cb(c,b) &#x3D; a.&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv &#x3D; [connector[&#39;has_val&#39;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#39;set_val&#39;](constraint, ab(a[&#39;val&#39;], b[&#39;val&#39;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#39;set_val&#39;](constraint, ca(c[&#39;val&#39;], a[&#39;val&#39;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#39;set_val&#39;](constraint, cb(c[&#39;val&#39;], b[&#39;val&#39;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#39;forget&#39;](constraint)</span><br><span class="line">        constraint &#x3D; &#123;&#39;new_val&#39;: new_value, &#39;forget&#39;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#39;connect&#39;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>The dictionary called <code>constraint</code> is a dispatch dictionary, but also the constraint object itself. It responds to the two messages that constraints receive, but is also passed as the <code>source</code> argument in calls to its connectors.</p>
<p>The constraint’s local function <code>new_value</code> is called whenever the constraint is informed that one of its connectors has a value. This function first checks to see if both <code>a</code> and <code>b</code> have values. If so, it tells <code>c</code> to set its value to the return value of function <code>ab</code>, which is <code>add</code> in the case of an <code>adder</code>. The constraint passes <em>itself</em> (<code>constraint</code>) as the <code>source</code> argument of the connector, which is the adder object. If <code>a</code> and <code>b</code> do not both have values, then the constraint checks <code>a</code> and <code>c</code>, and so on.</p>
<p>If the constraint is informed that one of its connectors has forgotten its value, it requests that all of its connectors now forget their values. (Only those values that were set by this constraint are actually lost.)</p>
<p>A <code>multiplier</code> is very similar to an <code>adder</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;The constraint that a * b &#x3D; c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure>
<p>A constant is a constraint as well, but one that is never sent any messages, because it involves only a single connector that it sets on construction.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;The constraint that connector &#x3D; value.&quot;&quot;&quot;</span><br><span class="line">        constraint &#x3D; &#123;&#125;</span><br><span class="line">        connector[&#39;set_val&#39;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>These three constraints are sufficient to implement our temperature conversion network.</p>
<p><strong>Representing connectors.</strong> A connector is represented as a dictionary that contains a value, but also has response functions with local state. The connector must track the <code>informant</code> that gave it its current value, and a list of <code>constraints</code> in which it participates.</p>
<p>The constructor <code>connector</code> has local functions for setting and forgetting values, which are the responses to messages from constraints.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;A connector between constraints.&quot;&quot;&quot;</span><br><span class="line">        informant &#x3D; None</span><br><span class="line">        constraints &#x3D; []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val &#x3D; connector[&#39;val&#39;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#39;val&#39;] &#x3D; source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#39;&#x3D;&#39;, value)</span><br><span class="line">                inform_all_except(source, &#39;new_val&#39;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val !&#x3D; value:</span><br><span class="line">                    print(&#39;Contradiction detected:&#39;, val, &#39;vs&#39;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant &#x3D;&#x3D; source:</span><br><span class="line">                informant, connector[&#39;val&#39;] &#x3D; None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#39;is forgotten&#39;)</span><br><span class="line">                inform_all_except(source, &#39;forget&#39;, constraints)</span><br><span class="line">        connector &#x3D; &#123;&#39;val&#39;: None,</span><br><span class="line">                     &#39;set_val&#39;: set_value,</span><br><span class="line">                     &#39;forget&#39;: forget_value,</span><br><span class="line">                     &#39;has_val&#39;: lambda: connector[&#39;val&#39;] is not None,</span><br><span class="line">                     &#39;connect&#39;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure>
<p>A connector is again a dispatch dictionary for the five messages used by constraints to communicate with connectors. Four responses are functions, and the final response is the value itself.</p>
<p>The local function <code>set_value</code> is called when there is a request to set the connector’s value. If the connector does not currently have a value, it will set its value and remember as <code>informant</code> the source constraint that requested the value to be set. Then the connector will notify all of its participating constraints except the constraint that requested the value to be set. This is accomplished using the following iterative function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;Inform all constraints of the message, except source.&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c !&#x3D; source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure>
<p>If a connector is asked to forget its value, it calls the local function <code>forget-value</code>, which first checks to make sure that the request is coming from the same constraint that set the value originally. If so, the connector informs its associated constraints about the loss of the value.</p>
<p>The response to the message <code>has_val</code> indicates whether the connector has a value. The response to the message <code>connect</code> adds the source constraint to the list of constraints.</p>
<p>The constraint program we have designed introduces many ideas that will appear again in object-oriented programming. Constraints and connectors are both abstractions that are manipulated through messages. When the value of a connector is changed, it is changed via a message that not only changes the value, but validates it (checking the source) and propagates its effects (informing other constraints). In fact, we will use a similar architecture of dictionaries with string-valued keys and functional values to implement an object-oriented system later in this chapter.</p>
<h2 id="2-5-Object-Oriented-Programming"><a href="#2-5-Object-Oriented-Programming" class="headerlink" title="2.5  Object-Oriented Programming"></a>2.5  Object-Oriented Programming</h2><p>Object-oriented programming (OOP) is a method for organizing programs that brings together many of the ideas introduced in this chapter. Like the functions in data abstraction, classes create abstraction barriers between the use and implementation of data. Like dispatch dictionaries, objects respond to behavioral requests. Like mutable data structures, objects have local state that is not directly accessible from the global environment. The Python object system provides convenient syntax to promote the use of these techniques for organizing programs. Much of this syntax is shared among other object-oriented programming languages.</p>
<p>The object system offers more than just convenience. It enables a new metaphor for designing programs in which several independent agents interact within the computer. Each object bundles together local state and behavior in a way that abstracts the complexity of both. Objects communicate with each other, and useful results are computed as a consequence of their interaction. Not only do objects pass messages, they also share behavior among other objects of the same type and inherit characteristics from related types.</p>
<p>The paradigm of object-oriented programming has its own vocabulary that supports the object metaphor. We have seen that an object is a data value that has methods and attributes, accessible via dot notation. Every object also has a type, called its <em>class</em>. To create new types of data, we implement new classes.</p>
<h3 id="2-5-1-Objects-and-Classes"><a href="#2-5-1-Objects-and-Classes" class="headerlink" title="2.5.1  Objects and Classes"></a>2.5.1  Objects and Classes</h3><p>A class serves as a template for all objects whose type is that class. Every object is an instance of some particular class. The objects we have used so far all have built-in classes, but new user-defined classes can be created as well. A class definition specifies the attributes and methods shared among objects of that class. We will introduce the class statement by revisiting the example of a bank account.</p>
<p>When introducing local state, we saw that bank accounts are naturally modeled as mutable values that have a <code>balance</code>. A bank account object should have a <code>withdraw</code> method that updates the account balance and returns the requested amount, if it is available. To complete the abstraction: a bank account should be able to return its current <code>balance</code>, return the name of the account <code>holder</code>, and an amount for <code>deposit</code>.</p>
<p>An <code>Account</code> class allows us to create multiple instances of bank accounts. The act of creating a new object instance is known as <em>instantiating</em> the class. The syntax in Python for instantiating a class is identical to the syntax of calling a function. In this case, we call <code>Account</code> with the argument <code>&#39;Kirk&#39;</code>, the account holder’s name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Account(&#39;Kirk&#39;)</span><br></pre></td></tr></table></figure>
<p>An <em>attribute</em> of an object is a name-value pair associated with the object, which is accessible via dot notation. The attributes specific to a particular object, as opposed to all objects of a class, are called <em>instance attributes</em>. Each <code>Account</code> has its own balance and account holder name, which are examples of instance attributes. In the broader programming community, instance attributes may also be called <em>fields</em>, <em>properties</em>, or <em>instance variables</em>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.holder</span><br><span class="line">&#39;Kirk&#39;</span><br><span class="line">&gt;&gt;&gt; a.balance</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Functions that operate on the object or perform object-specific computations are called methods. The return values and side effects of a method can depend upon and change other attributes of the object. For example, <code>deposit</code> is a method of our <code>Account</code> object <code>a</code>. It takes one argument, the amount to deposit, changes the <code>balance</code> attribute of the object, and returns the resulting balance.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.deposit(15)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>We say that methods are <em>invoked</em> on a particular object. As a result of invoking the <code>withdraw</code> method, either the withdrawal is approved and the amount is deducted, or the request is declined and the method returns an error message.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.withdraw(10)  # The withdraw method returns the balance after withdrawal</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; a.balance       # The balance attribute has changed</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; a.withdraw(10)</span><br><span class="line">&#39;Insufficient funds&#39;</span><br></pre></td></tr></table></figure>
<p>As illustrated above, the behavior of a method can depend upon the changing attributes of the object. Two calls to <code>withdraw</code> with the same argument return different results.</p>
<h3 id="2-5-2-Defining-Classes"><a href="#2-5-2-Defining-Classes" class="headerlink" title="2.5.2  Defining Classes"></a>2.5.2  Defining Classes</h3><p>User-defined classes are created by <code>class</code> statements, which consist of a single clause. A class statement defines the class name, then includes a suite of statements to define the attributes of the class:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class &lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>When a class statement is executed, a new class is created and bound to <code>in the first frame of the current environment. The suite is then executed. Any names bound within the</code> of a <code>class</code>statement, through <code>def</code> or assignment statements, create or modify attributes of the class.</p>
<p>Classes are typically organized around manipulating instance attributes, which are the name-value pairs associated with each instance of that class. The class specifies the instance attributes of its objects by defining a method for initializing new objects. For example, part of initializing an object of the <code>Account</code>class is to assign it a starting balance of 0.</p>
<p>The <code>` of a</code>class<code>statement contains</code>def<code>statements that define new methods for objects of that class. The method that initializes objects has a special name in Python,</code><strong>init</strong>` (two underscores on each side of the word “init”), and is called the <em>constructor</em> for the class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance &#x3D; 0</span><br><span class="line">            self.holder &#x3D; account_holder</span><br></pre></td></tr></table></figure>
<p>The <code>__init__</code> method for <code>Account</code> has two formal parameters. The first one, <code>self</code>, is bound to the newly created <code>Account</code> object. The second parameter, <code>account_holder</code>, is bound to the argument passed to the class when it is called to be instantiated.</p>
<p>The constructor binds the instance attribute name <code>balance</code> to 0. It also binds the attribute name <code>holder</code>to the value of the name <code>account_holder</code>. The formal parameter <code>account_holder</code> is a local name in the <code>__init__</code> method. On the other hand, the name <code>holder</code> that is bound via the final assignment statement persists, because it is stored as an attribute of <code>self</code> using dot notation.</p>
<p>Having defined the <code>Account</code> class, we can instantiate it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Account(&#39;Kirk&#39;)</span><br></pre></td></tr></table></figure>
<p>This “call” to the <code>Account</code> class creates a new object that is an instance of <code>Account</code>, then calls the constructor function <code>__init__</code> with two arguments: the newly created object and the string <code>&#39;Kirk&#39;</code>. By convention, we use the parameter name <code>self</code> for the first argument of a constructor, because it is bound to the object being instantiated. This convention is adopted in virtually all Python code.</p>
<p>Now, we can access the object’s <code>balance</code> and <code>holder</code> using dot notation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.balance</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a.holder</span><br><span class="line">&#39;Kirk&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Identity.</strong> Each new account instance has its own balance attribute, the value of which is independent of other objects of the same class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Account(&#39;Spock&#39;)</span><br><span class="line">&gt;&gt;&gt; b.balance &#x3D; 200</span><br><span class="line">&gt;&gt;&gt; [acc.balance for acc in (a, b)]</span><br><span class="line">[0, 200]</span><br></pre></td></tr></table></figure>
<p>To enforce this separation, every object that is an instance of a user-defined class has a unique identity. Object identity is compared using the <code>is</code> and <code>is not</code> operators.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a is a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is not b</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>Despite being constructed from identical calls, the objects bound to <code>a</code> and <code>b</code> are not the same. As usual, binding an object to a new name using assignment does not create a new object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c &#x3D; a</span><br><span class="line">&gt;&gt;&gt; c is a</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>New objects that have user-defined classes are only created when a class (such as <code>Account</code>) is instantiated with call expression syntax.</p>
<p><strong>Methods.</strong> Object methods are also defined by a <code>def</code> statement in the suite of a <code>class</code> statement. Below, <code>deposit</code> and <code>withdraw</code> are both defined as methods on objects of the <code>Account</code> class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance &#x3D; 0</span><br><span class="line">            self.holder &#x3D; account_holder</span><br><span class="line">        def deposit(self, amount):</span><br><span class="line">            self.balance &#x3D; self.balance + amount</span><br><span class="line">            return self.balance</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            if amount &gt; self.balance:</span><br><span class="line">                return &#39;Insufficient funds&#39;</span><br><span class="line">            self.balance &#x3D; self.balance - amount</span><br><span class="line">            return self.balance</span><br></pre></td></tr></table></figure>
<p>While method definitions do not differ from function definitions in how they are declared, method definitions do have a different effect when executed. The function value that is created by a <code>def</code>statement within a <code>class</code> statement is bound to the declared name, but bound locally within the class as an attribute. That value is invoked as a method using dot notation from an instance of the class.</p>
<p>Each method definition again includes a special first parameter <code>self</code>, which is bound to the object on which the method is invoked. For example, let us say that <code>deposit</code> is invoked on a particular <code>Account</code>object and passed a single argument value: the amount deposited. The object itself is bound to <code>self</code>, while the argument is bound to <code>amount</code>. All invoked methods have access to the object via the <code>self</code>parameter, and so they can all access and manipulate the object’s state.</p>
<p>To invoke these methods, we again use dot notation, as illustrated below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; spock_account &#x3D; Account(&#39;Spock&#39;)</span><br><span class="line">&gt;&gt;&gt; spock_account.deposit(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; spock_account.withdraw(90)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; spock_account.withdraw(90)</span><br><span class="line">&#39;Insufficient funds&#39;</span><br><span class="line">&gt;&gt;&gt; spock_account.holder</span><br><span class="line">&#39;Spock&#39;</span><br></pre></td></tr></table></figure>
<p>When a method is invoked via dot notation, the object itself (bound to <code>spock_account</code>, in this case) plays a dual role. First, it determines what the name <code>withdraw</code> means; <code>withdraw</code> is not a name in the environment, but instead a name that is local to the <code>Account</code> class. Second, it is bound to the first parameter <code>self</code> when the <code>withdraw</code> method is invoked.</p>
<h3 id="2-5-3-Message-Passing-and-Dot-Expressions"><a href="#2-5-3-Message-Passing-and-Dot-Expressions" class="headerlink" title="2.5.3  Message Passing and Dot Expressions"></a>2.5.3  Message Passing and Dot Expressions</h3><p>Methods, which are defined in classes, and instance attributes, which are typically assigned in constructors, are the fundamental elements of object-oriented programming. These two concepts replicate much of the behavior of a dispatch dictionary in a message passing implementation of a data value. Objects take messages using dot notation, but instead of those messages being arbitrary string-valued keys, they are names local to a class. Objects also have named local state values (the instance attributes), but that state can be accessed and manipulated using dot notation, without having to employ<code>nonlocal</code> statements in the implementation.</p>
<p>The central idea in message passing was that data values should have behavior by responding to messages that are relevant to the abstract type they represent. Dot notation is a syntactic feature of Python that formalizes the message passing metaphor. The advantage of using a language with a built-in object system is that message passing can interact seamlessly with other language features, such as assignment statements. We do not require different messages to “get” or “set” the value associated with a local attribute name; the language syntax allows us to use the message name directly.</p>
<p><strong>Dot expressions.</strong> The code fragment <code>spock_account.deposit</code> is called a <em>dot expression</em>. A dot expression consists of an expression, a dot, and a name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>The <code>can be any valid Python expression, but the</code> must be a simple name (not an expression that evaluates to a name). A dot expression evaluates to the value of the attribute with the given <code>, for the object that is the value of the</code>.</p>
<p>The built-in function <code>getattr</code> also returns an attribute for an object by name. It is the function equivalent of dot notation. Using <code>getattr</code>, we can look up an attribute using a string, just as we did with a dispatch dictionary.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#39;balance&#39;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>We can also test whether an object has a named attribute with <code>hasattr</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#39;deposit&#39;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>The attributes of an object include all of its instance attributes, along with all of the attributes (including methods) defined in its class. Methods are attributes of the class that require special handling.</p>
<p><strong>Methods and functions.</strong> When a method is invoked on an object, that object is implicitly passed as the first argument to the method. That is, the object that is the value of the <code>` to the left of the dot is passed automatically as the first argument to the method named on the right side of the dot expression. As a result, the object is bound to the parameter</code>self`.</p>
<p>To achieve automatic <code>self</code> binding, Python distinguishes between <em>functions</em>, which we have been creating since the beginning of the text, and <em>bound methods</em>, which couple together a function and the object on which that method will be invoked. A bound method value is already associated with its first argument, the instance on which it was invoked, which will be named <code>self</code> when the method is called.</p>
<p>We can see the difference in the interactive interpreter by calling <code>type</code> on the returned values of dot expressions. As an attribute of a class, a method is just a function, but as an attribute of an instance, it is a bound method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#39;function&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#39;method&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>These two results differ only in the fact that the first is a standard two-argument function with parameters <code>self</code> and <code>amount</code>. The second is a one-argument method, where the name <code>self</code> will be bound to the object named <code>spock_account</code> automatically when the method is called, while the parameter <code>amount</code> will be bound to the argument passed to the method. Both of these values, whether function values or bound method values, are associated with the same <code>deposit</code> function body.</p>
<p>We can call <code>deposit</code> in two ways: as a function and as a bound method. In the former case, we must supply an argument for the <code>self</code> parameter explicitly. In the latter case, the <code>self</code> parameter is bound automatically.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Account.deposit(spock_account, 1001)  # The deposit function takes 2 arguments</span><br><span class="line">1011</span><br><span class="line">&gt;&gt;&gt; spock_account.deposit(1000)           # The deposit method takes 1 argument</span><br><span class="line">2011</span><br></pre></td></tr></table></figure>
<p>The function <code>getattr</code> behaves exactly like dot notation: if its first argument is an object but the name is a method defined in the class, then <code>getattr</code> returns a bound method value. On the other hand, if the first argument is a class, then <code>getattr</code> returns the attribute value directly, which is a plain function.</p>
<p><strong>Naming Conventions.</strong> Class names are conventionally written using the CapWords convention (also called CamelCase because the capital letters in the middle of a name look like humps). Method names follow the standard convention of naming functions using lowercased words separated by underscores.</p>
<p>In some cases, there are instance variables and methods that are related to the maintenance and consistency of an object that we don’t want users of the object to see or use. They are not part of the abstraction defined by a class, but instead part of the implementation. Python’s convention dictates that if an attribute name starts with an underscore, it should only be accessed within methods of the class itself, rather than by users of the class.</p>
<h3 id="2-5-4-Class-Attributes"><a href="#2-5-4-Class-Attributes" class="headerlink" title="2.5.4  Class Attributes"></a>2.5.4  Class Attributes</h3><p>Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class. For instance, let us say that a bank pays interest on the balance of accounts at a fixed interest rate. That interest rate may change, but it is a single value shared across all accounts.</p>
<p>Class attributes are created by assignment statements in the suite of a <code>class</code> statement, outside of any method definition. In the broader developer community, class attributes may also be called class variables or static variables. The following class statement creates a class attribute for <code>Account</code> with the name <code>interest</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        interest &#x3D; 0.02            # A class attribute</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance &#x3D; 0</span><br><span class="line">            self.holder &#x3D; account_holder</span><br><span class="line">        # Additional methods would be defined here</span><br></pre></td></tr></table></figure>
<p>This attribute can still be accessed from any instance of the class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; spock_account &#x3D; Account(&#39;Spock&#39;)</span><br><span class="line">&gt;&gt;&gt; kirk_account &#x3D; Account(&#39;Kirk&#39;)</span><br><span class="line">&gt;&gt;&gt; spock_account.interest</span><br><span class="line">0.02</span><br><span class="line">&gt;&gt;&gt; kirk_account.interest</span><br><span class="line">0.02</span><br></pre></td></tr></table></figure>
<p>However, a single assignment statement to a class attribute changes the value of the attribute for all instances of the class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Account.interest &#x3D; 0.04</span><br><span class="line">&gt;&gt;&gt; spock_account.interest</span><br><span class="line">0.04</span><br><span class="line">&gt;&gt;&gt; kirk_account.interest</span><br><span class="line">0.04</span><br></pre></td></tr></table></figure>
<p><strong>Attribute names.</strong> We have introduced enough complexity into our object system that we have to specify how names are resolved to particular attributes. After all, we could easily have a class attribute and an instance attribute with the same name.</p>
<p>As we have seen, a dot expression consists of an expression, a dot, and a name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>To evaluate a dot expression:</p>
<ol>
<li>Evaluate the `` to the left of the dot, which yields the <em>object</em> of the dot expression.</li>
<li>`` is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned.</li>
<li>If <code>does not appear among instance attributes, then</code> is looked up in the class, which yields a class attribute value.</li>
<li>That value is returned unless it is a function, in which case a bound method is returned instead.</li>
</ol>
<p>In this evaluation procedure, instance attributes are found before class attributes, just as local names have priority over global in an environment. Methods defined within the class are combined with the object of the dot expression to form a bound method during the fourth step of this evaluation procedure. The procedure for looking up a name in a class has additional nuances that will arise shortly, once we introduce class inheritance.</p>
<p><strong>Attribute assignment.</strong> All assignment statements that contain a dot expression on their left-hand side affect attributes for the object of that dot expression. If the object is an instance, then assignment sets an instance attribute. If the object is a class, then assignment sets a class attribute. As a consequence of this rule, assignment to an attribute of an object cannot affect the attributes of its class. The examples below illustrate this distinction.</p>
<p>If we assign to the named attribute <code>interest</code> of an account instance, we create a new instance attribute that has the same name as the existing class attribute.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kirk_account.interest &#x3D; 0.08</span><br></pre></td></tr></table></figure>
<p>and that attribute value will be returned from a dot expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kirk_account.interest</span><br><span class="line">0.08</span><br></pre></td></tr></table></figure>
<p>However, the class attribute <code>interest</code> still retains its original value, which is returned for all other accounts.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; spock_account.interest</span><br><span class="line">0.04</span><br></pre></td></tr></table></figure>
<p>Changes to the class attribute <code>interest</code> will affect <code>spock_account</code>, but the instance attribute for <code>kirk_account</code> will be unaffected.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Account.interest &#x3D; 0.05  # changing the class attribute</span><br><span class="line">&gt;&gt;&gt; spock_account.interest     # changes instances without like-named instance attributes</span><br><span class="line">0.05</span><br><span class="line">&gt;&gt;&gt; kirk_account.interest     # but the existing instance attribute is unaffected</span><br><span class="line">0.08</span><br></pre></td></tr></table></figure>
<h3 id="2-5-5-Inheritance"><a href="#2-5-5-Inheritance" class="headerlink" title="2.5.5  Inheritance"></a>2.5.5  Inheritance</h3><p>When working in the object-oriented programming paradigm, we often find that different types are related. In particular, we find that similar classes differ in their amount of specialization. Two classes may have similar attributes, but one represents a special case of the other.</p>
<p>For example, we may want to implement a checking account, which is different from a standard account. A checking account charges an extra $1 for each withdrawal and has a lower interest rate. Here, we demonstrate the desired behavior.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ch &#x3D; CheckingAccount(&#39;Spock&#39;)</span><br><span class="line">&gt;&gt;&gt; ch.interest     # Lower interest rate for checking accounts</span><br><span class="line">0.01</span><br><span class="line">&gt;&gt;&gt; ch.deposit(20)  # Deposits are the same</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; ch.withdraw(5)  # withdrawals decrease balance by an extra charge</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>A <code>CheckingAccount</code> is a specialization of an <code>Account</code>. In OOP terminology, the generic account will serve as the base class of <code>CheckingAccount</code>, while <code>CheckingAccount</code> will be a subclass of <code>Account</code>. (The terms <em>parent class</em> and <em>superclass</em> are also used for the base class, while <em>child class</em> is also used for the subclass.)</p>
<p>A subclass <em>inherits</em> the attributes of its base class, but may <em>override</em> certain attributes, including certain methods. With inheritance, we only specify what is different between the subclass and the base class. Anything that we leave unspecified in the subclass is automatically assumed to behave just as it would for the base class.</p>
<p>Inheritance also has a role in our object metaphor, in addition to being a useful organizational feature. Inheritance is meant to represent <em>is-a</em> relationships between classes, which contrast with <em>has-a</em>relationships. A checking account <em>is-a</em> specific type of account, so having a <code>CheckingAccount</code> inherit from <code>Account</code> is an appropriate use of inheritance. On the other hand, a bank <em>has-a</em> list of bank accounts that it manages, so neither should inherit from the other. Instead, a list of account objects would be naturally expressed as an instance attribute of a bank object.</p>
<h3 id="2-5-6-Using-Inheritance"><a href="#2-5-6-Using-Inheritance" class="headerlink" title="2.5.6  Using Inheritance"></a>2.5.6  Using Inheritance</h3><p>First, we give a full implementation of the <code>Account</code> class, which includes docstrings for the class and its methods.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        &quot;&quot;&quot;A bank account that has a non-negative balance.&quot;&quot;&quot;</span><br><span class="line">        interest &#x3D; 0.02</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance &#x3D; 0</span><br><span class="line">            self.holder &#x3D; account_holder</span><br><span class="line">        def deposit(self, amount):</span><br><span class="line">            &quot;&quot;&quot;Increase the account balance by amount and return the new balance.&quot;&quot;&quot;</span><br><span class="line">            self.balance &#x3D; self.balance + amount</span><br><span class="line">            return self.balance</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            &quot;&quot;&quot;Decrease the account balance by amount and return the new balance.&quot;&quot;&quot;</span><br><span class="line">            if amount &gt; self.balance:</span><br><span class="line">                return &#39;Insufficient funds&#39;</span><br><span class="line">            self.balance &#x3D; self.balance - amount</span><br><span class="line">            return self.balance</span><br></pre></td></tr></table></figure>
<p>A full implementation of <code>CheckingAccount</code> appears below. We specify inheritance by placing an expression that evaluates to the base class in parentheses after the class name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class CheckingAccount(Account):</span><br><span class="line">        &quot;&quot;&quot;A bank account that charges for withdrawals.&quot;&quot;&quot;</span><br><span class="line">        withdraw_charge &#x3D; 1</span><br><span class="line">        interest &#x3D; 0.01</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            return Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></table></figure>
<p>Here, we introduce a class attribute <code>withdraw_charge</code> that is specific to the <code>CheckingAccount</code> class. We assign a lower value to the <code>interest</code> attribute. We also define a new <code>withdraw</code> method to override the behavior defined in the <code>Account</code> class. With no further statements in the class suite, all other behavior is inherited from the base class <code>Account</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; checking &#x3D; CheckingAccount(&#39;Sam&#39;)</span><br><span class="line">&gt;&gt;&gt; checking.deposit(10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; checking.withdraw(5)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; checking.interest</span><br><span class="line">0.01</span><br></pre></td></tr></table></figure>
<p>The expression <code>checking.deposit</code> evaluates to a bound method for making deposits, which was defined in the <code>Account</code> class. When Python resolves a name in a dot expression that is not an attribute of the instance, it looks up the name in the class. In fact, the act of “looking up” a name in a class tries to find that name in every base class in the inheritance chain for the original object’s class. We can define this procedure recursively. To look up a name in a class.</p>
<ol>
<li>If it names an attribute in the class, return the attribute value.</li>
<li>Otherwise, look up the name in the base class, if there is one.</li>
</ol>
<p>In the case of <code>deposit</code>, Python would have looked for the name first on the instance, and then in the <code>CheckingAccount</code> class. Finally, it would look in the <code>Account</code> class, where <code>deposit</code> is defined. According to our evaluation rule for dot expressions, since <code>deposit</code> is a function looked up in the class for the <code>checking</code> instance, the dot expression evaluates to a bound method value. That method is invoked with the argument 10, which calls the deposit method with <code>self</code> bound to the <code>checking</code> object and <code>amount</code>bound to 10.</p>
<p>The class of an object stays constant throughout. Even though the <code>deposit</code> method was found in the <code>Account</code> class, <code>deposit</code> is called with <code>self</code> bound to an instance of <code>CheckingAccount</code>, not of <code>Account</code>.</p>
<p><strong>Calling ancestors.</strong> Attributes that have been overridden are still accessible via class objects. For instance, we implemented the <code>withdraw</code> method of <code>CheckingAccount</code> by calling the <code>withdraw</code> method of <code>Account</code> with an argument that included the <code>withdraw_charge</code>.</p>
<p>Notice that we called <code>self.withdraw_charge</code> rather than the equivalent<code>CheckingAccount.withdraw_charge</code>. The benefit of the former over the latter is that a class that inherits from <code>CheckingAccount</code> might override the withdrawal charge. If that is the case, we would like our implementation of <code>withdraw</code> to find that new value instead of the old one.</p>
<p><strong>Interfaces.</strong> It is extremely common in object-oriented programs that different types of objects will share the same attribute names. An <em>object interface</em> is a collection of attributes and conditions on those attributes. For example, all accounts must have <code>deposit</code> and <code>withdraw</code> methods that take numerical arguments, as well as a <code>balance</code> attribute. The classes <code>Account</code> and <code>CheckingAccount</code> both implement this interface. Inheritance specifically promotes name sharing in this way. In some programming languages such as Java, interface implementations must be explicitly declared. In others such as Python, Ruby, and Go, any object with the appropriate names implements an interface.</p>
<p>The parts of your program that use objects (rather than implementing them) are most robust to future changes if they do not make assumptions about object types, but instead only about their attribute names. That is, they use the object abstraction, rather than assuming anything about its implementation.</p>
<p>For example, let us say that we run a lottery, and we wish to deposit $5 into each of a list of accounts. The following implementation does not assume anything about the types of those accounts, and therefore works equally well with any type of object that has a <code>deposit</code> method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deposit_all(winners, amount&#x3D;5):</span><br><span class="line">        for account in winners:</span><br><span class="line">            account.deposit(amount)</span><br></pre></td></tr></table></figure>
<p>The function <code>deposit_all</code> above assumes only that each <code>account</code> satisfies the account object abstraction, and so it will work with any other account classes that also implement this interface. Assuming a particular class of account would violate the abstraction barrier of the account object abstraction. For example, the following implementation will not necessarily work with new kinds of accounts:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deposit_all(winners, amount&#x3D;5):</span><br><span class="line">        for account in winners:</span><br><span class="line">            Account.deposit(account, amount)</span><br></pre></td></tr></table></figure>
<p>We will address this topic in more detail later in the chapter.</p>
<h3 id="2-5-7-Multiple-Inheritance"><a href="#2-5-7-Multiple-Inheritance" class="headerlink" title="2.5.7  Multiple Inheritance"></a>2.5.7  Multiple Inheritance</h3><p>Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called <em>multiple inheritance</em>.</p>
<p>Suppose that we have a <code>SavingsAccount</code> that inherits from <code>Account</code>, but charges customers a small fee every time they make a deposit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class SavingsAccount(Account):</span><br><span class="line">        deposit_charge &#x3D; 2</span><br><span class="line">        def deposit(self, amount):</span><br><span class="line">            return Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></table></figure>
<p>Then, a clever executive conceives of an <code>AsSeenOnTVAccount</code> account with the best features of both <code>CheckingAccount</code> and <code>SavingsAccount</code>: withdrawal fees, deposit fees, and a low interest rate. It’s both a checking and a savings account in one! “If we build it,” the executive reasons, “someone will sign up and pay all those fees. We’ll even give them a dollar.”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class AsSeenOnTVAccount(CheckingAccount, SavingsAccount):</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.holder &#x3D; account_holder</span><br><span class="line">            self.balance &#x3D; 1           # A free dollar!</span><br></pre></td></tr></table></figure>
<p>In fact, this implementation is complete. Both withdrawal and deposits will generate fees, using the function definitions in <code>CheckingAccount</code> and <code>SavingsAccount</code> respectively.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; such_a_deal &#x3D; AsSeenOnTVAccount(&quot;John&quot;)</span><br><span class="line">&gt;&gt;&gt; such_a_deal.balance</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; such_a_deal.deposit(20)            # $2 fee from SavingsAccount.deposit</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; such_a_deal.withdraw(5)            # $1 fee from CheckingAccount.withdraw</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>Non-ambiguous references are resolved correctly as expected:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; such_a_deal.deposit_charge</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; such_a_deal.withdraw_charge</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>But what about when the reference is ambiguous, such as the reference to the <code>withdraw</code> method that is defined in both <code>Account</code> and <code>CheckingAccount</code>? The figure below depicts an <em>inheritance graph</em> for the <code>AsSeenOnTVAccount</code> class. Each arrow points from a subclass to a base class.</p>
<p><img src="http://composingprograms.com/img/multiple_inheritance.png" alt="img"></p>
<p>For a simple “diamond” shape like this, Python resolves names from left to right, then upwards. In this example, Python checks for an attribute name in the following classes, in order, until an attribute with that name is found:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object</span><br></pre></td></tr></table></figure>
<p>There is no correct solution to the inheritance ordering problem, as there are cases in which we might prefer to give precedence to certain inherited classes over others. However, any programming language that supports multiple inheritance must select some ordering in a consistent way, so that users of the language can predict the behavior of their programs.</p>
<p><strong>Further reading.</strong> Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering. The method resolution order of any class can be queried using the <code>mro</code> method on all classes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [c.__name__ for c in AsSeenOnTVAccount.mro()]</span><br><span class="line">[&#39;AsSeenOnTVAccount&#39;, &#39;CheckingAccount&#39;, &#39;SavingsAccount&#39;, &#39;Account&#39;, &#39;object&#39;]</span><br></pre></td></tr></table></figure>
<p>The precise algorithm for finding method resolution orderings is not a topic for this text, but is <a href="http://python-history.blogspot.com/2010/06/method-resolution-order.html" target="_blank" rel="noopener">described by Python’s primary author</a> with a reference to the original paper.</p>
<h3 id="2-5-8-The-Role-of-Objects"><a href="#2-5-8-The-Role-of-Objects" class="headerlink" title="2.5.8  The Role of Objects"></a>2.5.8  The Role of Objects</h3><p>The Python object system is designed to make data abstraction and message passing both convenient and flexible. The specialized syntax of classes, methods, inheritance, and dot expressions all enable us to formalize the object metaphor in our programs, which improves our ability to organize large programs.</p>
<p>In particular, we would like our object system to promote a <em>separation of concerns</em> among the different aspects of the program. Each object in a program encapsulates and manages some part of the program’s state, and each class statement defines the functions that implement some part of the program’s overall logic. Abstraction barriers enforce the boundaries between different aspects of a large program.</p>
<p>Object-oriented programming is particularly well-suited to programs that model systems that have separate but interacting parts. For instance, different users interact in a social network, different characters interact in a game, and different shapes interact in a physical simulation. When representing such systems, the objects in a program often map naturally onto objects in the system being modeled, and classes represent their types and relationships.</p>
<p>On the other hand, classes may not provide the best mechanism for implementing certain abstractions. Functional abstractions provide a more natural metaphor for representing relationships between inputs and outputs. One should not feel compelled to fit every bit of logic in a program within a class, especially when defining independent functions for manipulating data is more natural. Functions can also enforce a separation of concerns.</p>
<p>Multi-paradigm languages such as Python allow programmers to match organizational paradigms to appropriate problems. Learning to identify when to introduce a new class, as opposed to a new function, in order to simplify or modularize a program, is an important design skill in software engineering that deserves careful attention.</p>
<h2 id="2-6-Implementing-Classes-and-Objects"><a href="#2-6-Implementing-Classes-and-Objects" class="headerlink" title="2.6  Implementing Classes and Objects"></a>2.6  Implementing Classes and Objects</h2><p>When working in the object-oriented programming paradigm, we use the object metaphor to guide the organization of our programs. Most logic about how to represent and manipulate data is expressed within class declarations. In this section, we see that classes and objects can themselves be represented using just functions and dictionaries. The purpose of implementing an object system in this way is to illustrate that using the object metaphor does not require a special programming language. Programs can be object-oriented, even in programming languages that do not have a built-in object system.</p>
<p>In order to implement objects, we will abandon dot notation (which does require built-in language support), but create dispatch dictionaries that behave in much the same way as the elements of the built-in object system. We have already seen how to implement message-passing behavior through dispatch dictionaries. To implement an object system in full, we send messages between instances, classes, and base classes, all of which are dictionaries that contain attributes.</p>
<p>We will not implement the entire Python object system, which includes features that we have not covered in this text (e.g., meta-classes and static methods). We will focus instead on user-defined classes without multiple inheritance and without introspective behavior (such as returning the class of an instance). Our implementation is not meant to follow the precise specification of the Python type system. Instead, it is designed to implement the core functionality that enables the object metaphor.</p>
<h3 id="2-6-1-Instances"><a href="#2-6-1-Instances" class="headerlink" title="2.6.1  Instances"></a>2.6.1  Instances</h3><p>We begin with instances. An instance has named attributes, such as the balance of an account, which can be set and retrieved. We implement an instance using a dispatch dictionary that responds to messages that “get” and “set” attribute values. Attributes themselves are stored in a local dictionary called <code>attributes</code>.</p>
<p>As we have seen previously in this chapter, dictionaries themselves are abstract data types. We implemented dictionaries with lists, we implemented lists with pairs, and we implemented pairs with functions. As we implement an object system in terms of dictionaries, keep in mind that we could just as well be implementing objects using functions alone.</p>
<p>To begin our implementation, we assume that we have a class implementation that can look up any names that are not part of the instance. We pass in a class to <code>make_instance</code> as the parameter <code>cls</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_instance(cls):</span><br><span class="line">        &quot;&quot;&quot;Return a new object instance, which is a dispatch dictionary.&quot;&quot;&quot;</span><br><span class="line">        def get_value(name):</span><br><span class="line">            if name in attributes:</span><br><span class="line">                return attributes[name]</span><br><span class="line">            else:</span><br><span class="line">                value &#x3D; cls[&#39;get&#39;](name)</span><br><span class="line">                return bind_method(value, instance)</span><br><span class="line">        def set_value(name, value):</span><br><span class="line">            attributes[name] &#x3D; value</span><br><span class="line">        attributes &#x3D; &#123;&#125;</span><br><span class="line">        instance &#x3D; &#123;&#39;get&#39;: get_value, &#39;set&#39;: set_value&#125;</span><br><span class="line">        return instance</span><br></pre></td></tr></table></figure>
<p>The <code>instance</code> is a dispatch dictionary that responds to the messages <code>get</code> and <code>set</code>. The <code>set</code> message corresponds to attribute assignment in Python’s object system: all assigned attributes are stored directly within the object’s local attribute dictionary. In <code>get</code>, if <code>name</code> does not appear in the local <code>attributes</code>dictionary, then it is looked up in the class. If the <code>value</code> returned by <code>cls</code> is a function, it must be bound to the instance.</p>
<p><strong>Bound method values.</strong> The <code>get_value</code> function in <code>make_instance</code> finds a named attribute in its class with <code>get</code>, then calls <code>bind_method</code>. Binding a method only applies to function values, and it creates a bound method value from a function value by inserting the instance as the first argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def bind_method(value, instance):</span><br><span class="line">        &quot;&quot;&quot;Return a bound method if value is callable, or value otherwise.&quot;&quot;&quot;</span><br><span class="line">        if callable(value):</span><br><span class="line">            def method(*args):</span><br><span class="line">                return value(instance, *args)</span><br><span class="line">            return method</span><br><span class="line">        else:</span><br><span class="line">            return value</span><br></pre></td></tr></table></figure>
<p>When a method is called, the first parameter <code>self</code> will be bound to the value of <code>instance</code> by this definition.</p>
<h3 id="2-6-2-Classes"><a href="#2-6-2-Classes" class="headerlink" title="2.6.2  Classes"></a>2.6.2  Classes</h3><p>A class is also an object, both in Python’s object system and the system we are implementing here. For simplicity, we say that classes do not themselves have a class. (In Python, classes do have classes; almost all classes share the same class, called <code>type</code>.) A class can respond to <code>get</code> and <code>set</code> messages, as well as the <code>new</code> message:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_class(attributes, base_class&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;Return a new class, which is a dispatch dictionary.&quot;&quot;&quot;</span><br><span class="line">        def get_value(name):</span><br><span class="line">            if name in attributes:</span><br><span class="line">                return attributes[name]</span><br><span class="line">            elif base_class is not None:</span><br><span class="line">                return base_class[&#39;get&#39;](name)</span><br><span class="line">        def set_value(name, value):</span><br><span class="line">            attributes[name] &#x3D; value</span><br><span class="line">        def new(*args):</span><br><span class="line">            return init_instance(cls, *args)</span><br><span class="line">        cls &#x3D; &#123;&#39;get&#39;: get_value, &#39;set&#39;: set_value, &#39;new&#39;: new&#125;</span><br><span class="line">        return cls</span><br></pre></td></tr></table></figure>
<p>Unlike an instance, the <code>get</code> function for classes does not query its class when an attribute is not found, but instead queries its <code>base_class</code>. No method binding is required for classes.</p>
<p><strong>Initialization.</strong> The <code>new</code> function in <code>make_class</code> calls <code>init_instance</code>, which first makes a new instance, then invokes a method called <code>__init__</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def init_instance(cls, *args):</span><br><span class="line">        &quot;&quot;&quot;Return a new object with type cls, initialized with args.&quot;&quot;&quot;</span><br><span class="line">        instance &#x3D; make_instance(cls)</span><br><span class="line">        init &#x3D; cls[&#39;get&#39;](&#39;__init__&#39;)</span><br><span class="line">        if init:</span><br><span class="line">            init(instance, *args)</span><br><span class="line">        return instance</span><br></pre></td></tr></table></figure>
<p>This final function completes our object system. We now have instances, which <code>set</code> locally but fall back to their classes on <code>get</code>. After an instance looks up a name in its class, it binds itself to function values to create methods. Finally, classes can create <code>new</code> instances, and they apply their <code>__init__</code> constructor function immediately after instance creation.</p>
<p>In this object system, the only function that should be called by the user is <code>make_class</code>. All other functionality is enabled through message passing. Similarly, Python’s object system is invoked via the <code>class</code> statement, and all of its other functionality is enabled through dot expressions and calls to classes.</p>
<h3 id="2-6-3-Using-Implemented-Objects"><a href="#2-6-3-Using-Implemented-Objects" class="headerlink" title="2.6.3  Using Implemented Objects"></a>2.6.3  Using Implemented Objects</h3><p>We now return to use the bank account example from the previous section. Using our implemented object system, we will create an <code>Account</code> class, a <code>CheckingAccount</code> subclass, and an instance of each.</p>
<p>The <code>Account</code> class is created through a <code>make_account_class</code> function, which has structure similar to a <code>class</code> statement in Python, but concludes with a call to <code>make_class</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_account_class():</span><br><span class="line">        &quot;&quot;&quot;Return the Account class, which has deposit and withdraw methods.&quot;&quot;&quot;</span><br><span class="line">        interest &#x3D; 0.02</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self[&#39;set&#39;](&#39;holder&#39;, account_holder)</span><br><span class="line">            self[&#39;set&#39;](&#39;balance&#39;, 0)</span><br><span class="line">        def deposit(self, amount):</span><br><span class="line">            &quot;&quot;&quot;Increase the account balance by amount and return the new balance.&quot;&quot;&quot;</span><br><span class="line">            new_balance &#x3D; self[&#39;get&#39;](&#39;balance&#39;) + amount</span><br><span class="line">            self[&#39;set&#39;](&#39;balance&#39;, new_balance)</span><br><span class="line">            return self[&#39;get&#39;](&#39;balance&#39;)</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            &quot;&quot;&quot;Decrease the account balance by amount and return the new balance.&quot;&quot;&quot;</span><br><span class="line">            balance &#x3D; self[&#39;get&#39;](&#39;balance&#39;)</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#39;Insufficient funds&#39;</span><br><span class="line">            self[&#39;set&#39;](&#39;balance&#39;, balance - amount)</span><br><span class="line">            return self[&#39;get&#39;](&#39;balance&#39;)</span><br><span class="line">        return make_class(locals())</span><br></pre></td></tr></table></figure>
<p>The final call to <code>locals</code> returns a dictionary with string keys that contains the name-value bindings in the current local frame.</p>
<p>The <code>Account</code> class is finally instantiated via assignment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Account &#x3D; make_account_class()</span><br></pre></td></tr></table></figure>
<p>Then, an account instance is created via the <code>new</code> message, which requires a name to go with the newly created account.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kirk_account &#x3D; Account[&#39;new&#39;](&#39;Kirk&#39;)</span><br></pre></td></tr></table></figure>
<p>Then, <code>get</code> messages passed to <code>kirk_account</code> retrieve properties and methods. Methods can be called to update the balance of the account.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kirk_account[&#39;get&#39;](&#39;holder&#39;)</span><br><span class="line">&#39;Kirk&#39;</span><br><span class="line">&gt;&gt;&gt; kirk_account[&#39;get&#39;](&#39;interest&#39;)</span><br><span class="line">0.02</span><br><span class="line">&gt;&gt;&gt; kirk_account[&#39;get&#39;](&#39;deposit&#39;)(20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; kirk_account[&#39;get&#39;](&#39;withdraw&#39;)(5)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>As with the Python object system, setting an attribute of an instance does not change the corresponding attribute of its class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kirk_account[&#39;set&#39;](&#39;interest&#39;, 0.04)</span><br><span class="line">&gt;&gt;&gt; Account[&#39;get&#39;](&#39;interest&#39;)</span><br><span class="line">0.02</span><br></pre></td></tr></table></figure>
<p><strong>Inheritance.</strong> We can create a subclass <code>CheckingAccount</code> by overloading a subset of the class attributes. In this case, we change the <code>withdraw</code> method to impose a fee, and we reduce the interest rate.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_checking_account_class():</span><br><span class="line">        &quot;&quot;&quot;Return the CheckingAccount class, which imposes a $1 withdrawal fee.&quot;&quot;&quot;</span><br><span class="line">        interest &#x3D; 0.01</span><br><span class="line">        withdraw_fee &#x3D; 1</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            fee &#x3D; self[&#39;get&#39;](&#39;withdraw_fee&#39;)</span><br><span class="line">            return Account[&#39;get&#39;](&#39;withdraw&#39;)(self, amount + fee)</span><br><span class="line">        return make_class(locals(), Account)</span><br></pre></td></tr></table></figure>
<p>In this implementation, we call the <code>withdraw</code> function of the base class <code>Account</code> from the <code>withdraw</code>function of the subclass, as we would in Python’s built-in object system. We can create the subclass itself and an instance, as before.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; CheckingAccount &#x3D; make_checking_account_class()</span><br><span class="line">&gt;&gt;&gt; jack_acct &#x3D; CheckingAccount[&#39;new&#39;](&#39;Spock&#39;)</span><br></pre></td></tr></table></figure>
<p>Deposits behave identically, as does the constructor function. withdrawals impose the $1 fee from the specialized <code>withdraw</code> method, and <code>interest</code> has the new lower value from <code>CheckingAccount</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; jack_acct[&#39;get&#39;](&#39;interest&#39;)</span><br><span class="line">0.01</span><br><span class="line">&gt;&gt;&gt; jack_acct[&#39;get&#39;](&#39;deposit&#39;)(20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; jack_acct[&#39;get&#39;](&#39;withdraw&#39;)(5)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>Our object system built upon dictionaries is quite similar in implementation to the built-in object system in Python. In Python, an instance of any user-defined class has a special attribute <code>__dict__</code> that stores the local instance attributes for that object in a dictionary, much like our <code>attributes</code> dictionary. Python differs because it distinguishes certain special methods that interact with built-in functions to ensure that those functions behave correctly for arguments of many different types. Functions that operate on different types are the subject of the next section.</p>
<h2 id="2-7-Object-Abstraction"><a href="#2-7-Object-Abstraction" class="headerlink" title="2.7  Object Abstraction"></a>2.7  Object Abstraction</h2><p>The object system allows programmers to build and use abstract data representations efficiently. It is also designed to allow multiple representations of abstract data to coexist in the same program.</p>
<p>A central concept in object abstraction is a <em>generic function</em>, which is a function that can accept values of multiple different types. We will consider three different techniques for implementing generic functions: shared interfaces, type dispatching, and type coercion. In the process of building up these concepts, we will also discover features of the Python object system that support the creation of generic functions.</p>
<h3 id="2-7-1-String-Conversion"><a href="#2-7-1-String-Conversion" class="headerlink" title="2.7.1  String Conversion"></a>2.7.1  String Conversion</h3><p>To represent data effectively, an object value should behave like the kind of data it is meant to represent, including producing a string representation of itself. String representations of data values are especially important in an interactive language such as Python that automatically displays the string representation of the values of expressions in an interactive session.</p>
<p>String values provide a fundamental medium for communicating information among humans. Sequences of characters can be rendered on a screen, printed to paper, read aloud, converted to braille, or broadcast as Morse code. Strings are also fundamental to programming because they can represent Python expressions.</p>
<p>Python stipulates that all objects should produce two different string representations: one that is human-interpretable text and one that is a Python-interpretable expression. The constructor function for strings,<code>str</code>, returns a human-readable string. Where possible, the <code>repr</code> function returns a Python expression that evaluates to an equal object. The docstring for <em>repr</em> explains this property:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repr(object) -&gt; string</span><br><span class="line"></span><br><span class="line">Return the canonical string representation of the object.</span><br><span class="line">For most object types, eval(repr(object)) &#x3D;&#x3D; object.</span><br></pre></td></tr></table></figure>
<p>The result of calling <code>repr</code> on the value of an expression is what Python prints in an interactive session.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 12e12</span><br><span class="line">12000000000000.0</span><br><span class="line">&gt;&gt;&gt; print(repr(12e12))</span><br><span class="line">12000000000000.0</span><br></pre></td></tr></table></figure>
<p>In cases where no representation exists that evaluates to the original value, Python typically produces a description surrounded by angled brackets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; repr(min)</span><br><span class="line">&#39;&lt;built-in function min&gt;&#39;</span><br></pre></td></tr></table></figure>
<p>The <code>str</code> constructor often coincides with <code>repr</code>, but provides a more interpretable text representation in some cases. For instance, we see a difference between <code>str</code> and <code>repr</code> with dates.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; tues &#x3D; date(2011, 9, 12)</span><br><span class="line">&gt;&gt;&gt; repr(tues)</span><br><span class="line">&#39;datetime.date(2011, 9, 12)&#39;</span><br><span class="line">&gt;&gt;&gt; str(tues)</span><br><span class="line">&#39;2011-09-12&#39;</span><br></pre></td></tr></table></figure>
<p>Defining the <code>repr</code> function presents a new challenge: we would like it to apply correctly to all data types, even those that did not exist when <code>repr</code> was implemented. We would like it to be a generic or <em>polymorphic function</em>, one that can be applied to many (<em>poly</em>) different forms (<em>morph</em>) of data.</p>
<p>The object system provides an elegant solution in this case: the <code>repr</code> function always invokes a method called <code>__repr__</code> on its argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tues.__repr__()</span><br><span class="line">&#39;datetime.date(2011, 9, 12)&#39;</span><br></pre></td></tr></table></figure>
<p>By implementing this same method in user-defined classes, we can extend the applicability of <code>repr</code> to any class we create in the future. This example highlights another benefit of dot expressions in general, that they provide a mechanism for extending the domain of existing functions to new object types.</p>
<p>The <code>str</code> constructor is implemented in a similar manner: it invokes a method called <code>__str__</code> on its argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tues.__str__()</span><br><span class="line">&#39;2011-09-12&#39;</span><br></pre></td></tr></table></figure>
<p>These polymorphic functions are examples of a more general principle: certain functions should apply to multiple data types. Moreover, one way to create such a function is to use a shared attribute name with a different definition in each class.</p>
<h3 id="2-7-2-Special-Methods"><a href="#2-7-2-Special-Methods" class="headerlink" title="2.7.2  Special Methods"></a>2.7.2  Special Methods</h3><p>In Python, certain <em>special names</em> are invoked by the Python interpreter in special circumstances. For instance, the <code>__init__</code> method of a class is automatically invoked whenever an object is constructed. The <code>__str__</code> method is invoked automatically when printing, and <code>__repr__</code> is invoked in an interactive session to display values.</p>
<p>There are special names for many other behaviors in Python. Some of those used most commonly are described below.</p>
<p><strong>True and false values.</strong> We saw previously that numbers in Python have a truth value; more specifically, 0 is a false value and all other numbers are true values. In fact, all objects in Python have a truth value. By default, objects of user-defined classes are considered to be true, but the special <code>__bool__</code> method can be used to override this behavior. If an object defines the <code>__bool__</code> method, then Python calls that method to determine its truth value.</p>
<p>As an example, suppose we want a bank account with 0 balance to be false. We can add a <code>__bool__</code>method to the <code>Account</code> class to create this behavior.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Account.__bool__ &#x3D; lambda self: self.balance !&#x3D; 0</span><br></pre></td></tr></table></figure>
<p>We can call the <code>bool</code> constructor to see the truth value of an object, and we can use any object in a boolean context.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bool(Account(&#39;Jack&#39;))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; if not Account(&#39;Jack&#39;):</span><br><span class="line">        print(&#39;Jack has nothing&#39;)</span><br><span class="line">Jack has nothing</span><br></pre></td></tr></table></figure>
<p><strong>Sequence operations.</strong> We have seen that we can call the <code>len</code> function to determine the length of a sequence.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#39;Go Bears!&#39;)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>The <code>len</code> function invokes the <code>__len__</code> method of its argument to determine its length. All built-in sequence types implement this method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Go Bears!&#39;.__len__()</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>Python uses a sequence’s length to determine its truth value, if it does not provide a <code>__bool__</code> method. Empty sequences are false, while non-empty sequences are true.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bool(&#39;&#39;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; bool([])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; bool(&#39;Go Bears!&#39;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>The <code>__getitem__</code> method is invoked by the element selection operator, but it can also be invoked directly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Go Bears!&#39;[3]</span><br><span class="line">&#39;B&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;Go Bears!&#39;.__getitem__(3)</span><br><span class="line">&#39;B&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Callable objects.</strong> In Python, functions are first-class objects, so they can be passed around as data and have attributes like any other object. Python also allows us to define objects that can be “called” like functions by including a <code>__call__</code> method. With this method, we can define a class that behaves like a higher-order function.</p>
<p>As an example, consider the following higher-order function, which returns a function that adds a constant value to its argument.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_adder(n):</span><br><span class="line">        def adder(k):</span><br><span class="line">            return n + k</span><br><span class="line">        return adder</span><br><span class="line">&gt;&gt;&gt; add_three &#x3D; make_adder(3)</span><br><span class="line">&gt;&gt;&gt; add_three(4)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>We can create an <code>Adder</code> class that defines a <code>__call__</code> method to provide the same functionality.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Adder(object):</span><br><span class="line">        def __init__(self, n):</span><br><span class="line">            self.n &#x3D; n</span><br><span class="line">        def __call__(self, k):</span><br><span class="line">            return self.n + k</span><br><span class="line">&gt;&gt;&gt; add_three_obj &#x3D; Adder(3)</span><br><span class="line">&gt;&gt;&gt; add_three_obj(4)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>Here, the <code>Adder</code> class behaves like the <code>make_adder</code> higher-order function, and the <code>add_three_obj</code> object behaves like the <code>add_three</code> function. We have further blurred the line between data and functions.</p>
<p><strong>Arithmetic.</strong> Special methods can also define the behavior of built-in operators applied to user-defined objects. In order to provide this generality, Python follows specific protocols to apply each operator. For example, to evaluate expressions that contain the <code>+</code> operator, Python checks for special methods on both the left and right operands of the expression. First, Python checks for an <code>__add__</code> method on the value of the left operand, then checks for an <code>__radd__</code> method on the value of the right operand. If either is found, that method is invoked with the value of the other operand as its argument. Some examples are given in the following sections. For readers interested in further details, the Python documentation describes the exhaustive set of <a href="http://docs.python.org/py3k/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">method names for operators</a>. Dive into Python 3 has a chapter on <a href="http://getpython3.com/diveintopython3/special-method-names.html" target="_blank" rel="noopener">special method names</a> that describes how many of these special method names are used.</p>
<h3 id="2-7-3-Multiple-Representations"><a href="#2-7-3-Multiple-Representations" class="headerlink" title="2.7.3  Multiple Representations"></a>2.7.3  Multiple Representations</h3><p>Abstraction barriers allow us to separate the use and representation of data. However, in large programs, it may not always make sense to speak of “the underlying representation” for a data type in a program. For one thing, there might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations.</p>
<p>To take a simple example, complex numbers may be represented in two almost equivalent ways: in rectangular form (real and imaginary parts) and in polar form (magnitude and angle). Sometimes the rectangular form is more appropriate and sometimes the polar form is more appropriate. Indeed, it is perfectly plausible to imagine a system in which complex numbers are represented in both ways, and in which the functions for manipulating complex numbers work with either representation. We implement such a system below. As a side note, we are developing a system that performs arithmetic operations on complex numbers as a simple but unrealistic example of a program that uses generic operations. A<a href="http://docs.python.org/py3k/library/stdtypes.html#typesnumeric" target="_blank" rel="noopener">complex number type</a> is actually built into Python, but for this example we will implement our own.</p>
<p>The idea of allowing for multiple representations of data arises regularly. Large software systems are often designed by many people working over extended periods of time, subject to requirements that change over time. In such an environment, it is simply not possible for everyone to agree in advance on choices of data representation. In addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program.</p>
<p>We will begin our implementation at the highest level of abstraction and work towards concrete representations. A <code>Complex</code> number is a <code>Number</code>, and numbers can be added or multiplied together. How numbers can be added or multiplied is abstracted by the method names <code>add</code> and <code>mul</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Number:</span><br><span class="line">        def __add__(self, other):</span><br><span class="line">            return self.add(other)</span><br><span class="line">        def __mul__(self, other):</span><br><span class="line">            return self.mul(other)</span><br></pre></td></tr></table></figure>
<p>This class requires that Number objects have <code>add</code> and <code>mul</code> methods, but does not define them. Moreover, it does not have an <code>__init__</code> method. The purpose of <code>Number</code> is not to be instantiated directly, but instead to serve as a superclass of various specific number classes. Our next task is to define <code>add</code> and <code>mul</code> appropriately for complex numbers.</p>
<p>A complex number can be thought of as a point in two-dimensional space with two orthogonal axes, the real axis and the imaginary axis. From this perspective, the complex number <code>c = real + imag * i</code>(where <code>i * i = -1</code>) can be thought of as the point in the plane whose horizontal coordinate is <code>real</code> and whose vertical coordinate is <code>imag</code>. Adding complex numbers involves adding their respective <code>real</code> and <code>imag</code> coordinates.</p>
<p>When multiplying complex numbers, it is more natural to think in terms of representing a complex number in polar form, as a <code>magnitude</code> and an <code>angle</code>. The product of two complex numbers is the vector obtained by stretching one complex number by a factor of the length of the other, and then rotating it through the angle of the other.</p>
<p>The <code>Complex</code> class inherits from <code>Number</code> and describes arithmetic for complex numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Complex(Number):</span><br><span class="line">        def add(self, other):</span><br><span class="line">            return ComplexRI(self.real + other.real, self.imag + other.imag)</span><br><span class="line">        def mul(self, other):</span><br><span class="line">            magnitude &#x3D; self.magnitude * other.magnitude</span><br><span class="line">            return ComplexMA(magnitude, self.angle + other.angle)</span><br></pre></td></tr></table></figure>
<p>This implementation assumes that two classes exist for complex numbers, corresponding to their two natural representations:</p>
<ul>
<li><code>ComplexRI</code> constructs a complex number from real and imaginary parts.</li>
<li><code>ComplexMA</code> constructs a complex number from a magnitude and angle.</li>
</ul>
<p><strong>Interfaces.</strong> Object attributes, which are a form of message passing, allows different data types to respond to the same message in different ways. A shared set of messages that elicit similar behavior from different classes is a powerful method of abstraction. An <em>interface</em> is a set of shared attribute names, along with a specification of their behavior. In the case of complex numbers, the interface needed to implement arithmetic consists of four attributes: <code>real</code>, <code>imag</code>, <code>magnitude</code>, and <code>angle</code>.</p>
<p>For complex arithmetic to be correct, these attributes must be consistent. That is, the rectangular coordinates <code>(real, imag)</code> and the polar coordinates <code>(magnitude, angle)</code> must describe the same point on the complex plane. The <code>Complex</code> class implicitly defines this interface by determining how these attributes are used to <code>add</code> and <code>mul</code> complex numbers.</p>
<p><strong>Properties.</strong> The requirement that two or more attribute values maintain a fixed relationship with each other is a new problem. One solution is to store attribute values for only one representation and compute the other representation whenever it is needed.</p>
<p>Python has a simple feature for computing attributes on the fly from zero-argument functions. The <code>@property</code> decorator allows functions to be called without call expression syntax (parentheses following an expression). The <code>ComplexRI</code> class stores <code>real</code> and <code>imag</code> attributes and computes <code>magnitude</code> and <code>angle</code>on demand.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import atan2</span><br><span class="line">&gt;&gt;&gt; class ComplexRI(Complex):</span><br><span class="line">        def __init__(self, real, imag):</span><br><span class="line">            self.real &#x3D; real</span><br><span class="line">            self.imag &#x3D; imag</span><br><span class="line">        @property</span><br><span class="line">        def magnitude(self):</span><br><span class="line">            return (self.real ** 2 + self.imag ** 2) ** 0.5</span><br><span class="line">        @property</span><br><span class="line">        def angle(self):</span><br><span class="line">            return atan2(self.imag, self.real)</span><br><span class="line">        def __repr__(self):</span><br><span class="line">            return &#39;ComplexRI(&#123;0:g&#125;, &#123;1:g&#125;)&#39;.format(self.real, self.imag)</span><br></pre></td></tr></table></figure>
<p>As a result of this implementation, all four attributes needed for complex arithmetic can be accessed without any call expressions, and changes to <code>real</code> or <code>imag</code> are reflected in the <code>magnitude</code> and <code>angle</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ri &#x3D; ComplexRI(5, 12)</span><br><span class="line">&gt;&gt;&gt; ri.real</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; ri.magnitude</span><br><span class="line">13.0</span><br><span class="line">&gt;&gt;&gt; ri.real &#x3D; 9</span><br><span class="line">&gt;&gt;&gt; ri.real</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; ri.magnitude</span><br><span class="line">15.0</span><br></pre></td></tr></table></figure>
<p>Similarly, the <code>ComplexMA</code> class stores <code>magnitude</code> and <code>angle</code>, but computes <code>real</code> and <code>imag</code> whenever those attributes are looked up.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import sin, cos, pi</span><br><span class="line">&gt;&gt;&gt; class ComplexMA(Complex):</span><br><span class="line">        def __init__(self, magnitude, angle):</span><br><span class="line">            self.magnitude &#x3D; magnitude</span><br><span class="line">            self.angle &#x3D; angle</span><br><span class="line">        @property</span><br><span class="line">        def real(self):</span><br><span class="line">            return self.magnitude * cos(self.angle)</span><br><span class="line">        @property</span><br><span class="line">        def imag(self):</span><br><span class="line">            return self.magnitude * sin(self.angle)</span><br><span class="line">        def __repr__(self):</span><br><span class="line">            return &#39;ComplexMA(&#123;0:g&#125;, &#123;1:g&#125; * pi)&#39;.format(self.magnitude, self.angle&#x2F;pi)</span><br></pre></td></tr></table></figure>
<p>Changes to the magnitude or angle are reflected immediately in the <code>real</code> and <code>imag</code> attributes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ma &#x3D; ComplexMA(2, pi&#x2F;2)</span><br><span class="line">&gt;&gt;&gt; ma.imag</span><br><span class="line">2.0</span><br><span class="line">&gt;&gt;&gt; ma.angle &#x3D; pi</span><br><span class="line">&gt;&gt;&gt; ma.real</span><br><span class="line">-2.0</span><br></pre></td></tr></table></figure>
<p>Our implementation of complex numbers is now complete. Either class implementing complex numbers can be used for either argument in either arithmetic function in <code>Complex</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import pi</span><br><span class="line">&gt;&gt;&gt; ComplexRI(1, 2) + ComplexMA(2, pi&#x2F;2)</span><br><span class="line">ComplexRI(1, 4)</span><br><span class="line">&gt;&gt;&gt; ComplexRI(0, 1) * ComplexRI(0, 1)</span><br><span class="line">ComplexMA(1, 1 * pi)</span><br></pre></td></tr></table></figure>
<p>The interface approach to encoding multiple representations has appealing properties. The class for each representation can be developed separately; they must only agree on the names of the attributes they share, as well as any behavior conditions for those attributes. The interface is also <em>additive</em>. If another programmer wanted to add a third representation of complex numbers to the same program, they would only have to create another class with the same attributes.</p>
<p>Multiple representations of data are closely related to the idea of data abstraction with which we began this chapter. Using data abstraction, we were able to change the implementation of a data type without changing the meaning of the program. With interfaces and message passing, we can have multiple different representations within the same program. In both cases, a set of names and corresponding behavior conditions define the abstraction that enables this flexibility.</p>
<h3 id="2-7-4-Generic-Functions"><a href="#2-7-4-Generic-Functions" class="headerlink" title="2.7.4  Generic Functions"></a>2.7.4  Generic Functions</h3><p>Generic functions are methods or functions that apply to arguments of different types. We have seen many examples already. The <code>Complex.add</code> method is generic, because it can take either a <code>ComplexRI</code> or <code>ComplexMA</code> as the value for <code>other</code>. This flexibility was gained by ensuring that both <code>ComplexRI</code> and <code>ComplexMA</code> share an interface. Using interfaces and message passing is only one of several methods used to implement generic functions. We will consider two others in this section: type dispatching and type coercion.</p>
<p>Suppose that, in addition to our complex number classes, we implement a <code>Rational</code> class to represent fractions exactly. The <code>add</code> and <code>mul</code> methods express the same computations as the <code>add_rational</code> and<code>mul_rational</code> functions from earlier in the chapter.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from fractions import gcd</span><br><span class="line">&gt;&gt;&gt; class Rational(Number):</span><br><span class="line">        def __init__(self, numer, denom):</span><br><span class="line">            g &#x3D; gcd(numer, denom)</span><br><span class="line">            self.numer &#x3D; numer &#x2F;&#x2F; g</span><br><span class="line">            self.denom &#x3D; denom &#x2F;&#x2F; g</span><br><span class="line">        def __repr__(self):</span><br><span class="line">            return &#39;Rational(&#123;0&#125;, &#123;1&#125;)&#39;.format(self.numer, self.denom)</span><br><span class="line">        def add(self, other):</span><br><span class="line">            nx, dx &#x3D; self.numer, self.denom</span><br><span class="line">            ny, dy &#x3D; other.numer, other.denom</span><br><span class="line">            return Rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line">        def mul(self, other):</span><br><span class="line">            numer &#x3D; self.numer * other.numer</span><br><span class="line">            denom &#x3D; self.denom * other.denom</span><br><span class="line">            return Rational(numer, denom)</span><br></pre></td></tr></table></figure>
<p>We have implemented the interface of the <code>Number</code> superclass by including <code>add</code> and <code>mul</code> methods. As a result, we can add and multiply rational numbers using familiar operators.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Rational(2, 5) + Rational(1, 10)</span><br><span class="line">Rational(1, 2)</span><br><span class="line">&gt;&gt;&gt; Rational(1, 4) * Rational(2, 3)</span><br><span class="line">Rational(1, 6)</span><br></pre></td></tr></table></figure>
<p>However, we cannot yet add a rational number to a complex number, although in mathematics such a combination is well-defined. We would like to introduce this cross-type operation in some carefully controlled way, so that we can support it without seriously violating our abstraction barriers. There is a tension between the outcomes we desire: we would like to be able to add a complex number to a rational number, and we would like to do so using a generic <code>__add__</code> method that does the right thing with all numeric types. At the same time, we would like to separate the concerns of complex numbers and rational numbers whenever possible, in order to maintain a modular program.</p>
<p><strong>Type dispatching.</strong> One way to implement cross-type operations is to select behavior based on the types of the arguments to a function or method. The idea of type dispatching is to write functions that inspect the type of arguments they receive, then execute code that is appropriate for those types.</p>
<p>The built-in function <code>isinstance</code> takes an object and a class. It returns true if the object has a class that either is or inherits from the given class.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c &#x3D; ComplexRI(1, 1)</span><br><span class="line">&gt;&gt;&gt; isinstance(c, ComplexRI)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Complex)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, ComplexMA)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>A simple example of type dispatching is an <code>is_real</code> function that uses a different implementation for each type of complex number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def is_real(c):</span><br><span class="line">        &quot;&quot;&quot;Return whether c is a real number with no imaginary part.&quot;&quot;&quot;</span><br><span class="line">        if isinstance(c, ComplexRI):</span><br><span class="line">            return c.imag &#x3D;&#x3D; 0</span><br><span class="line">        elif isinstance(c, ComplexMA):</span><br><span class="line">            return c.angle % pi &#x3D;&#x3D; 0</span><br><span class="line">&gt;&gt;&gt; is_real(ComplexRI(1, 1))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; is_real(ComplexMA(2, pi))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>Type dispatching is not always performed using <code>isinstance</code>. For arithmetic, we will give a <code>type_tag</code>attribute to <code>Rational</code> and <code>Complex</code> instances that has a string value. When two values <code>x</code> and <code>y</code> have the same <code>type_tag</code>, then we can combine them directly with <code>x.add(y)</code>. If not, we need a cross-type operation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Rational.type_tag &#x3D; &#39;rat&#39;</span><br><span class="line">&gt;&gt;&gt; Complex.type_tag &#x3D; &#39;com&#39;</span><br><span class="line">&gt;&gt;&gt; Rational(2, 5).type_tag &#x3D;&#x3D; Rational(1, 2).type_tag</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; ComplexRI(1, 1).type_tag &#x3D;&#x3D; ComplexMA(2, pi&#x2F;2).type_tag</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Rational(2, 5).type_tag &#x3D;&#x3D; ComplexRI(1, 1).type_tag</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>To combine complex and rational numbers, we write functions that rely on both of their representations simultaneously. Below, we rely on the fact that a <code>Rational</code> can be converted approximately to a <code>float</code>value that is a real number. The result can be combined with a complex number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_complex_and_rational(c, r):</span><br><span class="line">        return ComplexRI(c.real + r.numer&#x2F;r.denom, c.imag)</span><br></pre></td></tr></table></figure>
<p>Multiplication involves a similar conversion. In polar form, a real number in the complex plane always has a positive magnitude. The angle 0 indicates a positive number. The angle <code>pi</code> indicates a negative number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mul_complex_and_rational(c, r):</span><br><span class="line">        r_magnitude, r_angle &#x3D; r.numer&#x2F;r.denom, 0</span><br><span class="line">        if r_magnitude &lt; 0:</span><br><span class="line">            r_magnitude, r_angle &#x3D; -r_magnitude, pi</span><br><span class="line">        return ComplexMA(c.magnitude * r_magnitude, c.angle + r_angle)</span><br></pre></td></tr></table></figure>
<p>Both addition and multiplication are commutative, so swapping the argument order can use the same implementations of these cross-type operations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_rational_and_complex(r, c):</span><br><span class="line">        return add_complex_and_rational(c, r)</span><br><span class="line">&gt;&gt;&gt; def mul_rational_and_complex(r, c):</span><br><span class="line">        return mul_complex_and_rational(c, r)</span><br></pre></td></tr></table></figure>
<p>The role of type dispatching is to ensure that these cross-type operations are used at appropriate times. Below, we rewrite the <code>Number</code> superclass to use type dispatching for its <code>__add__</code> and <code>__mul__</code> methods.</p>
<p>We use the <code>type_tag</code> attribute to distinguish types of arguments. One could directly use the built-in <code>isinstance</code> method as well, but tags simplify the implementation. Using type tags also illustrates that type dispatching is not necessarily linked to the Python object system, but instead a general technique for creating generic functions over heterogeneous domains.</p>
<p>The <code>__add__</code> method considers two cases. First, if two arguments have the same type tag, then it assumes that <code>add</code> method of the first can take the second as an argument. Otherwise, it checks whether a dictionary of cross-type implementations, called <code>adders</code>, contains a function that can add arguments of those type tags. If there is such a function, the <code>cross_apply</code> method finds and applies it. The <code>__mul__</code>method has a similar structure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Number:</span><br><span class="line">        def __add__(self, other):</span><br><span class="line">            if self.type_tag &#x3D;&#x3D; other.type_tag:</span><br><span class="line">                return self.add(other)</span><br><span class="line">            elif (self.type_tag, other.type_tag) in self.adders:</span><br><span class="line">                return self.cross_apply(other, self.adders)</span><br><span class="line">        def __mul__(self, other):</span><br><span class="line">            if self.type_tag &#x3D;&#x3D; other.type_tag:</span><br><span class="line">                return self.mul(other)</span><br><span class="line">            elif (self.type_tag, other.type_tag) in self.multipliers:</span><br><span class="line">                return self.cross_apply(other, self.multipliers)</span><br><span class="line">        def cross_apply(self, other, cross_fns):</span><br><span class="line">            cross_fn &#x3D; cross_fns[(self.type_tag, other.type_tag)]</span><br><span class="line">            return cross_fn(self, other)</span><br><span class="line">        adders &#x3D; &#123;(&quot;com&quot;, &quot;rat&quot;): add_complex_and_rational,</span><br><span class="line">                  (&quot;rat&quot;, &quot;com&quot;): add_rational_and_complex&#125;</span><br><span class="line">        multipliers &#x3D; &#123;(&quot;com&quot;, &quot;rat&quot;): mul_complex_and_rational,</span><br><span class="line">                       (&quot;rat&quot;, &quot;com&quot;): mul_rational_and_complex&#125;</span><br></pre></td></tr></table></figure>
<p>In this new definition of the <code>Number</code> class, all cross-type implementations are indexed by pairs of type tags in the <code>adders</code> and <code>multipliers</code> dictionaries.</p>
<p>This dictionary-based approach to type dispatching is extensible. New subclasses of <code>Number</code> could install themselves into the system by declaring a type tag and adding cross-type operations to <code>Number.adders</code>and <code>Number.multipliers</code>. They could also define their own <code>adders</code> and <code>multipliers</code> in a subclass.</p>
<p>While we have introduced some complexity to the system, we can now mix types in addition and multiplication expressions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ComplexRI(1.5, 0) + Rational(3, 2)</span><br><span class="line">ComplexRI(3, 0)</span><br><span class="line">&gt;&gt;&gt; Rational(-1, 2) * ComplexMA(4, pi&#x2F;2)</span><br><span class="line">ComplexMA(2, 1.5 * pi)</span><br></pre></td></tr></table></figure>
<p><strong>Coercion.</strong> In the general situation of completely unrelated operations acting on completely unrelated types, implementing explicit cross-type operations, cumbersome though it may be, is the best that one can hope for. Fortunately, we can sometimes do better by taking advantage of additional structure that may be latent in our type system. Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called <em>coercion</em>. For example, if we are asked to arithmetically combine a rational number with a complex number, we can view the rational number as a complex number whose imaginary part is zero. After doing so, we can use <code>Complex.add</code> and <code>Complex.mul</code> to combine them.</p>
<p>In general, we can implement this idea by designing coercion functions that transform an object of one type into an equivalent object of another type. Here is a typical coercion function, which transforms a rational number to a complex number with zero imaginary part:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def rational_to_complex(r):</span><br><span class="line">        return ComplexRI(r.numer&#x2F;r.denom, 0)</span><br></pre></td></tr></table></figure>
<p>The alternative definition of the <code>Number</code> class performs cross-type operations by attempting to coerce both arguments to the same type. The <code>coercions</code> dictionary indexes all possible coercions by a pair of type tags, indicating that the corresponding value coerces a value of the first type to a value of the second type.</p>
<p>It is not generally possible to coerce an arbitrary data object of each type into all other types. For example, there is no way to coerce an arbitrary complex number to a rational number, so there will be no such conversion implementation in the <code>coercions</code> dictionary.</p>
<p>The <code>coerce</code> method returns two values with the same type tag. It inspects the type tags of its arguments, compares them to entries in the <code>coercions</code> dictionary, and converts one argument to the type of the other using <code>coerce_to</code>. Only one entry in <code>coercions</code> is necessary to complete our cross-type arithmetic system, replacing the four cross-type functions in the type-dispatching version of <code>Number</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Number:</span><br><span class="line">        def __add__(self, other):</span><br><span class="line">            x, y &#x3D; self.coerce(other)</span><br><span class="line">            return x.add(y)</span><br><span class="line">        def __mul__(self, other):</span><br><span class="line">            x, y &#x3D; self.coerce(other)</span><br><span class="line">            return x.mul(y)</span><br><span class="line">        def coerce(self, other):</span><br><span class="line">            if self.type_tag &#x3D;&#x3D; other.type_tag:</span><br><span class="line">                return self, other</span><br><span class="line">            elif (self.type_tag, other.type_tag) in self.coercions:</span><br><span class="line">                return (self.coerce_to(other.type_tag), other)</span><br><span class="line">            elif (other.type_tag, self.type_tag) in self.coercions:</span><br><span class="line">                return (self, other.coerce_to(self.type_tag))</span><br><span class="line">        def coerce_to(self, other_tag):</span><br><span class="line">            coercion_fn &#x3D; self.coercions[(self.type_tag, other_tag)]</span><br><span class="line">            return coercion_fn(self)</span><br><span class="line">        coercions &#x3D; &#123;(&#39;rat&#39;, &#39;com&#39;): rational_to_complex&#125;</span><br></pre></td></tr></table></figure>
<p>This coercion scheme has some advantages over the method of defining explicit cross-type operations. Although we still need to write coercion functions to relate the types, we need to write only one function for each pair of types rather than a different function for each set of types and each generic operation. What we are counting on here is the fact that the appropriate transformation between types depends only on the types themselves, not on the particular operation to be applied.</p>
<p>Further advantages come from extending coercion. Some more sophisticated coercion schemes do not just try to coerce one type into another, but instead may try to coerce two different types each into a third common type. Consider a rhombus and a rectangle: neither is a special case of the other, but both can be viewed as quadrilaterals. Another extension to coercion is iterative coercion, in which one data type is coerced into another via intermediate types. Consider that an integer can be converted into a real number by first converting it into a rational number, then converting that rational number into a real number. Chaining coercion in this way can reduce the total number of coercion functions that are required by a program.</p>
<p>Despite its advantages, coercion does have potential drawbacks. For one, coercion functions can lose information when they are applied. In our example, rational numbers are exact representations, but become approximations when they are converted to complex numbers.</p>
<p>Some programming languages have automatic coercion systems built in. In fact, early versions of Python had a <code>__coerce__</code> special method on objects. In the end, the complexity of the built-in coercion system did not justify its use, and so it was removed. Instead, particular operators apply coercion to their arguments as needed.</p>
<p><a href="http://composingprograms.com/" target="_blank" rel="noopener">C⚬MP⚬SING PR⚬GRAMS </a></p>
<ul>
<li><a href="http://composingprograms.com/" target="_blank" rel="noopener">TEXT</a></li>
<li></li>
<li><p><a href="http://composingprograms.com/projects.html" target="_blank" rel="noopener">PROJECTS</a></p>
</li>
<li></li>
<li><p><a href="http://composingprograms.com/tutor.html" target="_blank" rel="noopener">TUTOR</a></p>
</li>
<li></li>
<li><p><a href="http://composingprograms.com/about.html" target="_blank" rel="noopener">ABOUT</a></p>
</li>
</ul>
<h3 id="Chapter-2Hide-contents"><a href="#Chapter-2Hide-contents" class="headerlink" title="Chapter 2Hide contents"></a>Chapter 2Hide contents</h3><h3 id="2-1-Introduction-1"><a href="#2-1-Introduction-1" class="headerlink" title="2.1 Introduction"></a><a href="http://composingprograms.com/pages/21-introduction.html" target="_blank" rel="noopener">2.1 Introduction</a></h3><p><a href="http://composingprograms.com/pages/21-introduction.html#native-data-types" target="_blank" rel="noopener">2.1.1 Native Data Types</a></p>
<h3 id="2-2-Data-Abstraction-1"><a href="#2-2-Data-Abstraction-1" class="headerlink" title="2.2 Data Abstraction"></a><a href="http://composingprograms.com/pages/22-data-abstraction.html" target="_blank" rel="noopener">2.2 Data Abstraction</a></h3><p><a href="http://composingprograms.com/pages/22-data-abstraction.html#example-rational-numbers" target="_blank" rel="noopener">2.2.1 Example: Rational Numbers</a></p>
<p><a href="http://composingprograms.com/pages/22-data-abstraction.html#pairs" target="_blank" rel="noopener">2.2.2 Pairs</a></p>
<p><a href="http://composingprograms.com/pages/22-data-abstraction.html#abstraction-barriers" target="_blank" rel="noopener">2.2.3 Abstraction Barriers</a></p>
<p><a href="http://composingprograms.com/pages/22-data-abstraction.html#the-properties-of-data" target="_blank" rel="noopener">2.2.4 The Properties of Data</a></p>
<h3 id="2-3-Sequences-1"><a href="#2-3-Sequences-1" class="headerlink" title="2.3 Sequences"></a><a href="http://composingprograms.com/pages/23-sequences.html" target="_blank" rel="noopener">2.3 Sequences</a></h3><p><a href="http://composingprograms.com/pages/23-sequences.html#lists" target="_blank" rel="noopener">2.3.1 Lists</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#sequence-iteration" target="_blank" rel="noopener">2.3.2 Sequence Iteration</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#sequence-processing" target="_blank" rel="noopener">2.3.3 Sequence Processing</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#sequence-abstraction" target="_blank" rel="noopener">2.3.4 Sequence Abstraction</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#strings" target="_blank" rel="noopener">2.3.5 Strings</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#trees" target="_blank" rel="noopener">2.3.6 Trees</a></p>
<p><a href="http://composingprograms.com/pages/23-sequences.html#linked-lists" target="_blank" rel="noopener">2.3.7 Linked Lists</a></p>
<h3 id="2-4-Mutable-Data-1"><a href="#2-4-Mutable-Data-1" class="headerlink" title="2.4 Mutable Data"></a><a href="http://composingprograms.com/pages/24-mutable-data.html" target="_blank" rel="noopener">2.4 Mutable Data</a></h3><p><a href="http://composingprograms.com/pages/24-mutable-data.html#the-object-metaphor" target="_blank" rel="noopener">2.4.1 The Object Metaphor</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#sequence-objects" target="_blank" rel="noopener">2.4.2 Sequence Objects</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#dictionaries" target="_blank" rel="noopener">2.4.3 Dictionaries</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#local-state" target="_blank" rel="noopener">2.4.4 Local State</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#the-benefits-of-non-local-assignment" target="_blank" rel="noopener">2.4.5 The Benefits of Non-Local Assignment</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#the-cost-of-non-local-assignment" target="_blank" rel="noopener">2.4.6 The Cost of Non-Local Assignment</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#iterators" target="_blank" rel="noopener">2.4.7 Iterators</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#iterables" target="_blank" rel="noopener">2.4.8 Iterables</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#built-in-iterators" target="_blank" rel="noopener">2.4.9 Built-in Iterators</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#generators" target="_blank" rel="noopener">2.4.10 Generators</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#implementing-lists-and-dictionaries" target="_blank" rel="noopener">2.4.11 Implementing Lists and Dictionaries</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#dispatch-dictionaries" target="_blank" rel="noopener">2.4.12 Dispatch Dictionaries</a></p>
<p><a href="http://composingprograms.com/pages/24-mutable-data.html#propagating-constraints" target="_blank" rel="noopener">2.4.13 Propagating Constraints</a></p>
<h3 id="2-5-Object-Oriented-Programming-1"><a href="#2-5-Object-Oriented-Programming-1" class="headerlink" title="2.5 Object-Oriented Programming"></a><a href="http://composingprograms.com/pages/25-object-oriented-programming.html" target="_blank" rel="noopener">2.5 Object-Oriented Programming</a></h3><p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#objects-and-classes" target="_blank" rel="noopener">2.5.1 Objects and Classes</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#defining-classes" target="_blank" rel="noopener">2.5.2 Defining Classes</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#message-passing-and-dot-expressions" target="_blank" rel="noopener">2.5.3 Message Passing and Dot Expressions</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#class-attributes" target="_blank" rel="noopener">2.5.4 Class Attributes</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#inheritance" target="_blank" rel="noopener">2.5.5 Inheritance</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#using-inheritance" target="_blank" rel="noopener">2.5.6 Using Inheritance</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#multiple-inheritance" target="_blank" rel="noopener">2.5.7 Multiple Inheritance</a></p>
<p><a href="http://composingprograms.com/pages/25-object-oriented-programming.html#the-role-of-objects" target="_blank" rel="noopener">2.5.8 The Role of Objects</a></p>
<h3 id="2-6-Implementing-Classes-and-Objects-1"><a href="#2-6-Implementing-Classes-and-Objects-1" class="headerlink" title="2.6 Implementing Classes and Objects"></a><a href="http://composingprograms.com/pages/26-implementing-classes-and-objects.html" target="_blank" rel="noopener">2.6 Implementing Classes and Objects</a></h3><p><a href="http://composingprograms.com/pages/26-implementing-classes-and-objects.html#instances" target="_blank" rel="noopener">2.6.1 Instances</a></p>
<p><a href="http://composingprograms.com/pages/26-implementing-classes-and-objects.html#classes" target="_blank" rel="noopener">2.6.2 Classes</a></p>
<p><a href="http://composingprograms.com/pages/26-implementing-classes-and-objects.html#using-implemented-objects" target="_blank" rel="noopener">2.6.3 Using Implemented Objects</a></p>
<h3 id="2-7-Object-Abstraction-1"><a href="#2-7-Object-Abstraction-1" class="headerlink" title="2.7 Object Abstraction"></a><a href="http://composingprograms.com/pages/27-object-abstraction.html" target="_blank" rel="noopener">2.7 Object Abstraction</a></h3><p><a href="http://composingprograms.com/pages/27-object-abstraction.html#string-conversion" target="_blank" rel="noopener">2.7.1 String Conversion</a></p>
<p><a href="http://composingprograms.com/pages/27-object-abstraction.html#special-methods" target="_blank" rel="noopener">2.7.2 Special Methods</a></p>
<p><a href="http://composingprograms.com/pages/27-object-abstraction.html#multiple-representations" target="_blank" rel="noopener">2.7.3 Multiple Representations</a></p>
<p><a href="http://composingprograms.com/pages/27-object-abstraction.html#generic-functions" target="_blank" rel="noopener">2.7.4 Generic Functions</a></p>
<h3 id="2-8-Efficiency"><a href="#2-8-Efficiency" class="headerlink" title="2.8 Efficiency"></a><a href="http://composingprograms.com/pages/28-efficiency.html" target="_blank" rel="noopener">2.8 Efficiency</a></h3><p><a href="http://composingprograms.com/pages/28-efficiency.html#measuring-efficiency" target="_blank" rel="noopener">2.8.1 Measuring Efficiency</a></p>
<p><a href="http://composingprograms.com/pages/28-efficiency.html#memoization" target="_blank" rel="noopener">2.8.2 Memoization</a></p>
<p><a href="http://composingprograms.com/pages/28-efficiency.html#orders-of-growth" target="_blank" rel="noopener">2.8.3 Orders of Growth</a></p>
<p><a href="http://composingprograms.com/pages/28-efficiency.html#example-exponentiation" target="_blank" rel="noopener">2.8.4 Example: Exponentiation</a></p>
<p><a href="http://composingprograms.com/pages/28-efficiency.html#growth-categories" target="_blank" rel="noopener">2.8.5 Growth Categories</a></p>
<h3 id="2-9-Recursive-Objects"><a href="#2-9-Recursive-Objects" class="headerlink" title="2.9 Recursive Objects"></a><a href="http://composingprograms.com/pages/29-recursive-objects.html" target="_blank" rel="noopener">2.9 Recursive Objects</a></h3><p><a href="http://composingprograms.com/pages/29-recursive-objects.html#linked-list-class" target="_blank" rel="noopener">2.9.1 Linked List Class</a></p>
<p><a href="http://composingprograms.com/pages/29-recursive-objects.html#tree-class" target="_blank" rel="noopener">2.9.2 Tree Class</a></p>
<p><a href="http://composingprograms.com/pages/29-recursive-objects.html#sets" target="_blank" rel="noopener">2.9.3 Sets</a></p>
<h2 id="2-8-Efficiency-1"><a href="#2-8-Efficiency-1" class="headerlink" title="2.8  Efficiency"></a>2.8  Efficiency</h2><p>Decisions of how to represent and process data are often influenced by the efficiency of alternatives. Efficiency refers to the computational resources used by a representation or process, such as how much time and memory are required to compute the result of a function or represent an object. These amounts can vary widely depending on the details of an implementation.</p>
<h3 id="2-8-1-Measuring-Efficiency"><a href="#2-8-1-Measuring-Efficiency" class="headerlink" title="2.8.1  Measuring Efficiency"></a>2.8.1  Measuring Efficiency</h3><p>Measuring exactly how long a program requires to run or how much memory it consumes is challenging, because the results depend upon many details of how a computer is configured. A more reliable way to characterize the efficiency of a program is to measure how many times some event occurs, such as a function call.</p>
<p>Let’s return to our first tree-recursive function, the <code>fib</code> function for computing numbers in the Fibonacci sequence.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib(n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            return 1</span><br><span class="line">        return fib(n-2) + fib(n-1)</span><br><span class="line">&gt;&gt;&gt; fib(5)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Consider the pattern of computation that results from evaluating <code>fib(6)</code>, depicted below. To compute <code>fib(5)</code>, we compute <code>fib(3)</code> and <code>fib(4)</code>. To compute <code>fib(3)</code>, we compute <code>fib(1)</code> and <code>fib(2)</code>. In general, the evolved process looks like a tree. Each blue dot indicates a completed computation of a Fibonacci number in the traversal of this tree.</p>
<p><img src="http://composingprograms.com/img/fib.png" alt="img"></p>
<p>This function is instructive as a prototypical tree recursion, but it is a terribly inefficient way to compute Fibonacci numbers because it does so much redundant computation. The entire computation of <code>fib(3)</code>is duplicated.</p>
<p>We can measure this inefficiency. The higher-order <code>count</code> function returns an equivalent function to its argument that also maintains a <code>call_count</code> attribute. In this way, we can inspect just how many times <code>fib</code> is called.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count(f):</span><br><span class="line">        def counted(*args):</span><br><span class="line">            counted.call_count +&#x3D; 1</span><br><span class="line">            return f(*args)</span><br><span class="line">        counted.call_count &#x3D; 0</span><br><span class="line">        return counted</span><br></pre></td></tr></table></figure>
<p>By counting the number of calls to <code>fib</code>, we see that the calls required grows faster than the Fibonacci numbers themselves. This rapid expansion of calls is characteristic of tree-recursive functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib &#x3D; count(fib)</span><br><span class="line">&gt;&gt;&gt; fib(19)</span><br><span class="line">4181</span><br><span class="line">&gt;&gt;&gt; fib.call_count</span><br><span class="line">13529</span><br></pre></td></tr></table></figure>
<p><strong>Space.</strong> To understand the space requirements of a function, we must specify generally how memory is used, preserved, and reclaimed in our environment model of computation. In evaluating an expression, the interpreter preserves all <em>active</em> environments and all values and frames referenced by those environments. An environment is active if it provides the evaluation context for some expression being evaluated. An environment becomes inactive whenever the function call for which its first frame was created finally returns.</p>
<p>For example, when evaluating <code>fib</code>, the interpreter proceeds to compute each value in the order shown previously, traversing the structure of the tree. To do so, it only needs to keep track of those nodes that are above the current node in the tree at any point in the computation. The memory used to evaluate the rest of the branches can be reclaimed because it cannot affect future computation. In general, the space required for tree-recursive functions will be proportional to the maximum depth of the tree.</p>
<p>The diagram below depicts the environment created by evaluating <code>fib(3)</code>. In the process of evaluating the return expression for the initial application of <code>fib</code>, the expression <code>fib(n-2)</code> is evaluated, yielding a value of 0. Once this value is computed, the corresponding environment frame (grayed out) is no longer needed: it is not part of an active environment. Thus, a well-designed interpreter can reclaim the memory that was used to store this frame. On the other hand, if the interpreter is currently evaluating <code>fib(n-1)</code>, then the environment created by this application of <code>fib</code> (in which <code>n</code> is 2) is active. In turn, the environment originally created to apply <code>fib</code> to 3 is active because its return value has not yet been computed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">result = fib(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231830660.png" alt="image-20200206231830660" style="zoom:50%;"></p>
<p>The higher-order <code>count_frames</code> function tracks <code>open_count</code>, the number of calls to the function <code>f</code> that have not yet returned. The <code>max_count</code> attribute is the maximum value ever attained by <code>open_count</code>, and it corresponds to the maximum number of frames that are ever simultaneously active during the course of computation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count_frames(f):</span><br><span class="line">        def counted(*args):</span><br><span class="line">            counted.open_count +&#x3D; 1</span><br><span class="line">            counted.max_count &#x3D; max(counted.max_count, counted.open_count)</span><br><span class="line">            result &#x3D; f(*args)</span><br><span class="line">            counted.open_count -&#x3D; 1</span><br><span class="line">            return result</span><br><span class="line">        counted.open_count &#x3D; 0</span><br><span class="line">        counted.max_count &#x3D; 0</span><br><span class="line">        return counted</span><br><span class="line">&gt;&gt;&gt; fib &#x3D; count_frames(fib)</span><br><span class="line">&gt;&gt;&gt; fib(19)</span><br><span class="line">4181</span><br><span class="line">&gt;&gt;&gt; fib.open_count</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; fib.max_count</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; fib(24)</span><br><span class="line">46368</span><br><span class="line">&gt;&gt;&gt; fib.max_count</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<p>To summarize, the space requirement of the <code>fib</code> function, measured in active frames, is one less than the input, which tends to be small. The time requirement measured in total recursive calls is larger than the output, which tends to be huge.</p>
<h3 id="2-8-2-Memoization"><a href="#2-8-2-Memoization" class="headerlink" title="2.8.2  Memoization"></a>2.8.2  Memoization</h3><p>Tree-recursive computational processes can often be made more efficient through <em>memoization</em>, a powerful technique for increasing the efficiency of recursive functions that repeat computation. A memoized function will store the return value for any arguments it has previously received. A second call to <code>fib(25)</code> would not re-compute the return value recursively, but instead return the existing one that has already been constructed.</p>
<p>Memoization can be expressed naturally as a higher-order function, which can also be used as a decorator. The definition below creates a <em>cache</em> of previously computed results, indexed by the arguments from which they were computed. The use of a dictionary requires that the argument to the memoized function be immutable.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def memo(f):</span><br><span class="line">        cache &#x3D; &#123;&#125;</span><br><span class="line">        def memoized(n):</span><br><span class="line">            if n not in cache:</span><br><span class="line">                cache[n] &#x3D; f(n)</span><br><span class="line">            return cache[n]</span><br><span class="line">        return memoized</span><br></pre></td></tr></table></figure>
<p>If we apply <code>memo</code> to the recursive computation of Fibonacci numbers, a new pattern of computation evolves, depicted below.</p>
<p><img src="http://composingprograms.com/img/fib_memo.png" alt="img"></p>
<p>In this computation of <code>fib(5)</code>, the results for <code>fib(2)</code> and <code>fib(3)</code> are reused when computing <code>fib(4)</code> on the right branch of the tree. As a result, much of the tree-recursive computation is not required at all.</p>
<p>Using <code>count</code>, we can see that the <code>fib</code> function is actually only called once for each unique input to <code>fib</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counted_fib &#x3D; count(fib)</span><br><span class="line">&gt;&gt;&gt; fib  &#x3D; memo(counted_fib)</span><br><span class="line">&gt;&gt;&gt; fib(19)</span><br><span class="line">4181</span><br><span class="line">&gt;&gt;&gt; counted_fib.call_count</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; fib(34)</span><br><span class="line">5702887</span><br><span class="line">&gt;&gt;&gt; counted_fib.call_count</span><br><span class="line">35</span><br></pre></td></tr></table></figure>
<h3 id="2-8-3-Orders-of-Growth"><a href="#2-8-3-Orders-of-Growth" class="headerlink" title="2.8.3  Orders of Growth"></a>2.8.3  Orders of Growth</h3><p>Processes can differ massively in the rates at which they consume the computational resources of space and time, as the previous examples illustrate. However, exactly determining just how much space or time will be used when calling a function is a very difficult task that depends upon many factors. A useful way to analyze a process is to categorize it along with a group of processes that all have similar requirements. A useful categorization is the <em>order of growth</em> of a process, which expresses in simple terms how the resource requirements of a process grow as a function of the input.</p>
<p>As an introduction to orders of growth, we will analyze the function <code>count_factors</code> below, which counts the number of integers that evenly divide an input <code>n</code>. The function attempts to divide <code>n</code> by every integer less than or equal to its square root. The implementation takes advantage of the fact that if $k$ divides $n$ and $k&lt;\sqrt n$ , then there is another factor $j=n/ k$ such that $j &gt; \sqrt n$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_factors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sqrt_n = sqrt(n)</span><br><span class="line">    k, factors = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; sqrt_n:</span><br><span class="line">        <span class="keyword">if</span> n % k == <span class="number">0</span>:</span><br><span class="line">            factors += <span class="number">2</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k * k == n:</span><br><span class="line">        factors += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> factors</span><br><span class="line"></span><br><span class="line">result = count_factors(<span class="number">576</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Users/brooklyn/Library/Application Support/typora-user-images/image-20200206231931893.png" alt="image-20200206231931893" style="zoom:50%;"></p>
<p>How much time is required to evaluate <code>count_factors</code>? The exact answer will vary on different machines, but we can make some useful general observations about the amount of computation involved. The total number of times this process executes the body of the <code>while</code> statement is the greatest integer less than $\sqrt n$. The statements before and after this <code>while</code> statement are executed exactly once. So, the total number of statements executed is $w \cdot {\sqrt n} + v$, where $w$ is the number of statements in the <code>while</code> body and $v$ is the number of statements outside of the <code>while</code> statement. Although it isn’t exact, this formula generally characterizes how much time will be required to evaluate <code>count_factors</code> as a function of the input <code>n</code>.</p>
<p>A more exact description is difficult to obtain. The constants $w$ and $v$ are not constant at all, because the assignment statements to <code>factors</code> are sometimes executed but sometimes not. An order of growth analysis allows us to gloss over such details and instead focus on the general shape of growth. In particular, the order of growth for <code>count_factors</code> expresses in precise terms that the amount of time required to compute <code>count_factors(n)</code> scales at the rate $\sqrt n $, within a margin of some constant factors.</p>
<p><strong>Theta Notation.</strong> Let   be a parameter that measures the size of the input to some process, and let $R(n)$ be the amount of some resource that the process requires for an input of size $n$. In our previous examples we took $n$ to be the number for which a given function is to be computed, but there are other possibilities. For instance, if our goal is to compute an approximation to the square root of a number, we might take $n$ to be the number of digits of accuracy required.</p>
<p>$ R(n)$ might measure the amount of memory used, the number of elementary machine steps performed, and so on. In computers that do only a fixed number of steps at a time, the time required to evaluate an expression will be proportional to the number of elementary steps performed in the process of evaluation.</p>
<p>We say that $R(n)$ has order of growth $\Theta (f(n))$, written $R(n) = \Theta (f(n))$ (pronounced “theta of $f(n)$”), if there are positive constants $k_1$ and $k_2$ independent of $n$ such that</p>
<script type="math/tex; mode=display">
k_1 \cdot f(n) \le R(n) \le k_2 \cdot f(n)</script><p>for any value of $n$ larger than some minimum $m$. In other words, for large $n$, the value $R(n)$ is always sandwiched between two values that both scale with $f(n)$:</p>
<ul>
<li>A lower bound $k_1 \cdot f(n)$ and</li>
<li>An upper bound $k_2 \cdot f(n)$</li>
</ul>
<p>We can apply this definition to show that the number of steps required to evaluate <code>count_factors(n)</code>grows as $\Theta (\sqrt n)$ by inspecting the function body.</p>
<p>First, we choose $k_1 = 1$ and $m=0$, so that the lower bound states that <code>count_factors(n)</code> requires at least $1 \cdot \sqrt n$ steps for any $n &gt; 0$. There are at least 4 lines executed outside of the <code>while</code> statement, each of which takes at least 1 step to execute. There are at least two lines executed within the <code>while</code>body, along with the while header itself. All of these require at least one step. The <code>while</code> body is evaluated at least $\sqrt n - 1$ times. Composing these lower bounds, we see that the process requires at least $4 + 3 \cdot  \sqrt n - 1$ steps, which is always larger than $k_1 \cdot \sqrt n$.</p>
<p>Second, we can verify the upper bound. We assume that any single line in the body of <code>count_factors</code>requires at most <code>p</code> steps. This assumption isn’t true for every line of Python, but does hold in this case. Then, evaluating <code>count_factors(n)</code> can require at most $p \cdot (5+4\sqrt n)$, because there are 5 lines outside of the <code>while</code> statement and 4 within (including the header). This upper bound holds even if every <code>if</code> header evaluates to true. Finally, if we choose $k_2 = 5p$, then the steps required is always smaller than $k_2 \cdot \sqrt n$. Our argument is complete.</p>
<h3 id="2-8-4-Example-Exponentiation"><a href="#2-8-4-Example-Exponentiation" class="headerlink" title="2.8.4  Example: Exponentiation"></a>2.8.4  Example: Exponentiation</h3><p>Consider the problem of computing the exponential of a given number. We would like a function that takes as arguments a base <code>b</code> and a positive integer exponent <code>n</code> and computes bnbn. One way to do this is via the recursive definition</p>
<script type="math/tex; mode=display">
\begin {align}
b^n &= b \cdot b^{n-1} \\ 
b^0 &= 1
\end {align}</script><p>which translates readily into the recursive function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def exp(b, n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return 1</span><br><span class="line">        return b * exp(b, n-1)</span><br></pre></td></tr></table></figure>
<p>This is a linear recursive process that requires Θ(n)Θ(n) steps and Θ(n)Θ(n) space. Just as with factorial, we can readily formulate an equivalent linear iteration that requires a similar number of steps but constant space.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def exp_iter(b, n):</span><br><span class="line">        result &#x3D; 1</span><br><span class="line">        for _ in range(n):</span><br><span class="line">            result &#x3D; result * b</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>
<p>We can compute exponentials in fewer steps by using successive squaring. For instance, rather than computing $b^8$ as</p>
<script type="math/tex; mode=display">
b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot b)))))))</script><p>we can compute it using three multiplications:</p>
<script type="math/tex; mode=display">
\begin {align}
b^2 &= b \cdot b \\ 
b^4 &= b^2 \cdot b^2 \\
b^8 &= b^4 \cdot b^4
\end {align}</script><p>This method works fine for exponents that are powers of 2. We can also take advantage of successive squaring in computing exponentials in general if we use the recursive rule</p>
<script type="math/tex; mode=display">
b^n=
\left\{ 
\begin{array}{c}
( b^{\frac{n}{2}})^2  ~~~~~~if~n ~ is~even\\ 
b \cdot b^{n-1}~~~~~if~n ~ is~odd
\end{array}
\right.</script><p>We can express this method as a recursive function as well:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return x*x</span><br><span class="line">&gt;&gt;&gt; def fast_exp(b, n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return 1</span><br><span class="line">        if n % 2 &#x3D;&#x3D; 0:</span><br><span class="line">            return square(fast_exp(b, n&#x2F;&#x2F;2))</span><br><span class="line">        else:</span><br><span class="line">            return b * fast_exp(b, n-1)</span><br><span class="line">&gt;&gt;&gt; fast_exp(2, 100)</span><br><span class="line">1267650600228229401496703205376</span><br></pre></td></tr></table></figure>
<p>The process evolved by <code>fast_exp</code> grows logarithmically with <code>n</code> in both space and number of steps. To see this, observe that computing $b^{2n}$ using <code>fast_exp</code> requires only one more multiplication than computing $b^n$. The size of the exponent we can compute therefore doubles (approximately) with every new multiplication we are allowed. Thus, the number of multiplications required for an exponent of <code>n</code>grows about as fast as the logarithm of <code>n</code> base 2. The process has $\Theta(\log n)$ growth. The difference between $\Theta(\log n)$ growth and $\Theta( n)$ growth becomes striking as nn becomes large. For example, <code>fast_exp</code> for <code>n</code> of 1000 requires only 14 multiplications instead of 1000.</p>
<h3 id="2-8-5-Growth-Categories"><a href="#2-8-5-Growth-Categories" class="headerlink" title="2.8.5  Growth Categories"></a>2.8.5  Growth Categories</h3><p>Orders of growth are designed to simplify the analysis and comparison of computational processes. Many different processes can all have equivalent orders of growth, which indicates that they scale in similar ways. It is an essential skill of a computer scientist to know and recognize common orders of growth and identify processes of the same order.</p>
<p><strong>Constants.</strong> Constant terms do not affect the order of growth of a process. So, for instance, $\Theta( n)$ and $\Theta(500 \cdot n)$ are the same order of growth. This property follows from the definition of theta notation, which allows us to choose arbitrary constants $k_1$ and $k_2$ (such as $\frac{1}{500}$) for the upper and lower bounds. For simplicity, constants are always omitted from orders of growth.</p>
<p><strong>Logarithms.</strong> The base of a logarithm does not affect the order of growth of a process. For instance, $\log_2 n$ and $\log_{10} n$ are the same order of growth. Changing the base of a logarithm is equivalent to multiplying by a constant factor.</p>
<p><strong>Nesting.</strong> When an inner computational process is repeated for each step in an outer process, then the order of growth of the entire process is a product of the number of steps in the outer and inner processes.</p>
<p>For example, the function <code>overlap</code> below computes the number of elements in list <code>a</code> that also appear in list <code>b</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def overlap(a, b):</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for item in a:</span><br><span class="line">            if item in b:</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">        return count</span><br><span class="line">&gt;&gt;&gt; overlap([1, 3, 2, 2, 5, 1], [5, 4, 2])</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>The <code>in</code> operator for lists requires $\Theta( n)$ time, where nn is the length of the list <code>b</code>. It is applied $\Theta( m)$ times, where mm is the length of the list <code>a</code>. The <code>item in b</code> expression is the inner process, and the <code>for item in a</code> loop is the outer process. The total order of growth for this function is $\Theta(m \cdot n)$.</p>
<p><strong>Lower-order terms.</strong> As the input to a process grows, the fastest growing part of a computation dominates the total resources used. Theta notation captures this intuition. In a sum, all but the fastest growing term can be dropped without changing the order of growth.</p>
<p>For instance, consider the <code>one_more</code> function that returns how many elements of a list <code>a</code> are one more than some other element of <code>a</code>. That is, in the list <code>[3, 14, 15, 9]</code>, the element 15 is one more than 14, so <code>one_more</code> will return 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def one_more(a):</span><br><span class="line">        return overlap([x-1 for x in a], a)</span><br><span class="line">&gt;&gt;&gt; one_more([3, 14, 15, 9])</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>There are two parts to this computation: the list comprehension and the call to <code>overlap</code>. For a list <code>a</code> of length nn, list comprehension requires $\Theta( n)$ steps, while the call to <code>overlap</code> requires $\Theta( n^2)$ steps. The sum of steps is $\Theta(n+n^2)$, but this is not the simplest way of expressing the order of growth.</p>
<p>$\Theta(n^2+k \cdot n)$ and $\Theta (n^2)$ are equivalent for any constant $k$ because the $n^2$ term will eventually dominate the total for any $k$. The fact that bounds must hold only for $n$ greater than some minimum $m$ establishes this equivalence. For simplicity, lower-order terms are always omitted from orders of growth, and so we will never see a sum within a theta expression.</p>
<p><strong>Common categories.</strong> Given these equivalence properties, a small set of common categories emerge to describe most computational processes. The most common are listed below from slowest to fastest growth, along with descriptions of the growth as the input increases. Examples for each category follow.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Category</strong></th>
<th style="text-align:left"><strong>Theta Notation</strong></th>
<th style="text-align:left"><strong>Growth Description</strong></th>
<th style="text-align:left"><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Constant</td>
<td style="text-align:left">$\Theta (1)$</td>
<td style="text-align:left">Growth is independent of the input</td>
<td style="text-align:left"><code>abs</code></td>
</tr>
<tr>
<td style="text-align:left">Logarithmic</td>
<td style="text-align:left">$\Theta (\log n)$</td>
<td style="text-align:left">Multiplying input increments resources</td>
<td style="text-align:left"><code>fast_exp</code></td>
</tr>
<tr>
<td style="text-align:left">Linear</td>
<td style="text-align:left">$\Theta (n) $</td>
<td style="text-align:left">Incrementing input increments resources</td>
<td style="text-align:left"><code>exp</code></td>
</tr>
<tr>
<td style="text-align:left">Quadratic</td>
<td style="text-align:left">$\Theta (n^2) $</td>
<td style="text-align:left">Incrementing input adds n resources</td>
<td style="text-align:left"><code>one_more</code></td>
</tr>
<tr>
<td style="text-align:left">Exponential</td>
<td style="text-align:left">$\Theta (b^n) $</td>
<td style="text-align:left">Incrementing input multiplies resources</td>
<td style="text-align:left"><code>fib</code></td>
</tr>
</tbody>
</table>
</div>
<p>Other categories exist, such as the $\Theta (\sqrt n)$ growth of <code>count_factors</code>. However, these categories are particularly common.</p>
<p>Exponential growth describes many different orders of growth, because changing the base $b$ does affect the order of growth. For instance, the number of steps in our tree-recursive Fibonacci computation <code>fib</code>grows exponentially in its input $n$. In particular, one can show that the nth Fibonacci number is the closest integer to</p>
<script type="math/tex; mode=display">
\frac {\phi ^{n-2}}{\sqrt 5}</script><p>where $\phi$ is the golden ratio:</p>
<script type="math/tex; mode=display">
\phi = \frac{1+ \sqrt 5}{2} \approx 1.6180</script><p>We also stated that the number of steps scales with the resulting value, and so the tree-recursive process requires $\Theta (\phi ^n)$ steps, a function that grows exponentially with $n$.</p>
<h2 id="2-9-Recursive-Objects-1"><a href="#2-9-Recursive-Objects-1" class="headerlink" title="2.9  Recursive Objects"></a>2.9  Recursive Objects</h2><p>Objects can have other objects as attribute values. When an object of some class has an attribute value of that same class, it is a recursive object.</p>
<h3 id="2-9-1-Linked-List-Class"><a href="#2-9-1-Linked-List-Class" class="headerlink" title="2.9.1  Linked List Class"></a>2.9.1  Linked List Class</h3><p>A linked list, introduced earlier in this chapter, is composed of a first element and the rest of the list. The rest of a linked list is itself a linked list — a recursive definition. The empty list is a special case of a linked list that has no first element or rest. A linked list is a sequence: it has a finite length and supports element selection by index.</p>
<p>We can now implement a class with the same behavior. In this version, we will define its behavior using special method names that allow our class to work with the built-in <code>len</code> function and element selection operator (square brackets or <code>operator.getitem</code>) in Python. These built-in functions invoke special method names of a class: length is computed by <code>__len__</code> and element selection is computed by <code>__getitem__</code>. The empty linked list is represented by an empty tuple, which has length 0 and no elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty &#x3D; ()</span><br><span class="line">        def __init__(self, first, rest&#x3D;empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first &#x3D; first</span><br><span class="line">            self.rest &#x3D; rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i &#x3D;&#x3D; 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Link(3, Link(4, Link(5)))</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; s[1]</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>The definitions of <code>__len__</code> and <code>__getitem__</code> are in fact recursive. The built-in Python function <code>len</code> invokes a method called <code>__len__</code> when applied to a user-defined object argument. Likewise, the element selection operator invokes a method called <code>__getitem__</code>. Thus, bodies of these two methods will call themselves indirectly. For <code>__len__</code>, the base case is reached when <code>self.rest</code> evaluates to the empty tuple, <code>Link.empty</code>, which has a length of 0.</p>
<p>The built-in <code>isinstance</code> function returns whether the first argument has a type that is or inherits from the second argument. <code>isinstance(rest, Link)</code> is true if <code>rest</code> is a <code>Link</code> instance or an instance of some sub-class of <code>Link</code>.</p>
<p>Our implementation is complete, but an instance of the <code>Link</code> class is currently difficult to inspect. To help with debugging, we can also define a function to convert a <code>Link</code> to a string expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def link_expression(s):</span><br><span class="line">        &quot;&quot;&quot;Return a string that would evaluate to s.&quot;&quot;&quot;</span><br><span class="line">        if s.rest is Link.empty:</span><br><span class="line">            rest &#x3D; &#39;&#39;</span><br><span class="line">        else:</span><br><span class="line">            rest &#x3D; &#39;, &#39; + link_expression(s.rest)</span><br><span class="line">        return &#39;Link(&#123;0&#125;&#123;1&#125;)&#39;.format(s.first, rest)</span><br><span class="line">&gt;&gt;&gt; link_expression(s)</span><br><span class="line">&#39;Link(3, Link(4, Link(5)))&#39;</span><br></pre></td></tr></table></figure>
<p>This way of displaying an <code>Link</code> is so convenient that we would like to use it whenever an <code>Link</code> instance is displayed. We can ensure this behavior by setting the <code>link_expression</code> function as the value of the special class attribute <code>__repr__</code>. Python displays instances of user-defined classes by invoking their <code>__repr__</code> method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Link.__repr__ &#x3D; link_expression</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">Link(3, Link(4, Link(5)))</span><br></pre></td></tr></table></figure>
<p>The <code>Link</code> class has the closure property. Just as an element of a list can itself be a list, a <code>Link</code> can contain a <code>Link</code> as its <code>first</code> element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s_first &#x3D; Link(s, Link(6))</span><br><span class="line">&gt;&gt;&gt; s_first</span><br><span class="line">Link(Link(3, Link(4, Link(5))), Link(6))</span><br></pre></td></tr></table></figure>
<p>The <code>s_first</code> linked list has only two elements, but its first element is a linked list with three elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(s_first)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len(s_first[0])</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; s_first[0][2]</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Recursive functions are particularly well-suited to manipulate linked lists. For instance, the recursive <code>extend_link</code> function builds a linked list containing the elements of one <code>Link</code> instance <code>s</code> followed by the elements of another <code>Link</code> instance <code>t</code>. Installing this function as the <code>__add__</code> method of the <code>Link</code> class emulates the addition behavior of a built-in list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def extend_link(s, t):</span><br><span class="line">        if s is Link.empty:</span><br><span class="line">            return t</span><br><span class="line">        else:</span><br><span class="line">            return Link(s.first, extend_link(s.rest, t))</span><br><span class="line">&gt;&gt;&gt; extend_link(s, s)</span><br><span class="line">Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span><br><span class="line">&gt;&gt;&gt; Link.__add__ &#x3D; extend_link</span><br><span class="line">&gt;&gt;&gt; s + s</span><br><span class="line">Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span><br></pre></td></tr></table></figure>
<p>Rather than list comprehensions, one linked list can be generated from another using two higher-order functions: <code>map_link</code> and <code>filter_link</code>. The <code>map_link</code> function defined below applies a function <code>f</code> to each element of a linked list <code>s</code> and constructs a linked list containing the results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def map_link(f, s):</span><br><span class="line">        if s is Link.empty:</span><br><span class="line">            return s</span><br><span class="line">        else:</span><br><span class="line">            return Link(f(s.first), map_link(f, s.rest))</span><br><span class="line">&gt;&gt;&gt; map_link(square, s)</span><br><span class="line">Link(9, Link(16, Link(25)))</span><br></pre></td></tr></table></figure>
<p>The <code>filter_link</code> function returns a linked list containing all elements of a linked list <code>s</code> for which <code>f</code> returns a true value. The combination of <code>map_link</code> and <code>filter_link</code> can express the same logic as a list comprehension.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def filter_link(f, s):</span><br><span class="line">        if s is Link.empty:</span><br><span class="line">            return s</span><br><span class="line">        else:</span><br><span class="line">            filtered &#x3D; filter_link(f, s.rest)</span><br><span class="line">            if f(s.first):</span><br><span class="line">                return Link(s.first, filtered)</span><br><span class="line">            else:</span><br><span class="line">                return filtered</span><br><span class="line">&gt;&gt;&gt; odd &#x3D; lambda x: x % 2 &#x3D;&#x3D; 1</span><br><span class="line">&gt;&gt;&gt; map_link(square, filter_link(odd, s))</span><br><span class="line">Link(9, Link(25))</span><br><span class="line">&gt;&gt;&gt; [square(x) for x in [3, 4, 5] if odd(x)]</span><br><span class="line">[9, 25]</span><br></pre></td></tr></table></figure>
<p>The <code>join_link</code> function recursively constructs a string that contains the elements of a linked list seperated by some <code>separator</code> string. The result is much more compact than the output of <code>link_expression</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def join_link(s, separator):</span><br><span class="line">        if s is Link.empty:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        elif s.rest is Link.empty:</span><br><span class="line">            return str(s.first)</span><br><span class="line">        else:</span><br><span class="line">            return str(s.first) + separator + join_link(s.rest, separator)</span><br><span class="line">&gt;&gt;&gt; join_link(s, &quot;, &quot;)</span><br><span class="line">&#39;3, 4, 5&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Recursive Construction.</strong> Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.</p>
<p>The <code>count_partitions</code> function from Chapter 1 counted the number of ways to partition an integer <code>n</code>using parts up to size <code>m</code> via a tree-recursive process. With sequences, we can also enumerate these partitions explicitly using a similar process.</p>
<p>We follow the same recursive analysis of the problem as we did while counting: partitioning <code>n</code> using integers up to <code>m</code> involves either</p>
<ol>
<li>partitioning <code>n-m</code> using integers up to <code>m</code>, or</li>
<li>partitioning <code>n</code> using integers up to <code>m-1</code>.</li>
</ol>
<p>For base cases, we find that 0 has an empty partition, while partitioning a negative integer or using parts smaller than 1 is impossible.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def partitions(n, m):</span><br><span class="line">        &quot;&quot;&quot;Return a linked list of partitions of n using parts of up to m.</span><br><span class="line">        Each partition is represented as a linked list.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return Link(Link.empty) # A list containing the empty partition</span><br><span class="line">        elif n &lt; 0 or m &#x3D;&#x3D; 0:</span><br><span class="line">            return Link.empty</span><br><span class="line">        else:</span><br><span class="line">            using_m &#x3D; partitions(n-m, m)</span><br><span class="line">            with_m &#x3D; map_link(lambda s: Link(m, s), using_m)</span><br><span class="line">            without_m &#x3D; partitions(n, m-1)</span><br><span class="line">            return with_m + without_m</span><br></pre></td></tr></table></figure>
<p>In the recursive case, we construct two sublists of partitions. The first uses <code>m</code>, and so we add <code>m</code> to each element of the result <code>using_m</code> to form <code>with_m</code>.</p>
<p>The result of <code>partitions</code> is highly nested: a linked list of linked lists. Using <code>join_link</code> with appropriate separators, we can display the partitions in a human-readable manner.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_partitions(n, m):</span><br><span class="line">        lists &#x3D; partitions(n, m)</span><br><span class="line">        strings &#x3D; map_link(lambda s: join_link(s, &quot; + &quot;), lists)</span><br><span class="line">        print(join_link(strings, &quot;\n&quot;))</span><br><span class="line">&gt;&gt;&gt; print_partitions(6, 4)</span><br><span class="line">4 + 2</span><br><span class="line">4 + 1 + 1</span><br><span class="line">3 + 3</span><br><span class="line">3 + 2 + 1</span><br><span class="line">3 + 1 + 1 + 1</span><br><span class="line">2 + 2 + 2</span><br><span class="line">2 + 2 + 1 + 1</span><br><span class="line">2 + 1 + 1 + 1 + 1</span><br><span class="line">1 + 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>
<h3 id="2-9-2-Tree-Class"><a href="#2-9-2-Tree-Class" class="headerlink" title="2.9.2  Tree Class"></a>2.9.2  Tree Class</h3><p>Trees can also be represented by instances of user-defined classes, rather than nested instances of built-in sequence types. A tree is any data structure that has as an attribute a sequence of branches that are also trees.</p>
<p><strong>Internal values.</strong> Previously, we defined trees in such a way that all values appeared at the leaves of the tree. It is also common to define trees that have internal values at the roots of each subtree. An internal value is called an <code>label</code> in the tree. The <code>Tree</code> class below represents such trees, in which each tree has a sequence of branches that are also trees.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Tree:</span><br><span class="line">        def __init__(self, label, branches&#x3D;()):</span><br><span class="line">            self.label &#x3D; label</span><br><span class="line">            for branch in branches:</span><br><span class="line">                assert isinstance(branch, Tree)</span><br><span class="line">            self.branches &#x3D; branches</span><br><span class="line">        def __repr__(self):</span><br><span class="line">            if self.branches:</span><br><span class="line">                return &#39;Tree(&#123;0&#125;, &#123;1&#125;)&#39;.format(self.label, repr(self.branches))</span><br><span class="line">            else:</span><br><span class="line">                return &#39;Tree(&#123;0&#125;)&#39;.format(repr(self.label))</span><br><span class="line">        def is_leaf(self):</span><br><span class="line">            return not self.branches</span><br></pre></td></tr></table></figure>
<p>The <code>Tree</code> class can represent, for instance, the values computed in an expression tree for the recursive implementation of <code>fib</code>, the function for computing Fibonacci numbers. The function <code>fib_tree(n)</code> below returns a <code>Tree</code> that has the nth Fibonacci number as its <code>label</code> and a trace of all previously computed Fibonacci numbers within its branches.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib_tree(n):</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            return Tree(0)</span><br><span class="line">        elif n &#x3D;&#x3D; 2:</span><br><span class="line">            return Tree(1)</span><br><span class="line">        else:</span><br><span class="line">            left &#x3D; fib_tree(n-2)</span><br><span class="line">            right &#x3D; fib_tree(n-1)</span><br><span class="line">            return Tree(left.label + right.label, (left, right))</span><br><span class="line">&gt;&gt;&gt; fib_tree(5)</span><br><span class="line">Tree(3, (Tree(1, (Tree(0), Tree(1))), Tree(2, (Tree(1), Tree(1, (Tree(0), Tree(1)))))))</span><br></pre></td></tr></table></figure>
<p>Trees represented in this way are also processed using recursive functions. For example, we can sum the labels of a tree. As a base case, we return that an empty branch has no labels.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_labels(t):</span><br><span class="line">        &quot;&quot;&quot;Sum the labels of a Tree instance, which may be None.&quot;&quot;&quot;</span><br><span class="line">        return t.label + sum([sum_labels(b) for b in t.branches])</span><br><span class="line">&gt;&gt;&gt; sum_labels(fib_tree(5))</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>We can also apply <code>memo</code> to construct a Fibonacci tree, where repeated subtrees are only created once by the memoized version of <code>fib_tree</code>, but are used multiple times as branches of different larger trees.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib_tree &#x3D; memo(fib_tree)</span><br><span class="line">&gt;&gt;&gt; big_fib_tree &#x3D; fib_tree(35)</span><br><span class="line">&gt;&gt;&gt; big_fib_tree.label</span><br><span class="line">5702887</span><br><span class="line">&gt;&gt;&gt; big_fib_tree.branches[0] is big_fib_tree.branches[1].branches[1]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; sum_labels &#x3D; memo(sum_labels)</span><br><span class="line">&gt;&gt;&gt; sum_labels(big_fib_tree)</span><br><span class="line">142587180</span><br></pre></td></tr></table></figure>
<p>The amount of computation time and memory saved by memoization in these cases is substantial. Instead of creating 18,454,929 different instances of the <code>Tree</code> class, we now create only 35.</p>
<h3 id="2-9-3-Sets"><a href="#2-9-3-Sets" class="headerlink" title="2.9.3  Sets"></a>2.9.3  Sets</h3><p>In addition to the list, tuple, and dictionary, Python has a fourth built-in container type called a <code>set</code>. Set literals follow the mathematical notation of elements enclosed in braces. Duplicate elements are removed upon construction. Sets are unordered collections, and so the printed ordering may differ from the element ordering in the set literal.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#123;3, 2, 1, 4, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>Python sets support a variety of operations, including membership tests, length computation, and the standard set operations of union and intersection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 in s</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; s.union(&#123;1, 5&#125;)</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&gt;&gt;&gt; s.intersection(&#123;6, 5, 4, 3&#125;)</span><br><span class="line">&#123;3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>In addition to <code>union</code> and <code>intersection</code>, Python sets support several other methods. The predicates <code>isdisjoint</code>, <code>issubset</code>, and <code>issuperset</code> provide set comparison. Sets are mutable, and can be changed one element at a time using <code>add</code>, <code>remove</code>, <code>discard</code>, and <code>pop</code>. Additional methods provide multi-element mutations, such as <code>clear</code> and <code>update</code>. The Python <a href="http://docs.python.org/py3k/library/stdtypes.html#set" target="_blank" rel="noopener">documentation for sets</a> should be sufficiently intelligible at this point of the course to fill in the details.</p>
<p><strong>Implementing sets.</strong> Abstractly, a set is a collection of distinct objects that supports membership testing, union, intersection, and adjunction. Adjoining an element and a set returns a new set that contains all of the original set’s elements along with the new element, if it is distinct. Union and intersection return the set of elements that appear in either or both sets, respectively. As with any data abstraction, we are free to implement any functions over any representation of sets that provides this collection of behaviors.</p>
<p>In the remainder of this section, we consider three different methods of implementing sets that vary in their representation. We will characterize the efficiency of these different representations by analyzing the order of growth of set operations. We will use our <code>Link</code> and <code>Tree</code> classes from earlier in this section, which allow for simple and elegant recursive solutions for elementary set operations.</p>
<p><strong>Sets as unordered sequences.</strong> One way to represent a set is as a sequence in which no element appears more than once. The empty set is represented by the empty sequence. Membership testing walks recursively through the list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def empty(s):</span><br><span class="line">        return s is Link.empty</span><br><span class="line">&gt;&gt;&gt; def set_contains(s, v):</span><br><span class="line">        &quot;&quot;&quot;Return True if and only if set s contains v.&quot;&quot;&quot;</span><br><span class="line">        if empty(s):</span><br><span class="line">            return False</span><br><span class="line">        elif s.first &#x3D;&#x3D; v:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return set_contains(s.rest, v)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Link(4, Link(1, Link(5)))</span><br><span class="line">&gt;&gt;&gt; set_contains(s, 2)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; set_contains(s, 5)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>This implementation of <code>set_contains</code> requires Θ(n)Θ(n) time on average to test membership of an element, where nn is the size of the set <code>s</code>. Using this linear-time function for membership, we can adjoin an element to a set, also in linear time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def adjoin_set(s, v):</span><br><span class="line">        &quot;&quot;&quot;Return a set containing all elements of s and element v.&quot;&quot;&quot;</span><br><span class="line">        if set_contains(s, v):</span><br><span class="line">            return s</span><br><span class="line">        else:</span><br><span class="line">            return Link(v, s)</span><br><span class="line">&gt;&gt;&gt; t &#x3D; adjoin_set(s, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">Link(2, Link(4, Link(1, Link(5))))</span><br></pre></td></tr></table></figure>
<p>In designing a representation, one of the issues with which we should be concerned is efficiency. Intersecting two sets <code>set1</code> and <code>set2</code> also requires membership testing, but this time each element of <code>set1</code> must be tested for membership in <code>set2</code>, leading to a quadratic order of growth in the number of steps, Θ(n2)Θ(n2), for two sets of size nn.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def intersect_set(set1, set2):</span><br><span class="line">        &quot;&quot;&quot;Return a set containing all elements common to set1 and set2.&quot;&quot;&quot;</span><br><span class="line">        return keep_if_link(set1, lambda v: set_contains(set2, v))</span><br><span class="line">&gt;&gt;&gt; intersect_set(t, apply_to_all_link(s, square))</span><br><span class="line">Link(4, Link(1))</span><br></pre></td></tr></table></figure>
<p>When computing the union of two sets, we must be careful not to include any element twice. The <code>union_set</code> function also requires a linear number of membership tests, creating a process that also includes Θ(n2)Θ(n2) steps.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def union_set(set1, set2):</span><br><span class="line">        &quot;&quot;&quot;Return a set containing all elements either in set1 or set2.&quot;&quot;&quot;</span><br><span class="line">        set1_not_set2 &#x3D; keep_if_link(set1, lambda v: not set_contains(set2, v))</span><br><span class="line">        return extend_link(set1_not_set2, set2)</span><br><span class="line">&gt;&gt;&gt; union_set(t, s)</span><br><span class="line">Link(2, Link(4, Link(1, Link(5))))</span><br></pre></td></tr></table></figure>
<p><strong>Sets as ordered sequences.</strong> One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. To do this, we need some way to compare two objects so that we can say which is bigger. In Python, many different types of objects can be compared using <code>&lt;</code> and <code>&gt;</code> operators, but we will concentrate on numbers in this example. We will represent a set of numbers by listing its elements in increasing order.</p>
<p>One advantage of ordering shows up in <code>set_contains</code>: In checking for the presence of an object, we no longer have to scan the entire set. If we reach a set element that is larger than the item we are looking for, then we know that the item is not in the set:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_contains(s, v):</span><br><span class="line">        if empty(s) or s.first &gt; v:</span><br><span class="line">            return False</span><br><span class="line">        elif s.first &#x3D;&#x3D; v:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return set_contains(s.rest, v)</span><br><span class="line">&gt;&gt;&gt; u &#x3D; Link(1, Link(4, Link(5)))</span><br><span class="line">&gt;&gt;&gt; set_contains(u, 0)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; set_contains(u, 4)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>How many steps does this save? In the worst case, the item we are looking for may be the largest one in the set, so the number of steps is the same as for the unordered representation. On the other hand, if we search for items of many different sizes we can expect that sometimes we will be able to stop searching at a point near the beginning of the list and that other times we will still need to examine most of the list. On average we should expect to have to examine about half of the items in the set. Thus, the average number of steps required will be about n2n2. This is still Θ(n)Θ(n) growth, but it does save us some time in practice over the previous implementation.</p>
<p>We can obtain a more impressive speedup by re-implementing <code>intersect_set</code>. In the unordered representation, this operation required Θ(n2)Θ(n2) steps because we performed a complete scan of <code>set2</code> for each element of <code>set1</code>. But with the ordered representation, we can use a more clever method. We iterate through both sets simultaneously, tracking an element <code>e1</code> in <code>set1</code> and <code>e2</code> in <code>set2</code>. When <code>e1</code> and <code>e2</code> are equal, we include that element in the intersection.</p>
<p>Suppose, however, that <code>e1</code> is less than <code>e2</code>. Since <code>e2</code> is smaller than the remaining elements of <code>set2</code>, we can immediately conclude that <code>e1</code> cannot appear anywhere in the remainder of <code>set2</code> and hence is not in the intersection. Thus, we no longer need to consider <code>e1</code>; we discard it and proceed to the next element of <code>set1</code>. Similar logic advances through the elements of <code>set2</code> when <code>e2 &lt; e1</code>. Here is the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def intersect_set(set1, set2):</span><br><span class="line">        if empty(set1) or empty(set2):</span><br><span class="line">            return Link.empty</span><br><span class="line">        else:</span><br><span class="line">            e1, e2 &#x3D; set1.first, set2.first</span><br><span class="line">            if e1 &#x3D;&#x3D; e2:</span><br><span class="line">                return Link(e1, intersect_set(set1.rest, set2.rest))</span><br><span class="line">            elif e1 &lt; e2:</span><br><span class="line">                return intersect_set(set1.rest, set2)</span><br><span class="line">            elif e2 &lt; e1:</span><br><span class="line">                return intersect_set(set1, set2.rest)</span><br><span class="line">&gt;&gt;&gt; intersect_set(s, s.rest)</span><br><span class="line">Link(4, Link(5))</span><br></pre></td></tr></table></figure>
<p>To estimate the number of steps required by this process, observe that in each step we shrink the size of at least one of the sets. Thus, the number of steps required is at most the sum of the sizes of <code>set1</code> and <code>set2</code>, rather than the product of the sizes, as with the unordered representation. This is Θ(n)Θ(n) growth rather than Θ(n2)Θ(n2) — a considerable speedup, even for sets of moderate size. For example, the intersection of two sets of size 100 will take around 200 steps, rather than 10,000 for the unordered representation.</p>
<p>Adjunction and union for sets represented as ordered sequences can also be computed in linear time. These implementations are left as an exercise.</p>
<p><strong>Sets as binary search trees.</strong> We can do better than the ordered-list representation by arranging the set elements in the form of a tree with exactly two branches. The <code>entry</code> of the root of the tree holds one element of the set. The entries within the <code>left</code> branch include all elements smaller than the one at the root. Entries in the <code>right</code> branch include all elements greater than the one at the root. The figure below shows some trees that represent the set <code>{1, 3, 5, 7, 9, 11}</code>. The same set may be represented by a tree in a number of different ways. In all binary search trees, all elements in the <code>left</code> branch be smaller than the <code>entry</code> at the root, and that all elements in the <code>right</code> subtree be larger.</p>
<p><img src="http://composingprograms.com/img/set_trees.png" alt="img"></p>
<p>The advantage of the tree representation is this: Suppose we want to check whether a value <code>v</code> is contained in a set. We begin by comparing <code>v</code> with <code>entry</code>. If <code>v</code> is less than this, we know that we need only search the <code>left</code> subtree; if <code>v</code> is greater, we need only search the <code>right</code> subtree. Now, if the tree is “balanced,” each of these subtrees will be about half the size of the original. Thus, in one step we have reduced the problem of searching a tree of size nn to searching a tree of size n2n2. Since the size of the tree is halved at each step, we should expect that the number of steps needed to search a tree grows as Θ(logn)Θ(log⁡n). For large sets, this will be a significant speedup over the previous representations. This <code>set_contains</code> function exploits the ordering structure of the tree-structured set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_contains(s, v):</span><br><span class="line">        if s is None:</span><br><span class="line">            return False</span><br><span class="line">        elif s.entry &#x3D;&#x3D; v:</span><br><span class="line">            return True</span><br><span class="line">        elif s.entry &lt; v:</span><br><span class="line">            return set_contains(s.right, v)</span><br><span class="line">        elif s.entry &gt; v:</span><br><span class="line">            return set_contains(s.left, v)</span><br></pre></td></tr></table></figure>
<p>Adjoining an item to a set is implemented similarly and also requires Θ(logn)Θ(log⁡n) steps. To adjoin a value <code>v</code>, we compare <code>v</code> with <code>entry</code> to determine whether <code>v</code> should be added to the <code>right</code> or to the <code>left</code> branch, and having adjoined <code>v</code> to the appropriate branch we piece this newly constructed branch together with the original <code>entry</code> and the other branch. If <code>v</code> is equal to the <code>entry</code>, we just return the node. If we are asked to adjoin <code>v</code> to an empty tree, we generate a <code>Tree</code> that has <code>v</code> as the <code>entry</code> and empty <code>right</code> and <code>left</code> branches. Here is the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def adjoin_set(s, v):</span><br><span class="line">        if s is None:</span><br><span class="line">            return Tree(v)</span><br><span class="line">        elif s.entry &#x3D;&#x3D; v:</span><br><span class="line">            return s</span><br><span class="line">        elif s.entry &lt; v:</span><br><span class="line">            return Tree(s.entry, s.left, adjoin_set(s.right, v))</span><br><span class="line">        elif s.entry &gt; v:</span><br><span class="line">            return Tree(s.entry, adjoin_set(s.left, v), s.right)</span><br><span class="line">&gt;&gt;&gt; adjoin_set(adjoin_set(adjoin_set(None, 2), 3), 1)</span><br><span class="line">Tree(2, Tree(1), Tree(3))</span><br></pre></td></tr></table></figure>
<p>Our claim that searching the tree can be performed in a logarithmic number of steps rests on the assumption that the tree is “balanced,” i.e., that the left and the right subtree of every tree have approximately the same number of elements, so that each subtree contains about half the elements of its parent. But how can we be certain that the trees we construct will be balanced? Even if we start with a balanced tree, adding elements with <code>adjoin_set</code> may produce an unbalanced result. Since the position of a newly adjoined element depends on how the element compares with the items already in the set, we can expect that if we add elements “randomly” the tree will tend to be balanced on the average.</p>
<p>But this is not a guarantee. For example, if we start with an empty set and adjoin the numbers 1 through 7 in sequence we end up with a highly unbalanced tree in which all the left subtrees are empty, so it has no advantage over a simple ordered list. One way to solve this problem is to define an operation that transforms an arbitrary tree into a balanced tree with the same elements. We can perform this transformation after every few <code>adjoin_set</code> operations to keep our set in balance.</p>
<p>Intersection and union operations can be performed on tree-structured sets in linear time by converting them to ordered lists and back. The details are left as an exercise.</p>
<p><strong>Python set implementation.</strong> The <code>set</code> type that is built into Python does not use any of these representations internally. Instead, Python uses a representation that gives constant-time membership tests and adjoin operations based on a technique called <em>hashing</em>, which is a topic for another course. Built-in Python sets cannot contain mutable data types, such as lists, dictionaries, or other sets. To allow for nested sets, Python also includes a built-in immutable <code>frozenset</code> class that shares methods with the <code>set</code> class but excludes mutation methods and operators.</p>
<h1 id="Chapter-3-Interpreting-Computer-Programs"><a href="#Chapter-3-Interpreting-Computer-Programs" class="headerlink" title="Chapter 3: Interpreting Computer Programs"></a>Chapter 3: Interpreting Computer Programs</h1><h2 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1  Introduction"></a>3.1  Introduction</h2><p>Chapters 1 and 2 describe the close connection between two fundamental elements of programming: functions and data. We saw how functions can be manipulated as data using higher-order functions. We also saw how data can be endowed with behavior using message passing and an object system. We have also studied techniques for organizing large programs, such as functional abstraction, data abstraction, class inheritance, and generic functions. These core concepts constitute a strong foundation upon which to build modular, maintainable, and extensible programs.</p>
<p>This chapter focuses on the third fundamental element of programming: programs themselves. A Python program is just a collection of text. Only through the process of interpretation do we perform any meaningful computation based on that text. A programming language like Python is useful because we can define an <em>interpreter</em>, a program that carries out Python’s evaluation and execution procedures. It is no exaggeration to regard this as the most fundamental idea in programming, that an interpreter, which determines the meaning of expressions in a programming language, is just another program.</p>
<p>To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others.</p>
<h3 id="3-1-1-Programming-Languages"><a href="#3-1-1-Programming-Languages" class="headerlink" title="3.1.1  Programming Languages"></a>3.1.1  Programming Languages</h3><p>Programming languages vary widely in their syntactic structures, features, and domain of application. Among general purpose programming languages, the constructs of function definition and function application are pervasive. On the other hand, powerful languages exist that do not include an object system, higher-order functions, assignment, or even control constructs such as <code>while</code> and <code>for</code>statements. As an example of a powerful language with a minimal set of features, we will introduce the <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language" target="_blank" rel="noopener">Scheme</a>) programming language. The subset of Scheme introduced in this text does not allow mutable values at all.</p>
<p>In this chapter, we study the design of interpreters and the computational processes that they create when executing programs. The prospect of designing an interpreter for a general programming language may seem daunting. After all, interpreters are programs that can carry out any possible computation, depending on their input. However, many interpreters have an elegant common structure: two mutually recursive functions. The first evaluates expressions in environments; the second applies functions to arguments.</p>
<p>These functions are recursive in that they are defined in terms of each other: applying a function requires evaluating the expressions in its body, while evaluating an expression may involve applying one or more functions.</p>
<h2 id="3-2-Functional-Programming"><a href="#3-2-Functional-Programming" class="headerlink" title="3.2  Functional Programming"></a>3.2  Functional Programming</h2><p>The software running on any modern computer is written in a variety of programming languages. There are physical languages, such as the machine languages for particular computers. These languages are concerned with the representation of data and control in terms of individual bits of storage and primitive machine instructions. The machine-language programmer is concerned with using the given hardware to erect systems and utilities for the efficient implementation of resource-limited computations. High-level languages, erected on a machine-language substrate, hide concerns about the representation of data as collections of bits and the representation of programs as sequences of primitive instructions. These languages have means of combination and abstraction, such as function definition, that are appropriate to the larger-scale organization of software systems.</p>
<p>In this section, we introduce a high-level programming language that encourages a functional style. Our object of study, a subset of the Scheme language, employs a very similar model of computation to Python’s, but uses only expressions (no statements), specializes in symbolic computation, and employs only immutable values.</p>
<p>Scheme is a dialect of <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language" target="_blank" rel="noopener">Lisp</a>), the second-oldest programming language that is still widely used today (after <a href="http://en.wikipedia.org/wiki/Fortran" target="_blank" rel="noopener">Fortran</a>). The community of Lisp programmers has continued to thrive for decades, and new dialects of Lisp such as <a href="http://en.wikipedia.org/wiki/Clojure" target="_blank" rel="noopener">Clojure</a> have some of the fastest growing communities of developers of any modern programming language. To follow along with the examples in this text, you can <a href="http://inst.eecs.berkeley.edu/~scheme/" target="_blank" rel="noopener">download a Scheme interpreter</a>.</p>
<h3 id="3-2-1-Expressions"><a href="#3-2-1-Expressions" class="headerlink" title="3.2.1  Expressions"></a>3.2.1  Expressions</h3><p>Scheme programs consist of expressions, which are either call expressions or special forms. A call expression consists of an operator expression followed by zero or more operand sub-expressions, as in Python. Both the operator and operand are contained within parentheses:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(quotient 10 2)</span><br></pre></td></tr></table></figure>
<p>5</p>
<p>Scheme exclusively uses prefix notation. Operators are often symbols, such as <code>+</code> and <code>*</code>. Call expressions can be nested, and they may span more than one line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(+ (* 3 5) (- 10 6))</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(+ (* 3</span><br><span class="line">      (+ (* 2 4)</span><br><span class="line">         (+ 3 5)))</span><br><span class="line">   (+ (- 10 7)</span><br><span class="line">      6))</span><br></pre></td></tr></table></figure>
<p>57</p>
<p>As in Python, Scheme expressions may be primitives or combinations. Number literals are primitives, while call expressions are combined forms that include arbitrary sub-expressions. The evaluation procedure of call expressions matches that of Python: first the operator and operand expressions are evaluated, and then the function that is the value of the operator is applied to the arguments that are the values of the operands.</p>
<p>The <code>if</code> expression in Scheme is a <em>special form</em>, meaning that while it looks syntactically like a call expression, it has a different evaluation procedure. The general form of an <code>if</code> expression is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)</span><br></pre></td></tr></table></figure>
<p>To evaluate an <code>if</code> expression, the interpreter starts by evaluating the <code>part of the expression. If the</code> evaluates to a true value, the interpreter then evaluates the <code>and returns its value. Otherwise it evaluates the</code> and returns its value.</p>
<p>Numerical values can be compared using familiar comparison operators, but prefix notation is used in this case as well:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(&gt;&#x3D; 2 1)</span><br></pre></td></tr></table></figure>
<p>true</p>
<p>The boolean values <code>#t</code> (or <code>true</code>) and <code>#f</code> (or <code>false</code>) in Scheme can be combined with boolean special forms, which have evaluation procedures similar to those in Python.</p>
<blockquote>
<ul>
<li><code>(and  ... )</code> The interpreter evaluates the expressions <code>one at a time, in left-to-right order. If any</code> evaluates to <code>false</code>, the value of the <code>and</code> expression is <code>false</code>, and the rest of the <code>&#39;s are not evaluated. If all</code>‘s evaluate to true values, the value of the <code>and</code>expression is the value of the last one.</li>
<li><code>(or  ... )</code> The interpreter evaluates the expressions <code>one at a time, in left-to-right order. If any</code> evaluates to a true value, that value is returned as the value of the <code>or</code>expression, and the rest of the <code>&#39;s are not evaluated. If all</code>‘s evaluate to <code>false</code>, the value of the <code>or</code> expression is <code>false</code>.</li>
<li><code>(not )</code> The value of a not expression is <code>true</code> when the expression <code>` evaluates to</code>false<code>, and</code>false` otherwise.</li>
</ul>
</blockquote>
<h3 id="3-2-2-Definitions"><a href="#3-2-2-Definitions" class="headerlink" title="3.2.2  Definitions"></a>3.2.2  Definitions</h3><p>Values can be named using the <code>define</code> special form:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define pi 3.14)</span><br><span class="line">(* pi 2)</span><br></pre></td></tr></table></figure>
<p>6.28</p>
<p>New functions (called <em>procedures</em> in Scheme) can be defined using a second version of the <code>define</code>special form. For example, to define squaring, we write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (square x) (* x x))</span><br></pre></td></tr></table></figure>
<p>The general form of a procedure definition is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>
<p>The <code>is a symbol to be associated with the procedure definition in the environment. The</code> are the names used within the body of the procedure to refer to the corresponding arguments of the procedure. The <code>is an expression that will yield the value of the procedure application when the formal parameters are replaced by the actual arguments to which the procedure is applied. The</code> and the `` are grouped within parentheses, just as they would be in an actual call to the procedure being defined.</p>
<p>Having defined square, we can now use it in call expressions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(square 21)</span><br></pre></td></tr></table></figure>
<p>441</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(square (+ 2 5))</span><br></pre></td></tr></table></figure>
<p>49</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(square (square 3))</span><br></pre></td></tr></table></figure>
<p>81</p>
<p>User-defined functions can take multiple arguments and include special forms:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (average x y)</span><br><span class="line">  (&#x2F; (+ x y) 2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(average 1 3)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (abs x)</span><br><span class="line">    (if (&lt; x 0)</span><br><span class="line">        (- x)</span><br><span class="line">        x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(abs -3)</span><br></pre></td></tr></table></figure>
<p>3</p>
<p>Scheme supports local definitions with the same lexical scoping rules as Python. Below, we define an iterative procedure for computing square roots using nested definitions and recursion:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (sqrt x)</span><br><span class="line">  (define (good-enough? guess)</span><br><span class="line">    (&lt; (abs (- (square guess) x)) 0.001))</span><br><span class="line">  (define (improve guess)</span><br><span class="line">    (average guess (&#x2F; x guess)))</span><br><span class="line">  (define (sqrt-iter guess)</span><br><span class="line">    (if (good-enough? guess)</span><br><span class="line">        guess</span><br><span class="line">        (sqrt-iter (improve guess))))</span><br><span class="line">  (sqrt-iter 1.0))</span><br><span class="line">(sqrt 9)</span><br></pre></td></tr></table></figure>
<p>3.00009155413138</p>
<p>Anonymous functions are created using the <code>lambda</code> special form. <code>Lambda</code> is used to create procedures in the same way as <code>define</code>, except that no name is specified for the procedure:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure>
<p>The resulting procedure is just as much a procedure as one that is created using <code>define</code>. The only difference is that it has not been associated with any name in the environment. In fact, the following expressions are equivalent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (plus4 x) (+ x 4))</span><br><span class="line">(define plus4 (lambda (x) (+ x 4)))</span><br></pre></td></tr></table></figure>
<p>Like any expression that has a procedure as its value, a lambda expression can be used as the operator in a call expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">((lambda (x y z) (+ x y (square z))) 1 2 3)</span><br></pre></td></tr></table></figure>
<p>12</p>
<h3 id="3-2-3-Compound-values"><a href="#3-2-3-Compound-values" class="headerlink" title="3.2.3  Compound values"></a>3.2.3  Compound values</h3><p>Pairs are built into the Scheme language. For historical reasons, pairs are created with the <code>cons</code> built-in function, and the elements of a pair are accessed with <code>car</code> and <code>cdr</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define x (cons 1 2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>(1 . 2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(car x)</span><br></pre></td></tr></table></figure>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cdr x)</span><br></pre></td></tr></table></figure>
<p>2</p>
<p>Recursive lists are also built into the language, using pairs. A special value denoted <code>nil</code> or <code>&#39;()</code> represents the empty list. A recursive list value is rendered by placing its elements within parentheses, separated by spaces:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cons 1</span><br><span class="line">      (cons 2</span><br><span class="line">            (cons 3</span><br><span class="line">                  (cons 4 nil))))</span><br></pre></td></tr></table></figure>
<p>(1 2 3 4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(list 1 2 3 4)</span><br></pre></td></tr></table></figure>
<p>(1 2 3 4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define one-through-four (list 1 2 3 4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(car one-through-four)</span><br></pre></td></tr></table></figure>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cdr one-through-four)</span><br></pre></td></tr></table></figure>
<p>(2 3 4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(car (cdr one-through-four))</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cons 10 one-through-four)</span><br></pre></td></tr></table></figure>
<p>(10 1 2 3 4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cons 5 one-through-four)</span><br></pre></td></tr></table></figure>
<p>(5 1 2 3 4)</p>
<p>Whether a list is empty can be determined using the primitive <code>null?</code> predicate. Using it, we can define the standard sequence operations for computing <code>length</code> and selecting elements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (length items)</span><br><span class="line">  (if (null? items)</span><br><span class="line">      0</span><br><span class="line">      (+ 1 (length (cdr items)))))</span><br><span class="line">(define (getitem items n)</span><br><span class="line">  (if (&#x3D; n 0)</span><br><span class="line">      (car items)</span><br><span class="line">      (getitem (cdr items) (- n 1))))</span><br><span class="line">(define squares (list 1 4 9 16 25))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(length squares)</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(getitem squares 3)</span><br></pre></td></tr></table></figure>
<p>16</p>
<h3 id="3-2-4-Symbolic-Data"><a href="#3-2-4-Symbolic-Data" class="headerlink" title="3.2.4  Symbolic Data"></a>3.2.4  Symbolic Data</h3><p>All the compound data objects we have used so far were constructed ultimately from numbers. One of Scheme’s strengths is working with arbitrary symbols as data.</p>
<p>In order to manipulate symbols we need a new element in our language: the ability to <em>quote</em> a data object. Suppose we want to construct the list <code>(a b)</code>. We can’t accomplish this with <code>(list a b)</code>, because this expression constructs a list of the values of <code>a</code> and <code>b</code> rather than the symbols themselves. In Scheme, we refer to the symbols <code>a</code> and <code>b</code> rather than their values by preceding them with a single quotation mark:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define a 1)</span><br><span class="line">(define b 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(list a b)</span><br></pre></td></tr></table></figure>
<p>(1 2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(list &#39;a &#39;b)</span><br></pre></td></tr></table></figure>
<p>(a b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(list &#39;a b)</span><br></pre></td></tr></table></figure>
<p>(a 2)</p>
<p>In Scheme, any expression that is not evaluated is said to be <em>quoted</em>. This notion of quotation is derived from a classic philosophical distinction between a thing, such as a dog, which runs around and barks, and the word “dog” that is a linguistic construct for designating such things. When we use “dog” in quotation marks, we do not refer to some dog in particular but instead to a word. In language, quotation allow us to talk about language itself, and so it is in Scheme:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(list &#39;define &#39;list)</span><br></pre></td></tr></table></figure>
<p>(define list)</p>
<p>Quotation also allows us to type in compound objects, using the conventional printed representation for lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(car &#39;(a b c))</span><br></pre></td></tr></table></figure>
<p>a</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cdr &#39;(a b c))</span><br></pre></td></tr></table></figure>
<p>(b c)</p>
<p>The full Scheme language contains additional features, such as mutation operations, vectors, and maps. However, the subset we have introduced so far provides a rich functional programming language capable of implementing many of the ideas we have discussed so far in this text.</p>
<h3 id="3-2-5-Turtle-graphics"><a href="#3-2-5-Turtle-graphics" class="headerlink" title="3.2.5  Turtle graphics"></a>3.2.5  Turtle graphics</h3><p>The implementation of Scheme that serves as a companion to this text includes Turtle graphics, an illustrating environment developed as part of the Logo language (another Lisp dialect). This turtle begins in the center of a canvas, moves and turns based on procedures, and draws lines behind it as it moves. While the turtle was invented to engage children in the act of programming, it remains an engaging graphical tool for even advanced programmers.</p>
<p>At any moment during the course of executing a Scheme program, the turtle has a position and heading on the canvas. Single-argument procedures such as <code>forward</code> and <code>right</code> change the position and heading of the turtle. Common procedures have abbreviations: <code>forward</code> can also be called as <code>fd</code>, etc. The <code>begin</code> special form in Scheme allows a single expression to include multiple sub-expressions. This form is useful for issuing multiple commands:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; (define (repeat k fn) (if (&gt; k 0)</span><br><span class="line">                            (begin (fn) (repeat (- k 1) fn))</span><br><span class="line">                            nil))</span><br><span class="line">&gt; (repeat 5</span><br><span class="line">          (lambda () (fd 100)</span><br><span class="line">                     (repeat 5</span><br><span class="line">                             (lambda () (fd 20) (rt 144)))</span><br><span class="line">                     (rt 144)))</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p><img src="http://composingprograms.com/img/star.png" alt="img"></p>
<p>The full repertoire of Turtle procedures is also built into Python as the <a href="http://docs.python.org/py3k/library/turtle.html" target="_blank" rel="noopener">turtle library module</a>.</p>
<p>As a final example, Scheme can express recursive drawings using its turtle graphics in a remarkably compact form. Sierpinski’s triangle is a fractal that draws each triangle as three neighboring triangles that have vertexes at the midpoints of the legs of the triangle that contains them. It can be drawn to a finite recursive depth by this Scheme program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; (define (repeat k fn)</span><br><span class="line">    (if (&gt; k 0)</span><br><span class="line">        (begin (fn) (repeat (- k 1) fn))</span><br><span class="line">        nil))</span><br><span class="line"></span><br><span class="line">&gt; (define (tri fn)</span><br><span class="line">    (repeat 3 (lambda () (fn) (lt 120))))</span><br><span class="line"></span><br><span class="line">&gt; (define (sier d k)</span><br><span class="line">    (tri (lambda ()</span><br><span class="line">           (if (&#x3D; k 1) (fd d) (leg d k)))))</span><br><span class="line"></span><br><span class="line">&gt; (define (leg d k)</span><br><span class="line">    (sier (&#x2F; d 2) (- k 1))</span><br><span class="line">    (penup)</span><br><span class="line">    (fd d)</span><br><span class="line">    (pendown))</span><br></pre></td></tr></table></figure>
<p>The <code>triangle</code> procedure is a general method for repeating a drawing procedure three times with a left turn following each repetition. The <code>sier</code> procedure takes a length <code>d</code> and a recursive depth <code>k</code>. It draws a plain triangle if the depth is 1, and otherwise draws a triangle made up of calls to <code>leg</code>. The <code>leg</code> procedure draws a single leg of a recursive Sierpinski triangle by a recursive call to <code>sier</code> that fills the first half of the length of the leg, then by moving the turtle to the next vertex. The procedures <code>penup</code> and <code>pendown</code> stop the turtle from drawing as it moves by lifting its pen up and the placing it down again. The mutual recursion between <code>sier</code> and <code>leg</code> yields this result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (sier 400 6)</span><br></pre></td></tr></table></figure>
<p><img src="http://composingprograms.com/img/sier.png" alt="img"></p>
<h2 id="3-3-Exceptions"><a href="#3-3-Exceptions" class="headerlink" title="3.3  Exceptions"></a>3.3  Exceptions</h2><p>Programmers must be always mindful of possible errors that may arise in their programs. Examples abound: a function may not receive arguments that it is designed to accept, a necessary resource may be missing, or a connection across a network may be lost. When designing a program, one must anticipate the exceptional circumstances that may arise and take appropriate measures to handle them.</p>
<p>There is no single correct approach to handling errors in a program. Programs designed to provide some persistent service like a web server should be robust to errors, logging them for later consideration but continuing to service new requests as long as possible. On the other hand, the Python interpreter handles errors by terminating immediately and printing an error message, so that programmers can address issues as soon as they arise. In any case, programmers must make conscious choices about how their programs should react to exceptional conditions.</p>
<p><em>Exceptions</em>, the topic of this section, provides a general mechanism for adding error-handling logic to programs. <em>Raising an exception</em> is a technique for interrupting the normal flow of execution in a program, signaling that some exceptional circumstance has arisen, and returning directly to an enclosing part of the program that was designated to react to that circumstance. The Python interpreter raises an exception each time it detects an error in an expression or statement. Users can also raise exceptions with <code>raise</code> and <code>assert</code> statements.</p>
<p><strong>Raising exceptions.</strong> An exception is a object instance with a class that inherits, either directly or indirectly, from the <code>BaseException</code> class. The <code>assert</code> statement introduced in Chapter 1 raises an exception with the class <code>AssertionError</code>. In general, any exception instance can be raised with the <code>raise</code> statement. The general form of raise statements are described in the <a href="http://docs.python.org/py3k/reference/simple_stmts.html#raise" target="_blank" rel="noopener">Python docs</a>. The most common use of <code>raise</code> constructs an exception instance and raises it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise Exception(&#39;An error occurred&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">Exception: an error occurred</span><br></pre></td></tr></table></figure>
<p>When an exception is raised, no further statements in the current block of code are executed. Unless the exception is <em>handled</em> (described below), the interpreter will return directly to the interactive read-eval-print loop, or terminate entirely if Python was started with a file argument. In addition, the interpreter will print a <em>stack backtrace</em>, which is a structured block of text that describes the nested set of active function calls in the branch of execution in which the exception was raised. In the example above, the file name `` indicates that the exception was raised by the user in an interactive session, rather than from code in a file.</p>
<p><strong>Handling exceptions.</strong> An exception can be handled by an enclosing <code>try</code> statement. A <code>try</code> statement consists of multiple clauses; the first begins with <code>try</code> and the rest begin with <code>except</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;try suite&gt;</span><br><span class="line">except &lt;exception class&gt; as &lt;name&gt;:</span><br><span class="line">    &lt;except suite&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The <code>is always executed immediately when the `try` statement is executed. Suites of the `except` clauses are only executed when an exception is raised during the course of executing the</code>. Each <code>except</code> clause specifies the particular class of exception to handle. For instance, if the <code>is `AssertionError`, then any instance of a class inheriting from `AssertionError` that is raised during the course of executing the</code> will be handled by the following <code>. Within the</code>, the identifier <code>is bound to the exception object that was raised, but this binding does not persist beyond the</code>.</p>
<p>For example, we can handle a <code>ZeroDivisionError</code> exception using a <code>try</code> statement that binds the name <code>x</code> to 0 when the exception is raised.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        x &#x3D; 1&#x2F;0</span><br><span class="line">    except ZeroDivisionError as e:</span><br><span class="line">        print(&#39;handling a&#39;, type(e))</span><br><span class="line">        x &#x3D; 0</span><br><span class="line">handling a &lt;class &#39;ZeroDivisionError&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>A <code>try</code> statement will handle exceptions that occur within the body of a function that is applied (either directly or indirectly) within the <code>. When an exception is raised, control jumps directly to the body of the</code> of the most recent <code>try</code> statement that handles that type of exception.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def invert(x):</span><br><span class="line">        result &#x3D; 1&#x2F;x  # Raises a ZeroDivisionError if x is 0</span><br><span class="line">        print(&#39;Never printed if x is 0&#39;)</span><br><span class="line">        return result</span><br><span class="line">&gt;&gt;&gt; def invert_safe(x):</span><br><span class="line">        try:</span><br><span class="line">            return invert(x)</span><br><span class="line">        except ZeroDivisionError as e:</span><br><span class="line">            return str(e)</span><br><span class="line">&gt;&gt;&gt; invert_safe(2)</span><br><span class="line">Never printed if x is 0</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; invert_safe(0)</span><br><span class="line">&#39;division by zero&#39;</span><br></pre></td></tr></table></figure>
<p>This example illustrates that the <code>print</code> expression in <code>invert</code> is never evaluated, and instead control is transferred to the suite of the <code>except</code> clause in <code>invert_safe</code>. Coercing the <code>ZeroDivisionError</code> <code>e</code> to a string gives the human-interpretable string returned by <code>invert_safe</code>: <code>&#39;division by zero&#39;</code>.</p>
<h3 id="3-3-1-Exception-Objects"><a href="#3-3-1-Exception-Objects" class="headerlink" title="3.3.1  Exception Objects"></a>3.3.1  Exception Objects</h3><p>Exception objects themselves can have attributes, such as the error message stated in an <code>assert</code>statement and information about where in the course of execution the exception was raised. User-defined exception classes can have additional attributes.</p>
<p>In Chapter 1, we implemented Newton’s method to find the zeros of arbitrary functions. The following example defines an exception class that returns the best guess discovered in the course of iterative improvement whenever a <code>ValueError</code> occurs. A math domain error (a type of <code>ValueError</code>) is raised when <code>sqrt</code> is applied to a negative number. This exception is handled by raising an <code>IterImproveError</code> that stores the most recent guess from Newton’s method as an attribute.</p>
<p>First, we define a new class that inherits from <code>Exception</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class IterImproveError(Exception):</span><br><span class="line">        def __init__(self, last_guess):</span><br><span class="line">            self.last_guess &#x3D; last_guess</span><br></pre></td></tr></table></figure>
<p>Next, we define a version of <code>improve</code>, our generic iterative improvement algorithm. This version handles any <code>ValueError</code> by raising an <code>IterImproveError</code> that stores the most recent guess. As before, <code>improve</code>takes as arguments two functions, each of which takes a single numerical argument. The <code>update</code>function returns new guesses, while the <code>done</code> function returns a boolean indicating that improvement has converged to a correct value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def improve(update, done, guess&#x3D;1, max_updates&#x3D;1000):</span><br><span class="line">        k &#x3D; 0</span><br><span class="line">        try:</span><br><span class="line">            while not done(guess) and k &lt; max_updates:</span><br><span class="line">                guess &#x3D; update(guess)</span><br><span class="line">                k &#x3D; k + 1</span><br><span class="line">            return guess</span><br><span class="line">        except ValueError:</span><br><span class="line">            raise IterImproveError(guess)</span><br></pre></td></tr></table></figure>
<p>Finally, we define <code>find_zero</code>, which returns the result of <code>improve</code> applied to a Newton update function returned by <code>newton_update</code>, which is defined in Chapter 1 and requires no changes for this example. This version of <code>find_zero</code> handles an <code>IterImproveError</code> by returning its last guess.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def find_zero(f, guess&#x3D;1):</span><br><span class="line">        def done(x):</span><br><span class="line">            return f(x) &#x3D;&#x3D; 0</span><br><span class="line">        try:</span><br><span class="line">            return improve(newton_update(f), done, guess)</span><br><span class="line">        except IterImproveError as e:</span><br><span class="line">            return e.last_guess</span><br></pre></td></tr></table></figure>
<p>Consider applying <code>find_zero</code> to find the zero of the function 2x2+x√2x2+x. This function has a zero at 0, but evaluating it on any negative number will raise a <code>ValueError</code>. Our Chapter 1 implementation of Newton’s Method would raise that error and fail to return any guess of the zero. Our revised implementation returns the last guess found before the error.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import sqrt</span><br><span class="line">&gt;&gt;&gt; find_zero(lambda x: 2*x*x + sqrt(x))</span><br><span class="line">-0.030211203830201594</span><br></pre></td></tr></table></figure>
<p>Although this approximation is still far from the correct answer of 0, some applications would prefer this coarse approximation to a <code>ValueError</code>.</p>
<p>Exceptions are another technique that help us as programs to separate the concerns of our program into modular parts. In this example, Python’s exception mechanism allowed us to separate the logic for iterative improvement, which appears unchanged in the suite of the <code>try</code> clause, from the logic for handling errors, which appears in <code>except</code> clauses. We will also find that exceptions are a useful feature when implementing interpreters in Python.</p>
<h2 id="3-4-Interpreters-for-Languages-with-Combination"><a href="#3-4-Interpreters-for-Languages-with-Combination" class="headerlink" title="3.4  Interpreters for Languages with Combination"></a>3.4  Interpreters for Languages with Combination</h2><p>We now embark on a tour of the technology by which languages are established in terms of other languages. <em>Metalinguistic abstraction</em> — establishing new languages — plays an important role in all branches of engineering design. It is particularly important to computer programming, because in programming not only can we formulate new languages but we can also implement these languages by constructing interpreters. An interpreter for a programming language is a function that, when applied to an expression of the language, performs the actions required to evaluate that expression.</p>
<p>We will first define an interpreter for a language that is a limited subset of Scheme, called Calculator. Then, we will develop a sketch of an interpreter for Scheme as a whole. The interpreter we create will be complete in the sense that it will allow us to write fully general programs in Scheme. To do so, it will implement the same environment model of evaluation that we introduced for Python programs in Chapter 1.</p>
<p>Many of the examples in this section are contained in the companion <a href="http://composingprograms.com/examples/scalc/scalc.html" target="_blank" rel="noopener">Scheme-Syntax Calculator example</a>, as they are too complex to fit naturally in the format of this text.</p>
<h3 id="3-4-1-A-Scheme-Syntax-Calculator"><a href="#3-4-1-A-Scheme-Syntax-Calculator" class="headerlink" title="3.4.1  A Scheme-Syntax Calculator"></a>3.4.1  A Scheme-Syntax Calculator</h3><p>The Scheme-Syntax Calculator (or simply Calculator) is an expression language for the arithmetic operations of addition, subtraction, multiplication, and division. Calculator shares Scheme’s call expression syntax and operator behavior. Addition (<code>+</code>) and multiplication (<code>*</code>) operations each take an arbitrary number of arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; (+ 1 2 3 4)</span><br><span class="line">10</span><br><span class="line">&gt; (+)</span><br><span class="line">0</span><br><span class="line">&gt; (* 1 2 3 4)</span><br><span class="line">24</span><br><span class="line">&gt; (*)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Subtraction (<code>-</code>) has two behaviors. With one argument, it negates the argument. With at least two arguments, it subtracts all but the first from the first. Division (<code>/</code>) has a similar pair of two behaviors: compute the multiplicative inverse of a single argument or divide all but the first into the first:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; (- 10 1 2 3)</span><br><span class="line">4</span><br><span class="line">&gt; (- 3)</span><br><span class="line">-3</span><br><span class="line">&gt; (&#x2F; 15 12)</span><br><span class="line">1.25</span><br><span class="line">&gt; (&#x2F; 30 5 2)</span><br><span class="line">3</span><br><span class="line">&gt; (&#x2F; 10)</span><br><span class="line">0.1</span><br></pre></td></tr></table></figure>
<p>A call expression is evaluated by evaluating its operand sub-expressions, then applying the operator to the resulting arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (- 100 (* 7 (+ 8 (&#x2F; -12 -3))))</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure>
<p>We will implement an interpreter for the Calculator language in Python. That is, we will write a Python program that takes string lines as input and returns the result of evaluating those lines as a Calculator expression. Our interpreter will raise an appropriate exception if the calculator expression is not well formed.</p>
<h3 id="3-4-2-Expression-Trees"><a href="#3-4-2-Expression-Trees" class="headerlink" title="3.4.2  Expression Trees"></a>3.4.2  Expression Trees</h3><p>Until this point in the course, expression trees have been conceptual entities to which we have referred in describing the process of evaluation; we have never before explicitly represented expression trees as data in our programs. In order to write an interpreter, we must operate on expressions as data.</p>
<p>A primitive expression is just a number or a string in Calculator: either an <code>int</code> or <code>float</code> or an operator symbol. All combined expressions are call expressions. A call expression is a Scheme list with a first element (the operator) followed by zero or more operand expressions.</p>
<p><strong>Scheme Pairs.</strong> In Scheme, lists are nested pairs, but not all pairs are lists. To represent Scheme pairs and lists in Python, we will define a class <code>Pair</code> that is similar to the <code>Rlist</code> class earlier in the chapter. The implementation appears in <a href="http://composingprograms.com/examples/scalc/scheme_reader.py.html" target="_blank" rel="noopener">scheme_reader</a>.</p>
<p>The empty list is represented by an object called <code>nil</code>, which is an instance of the class <code>nil</code>. We assume that only one <code>nil</code> instance will ever be created.</p>
<p>The <code>Pair</code> class and <code>nil</code> object are Scheme values represented in Python. They have <code>repr</code> strings that are Python expressions and <code>str</code> strings that are Scheme expressions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">(1 2)</span><br></pre></td></tr></table></figure>
<p>They implement the basic Python sequence interface of length and element selection, as well as a <code>map</code>method that returns a Scheme list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; s[1]</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(s.map(lambda x: x+4))</span><br><span class="line">(5 6)</span><br></pre></td></tr></table></figure>
<p><strong>Nested Lists.</strong> Nested pairs can represent lists, but the elements of a list can also be lists themselves. Pairs are therefore sufficient to represent Scheme expressions, which are in fact nested lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; expr &#x3D; Pair(&#39;+&#39;, Pair(Pair(&#39;*&#39;, Pair(3, Pair(4, nil))), Pair(5, nil)))</span><br><span class="line">&gt;&gt;&gt; print(expr)</span><br><span class="line">(+ (* 3 4) 5)</span><br><span class="line">&gt;&gt;&gt; print(expr.second.first)</span><br><span class="line">(* 3 4)</span><br><span class="line">&gt;&gt;&gt; expr.second.first.second.first</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>This example demonstrates that all Calculator expressions are nested Scheme lists. Our Calculator interpreter will read in nested Scheme lists, convert them into expression trees represented as nested <code>Pair</code> instances (<em>Parsing expressions</em> below), and then evaluate the expression trees to produce values (<em>Calculator evaluation</em> below).</p>
<h3 id="3-4-3-Parsing-Expressions"><a href="#3-4-3-Parsing-Expressions" class="headerlink" title="3.4.3  Parsing Expressions"></a>3.4.3  Parsing Expressions</h3><p>Parsing is the process of generating expression trees from raw text input. A parser is a composition of two components: a lexical analyzer and a syntactic analyzer. First, the <em>lexical analyzer</em> partitions the input string into <em>tokens</em>, which are the minimal syntactic units of the language such as names and symbols. Second, the <em>syntactic analyzer</em> constructs an expression tree from this sequence of tokens. The sequence of tokens produced by the lexical analyzer is consumed by the syntactic analyzer.</p>
<p><strong>Lexical analysis.</strong> The component that interprets a string as a token sequence is called a <em>tokenizer</em> or <em>lexical analyzer</em>. In our implementation, the tokenizer is a function called <code>tokenize_line</code> in <a href="http://composingprograms.com/examples/scalc/scheme_tokens.py.html" target="_blank" rel="noopener">scheme_tokens</a>. Scheme tokens are delimited by white space, parentheses, dots, or single quotation marks. Delimiters are tokens, as are symbols and numerals. The tokenizer analyzes a line character by character, validating the format of symbols and numerals.</p>
<p>Tokenizing a well-formed Calculator expression separates all symbols and delimiters, but identifies multi-character numbers (e.g., 2.3) and converts them into numeric types.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tokenize_line(&#39;(+ 1 (* 2.3 45))&#39;)</span><br><span class="line">[&#39;(&#39;, &#39;+&#39;, 1, &#39;(&#39;, &#39;*&#39;, 2.3, 45, &#39;)&#39;, &#39;)&#39;]</span><br></pre></td></tr></table></figure>
<p>Lexical analysis is an iterative process, and it can be applied to each line of an input program in isolation.</p>
<p><strong>Syntactic analysis.</strong> The component that interprets a token sequence as an expression tree is called a <em>syntactic analyzer</em>. Syntactic analysis is a tree-recursive process, and it must consider an entire expression that may span multiple lines.</p>
<p>Syntactic analysis is implemented by the <code>scheme_read</code> function in <a href="http://composingprograms.com/examples/scalc/scheme_reader.py.html" target="_blank" rel="noopener">scheme_reader</a>. It is tree-recursive because analyzing a sequence of tokens often involves analyzing a subsequence of those tokens into a subexpression, which itself serves as a branch (e.g., operand) of a larger expression tree. Recursion generates the hierarchical structures consumed by the evaluator.</p>
<p>The <code>scheme_read</code> function expects its input <code>src</code> to be a <code>Buffer</code> instance that gives access to a sequence of tokens. A <code>Buffer</code>, defined in the <a href="http://composingprograms.com/examples/scalc/buffer.py.html" target="_blank" rel="noopener">buffer</a> module, collects tokens that span multiple lines into a single object that can be analyzed syntactically.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lines &#x3D; [&#39;(+ 1&#39;, &#39;   (* 2.3 45))&#39;]</span><br><span class="line">&gt;&gt;&gt; expression &#x3D; scheme_read(Buffer(tokenize_lines(lines)))</span><br><span class="line">&gt;&gt;&gt; expression</span><br><span class="line">Pair(&#39;+&#39;, Pair(1, Pair(Pair(&#39;*&#39;, Pair(2.3, Pair(45, nil))), nil)))</span><br><span class="line">&gt;&gt;&gt; print(expression)</span><br><span class="line">(+ 1 (* 2.3 45))</span><br></pre></td></tr></table></figure>
<p>The <code>scheme_read</code> function first checks for various base cases, including empty input (which raises an end-of-file exception, called <code>EOFError</code> in Python) and primitive expressions. A recursive call to <code>read_tail</code>is invoked whenever a <code>(</code> token indicates the beginning of a list.</p>
<p>The <code>read_tail</code> function continues to read from the same input <code>src</code>, but expects to be called after a list has begun. Its base cases are an empty input (an error) or a closing parenthesis that terminates the list. Its recursive call reads the first element of the list with <code>scheme_read</code>, reads the rest of the list with <code>read_tail</code>, and then returns a list represented as a <code>Pair</code>.</p>
<p>This implementation of <code>scheme_read</code> can read well-formed Scheme lists, which are all we need for the Calculator language. Parsing dotted lists and quoted forms is left as an exercise.</p>
<p>Informative syntax errors improve the usability of an interpreter substantially. The <code>SyntaxError</code> exceptions that are raised include a description of the problem encountered.</p>
<h3 id="3-4-4-Calculator-Evaluation"><a href="#3-4-4-Calculator-Evaluation" class="headerlink" title="3.4.4  Calculator Evaluation"></a>3.4.4  Calculator Evaluation</h3><p>The <a href="http://composingprograms.com/examples/scalc/scalc.py.html" target="_blank" rel="noopener">scalc</a> module implements an evaluator for the Calculator language. The <code>calc_eval</code> function takes an expression as an argument and returns its value. Definitions of the helper functions <code>simplify</code>, <code>reduce</code>, and <code>as_scheme_list</code> appear in the model and are used below.</p>
<p>For Calculator, the only two legal syntactic forms of expressions are numbers and call expressions, which are <code>Pair</code> instances representing well-formed Scheme lists. Numbers are <em>self-evaluating</em>; they can be returned directly from <code>calc_eval</code>. Call expressions require function application.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def calc_eval(exp):</span><br><span class="line">        &quot;&quot;&quot;Evaluate a Calculator expression.&quot;&quot;&quot;</span><br><span class="line">        if type(exp) in (int, float):</span><br><span class="line">            return simplify(exp)</span><br><span class="line">        elif isinstance(exp, Pair):</span><br><span class="line">            arguments &#x3D; exp.second.map(calc_eval)</span><br><span class="line">            return simplify(calc_apply(exp.first, arguments))</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(exp + &#39; is not a number or call expression&#39;)</span><br></pre></td></tr></table></figure>
<p>Call expressions are evaluated by first recursively mapping the <code>calc_eval</code> function to the list of operands, which computes a list of <code>arguments</code>. Then, the operator is applied to those arguments in a second function, <code>calc_apply</code>.</p>
<p>The Calculator language is simple enough that we can easily express the logic of applying each operator in the body of a single function. In <code>calc_apply</code>, each conditional clause corresponds to applying one operator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def calc_apply(operator, args):</span><br><span class="line">        &quot;&quot;&quot;Apply the named operator to a list of args.&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(operator, str):</span><br><span class="line">            raise TypeError(str(operator) + &#39; is not a symbol&#39;)</span><br><span class="line">        if operator &#x3D;&#x3D; &#39;+&#39;:</span><br><span class="line">            return reduce(add, args, 0)</span><br><span class="line">        elif operator &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">            if len(args) &#x3D;&#x3D; 0:</span><br><span class="line">                raise TypeError(operator + &#39; requires at least 1 argument&#39;)</span><br><span class="line">            elif len(args) &#x3D;&#x3D; 1:</span><br><span class="line">                return -args.first</span><br><span class="line">            else:</span><br><span class="line">                return reduce(sub, args.second, args.first)</span><br><span class="line">        elif operator &#x3D;&#x3D; &#39;*&#39;:</span><br><span class="line">            return reduce(mul, args, 1)</span><br><span class="line">        elif operator &#x3D;&#x3D; &#39;&#x2F;&#39;:</span><br><span class="line">            if len(args) &#x3D;&#x3D; 0:</span><br><span class="line">                raise TypeError(operator + &#39; requires at least 1 argument&#39;)</span><br><span class="line">            elif len(args) &#x3D;&#x3D; 1:</span><br><span class="line">                return 1&#x2F;args.first</span><br><span class="line">            else:</span><br><span class="line">                return reduce(truediv, args.second, args.first)</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(operator + &#39; is an unknown operator&#39;)</span><br></pre></td></tr></table></figure>
<p>Above, each suite computes the result of a different operator or raises an appropriate <code>TypeError</code> when the wrong number of arguments is given. The <code>calc_apply</code> function can be applied directly, but it must be passed a list of <em>values</em> as arguments rather than a list of operand expressions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc_apply(&#39;+&#39;, as_scheme_list(1, 2, 3))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; calc_apply(&#39;-&#39;, as_scheme_list(10, 1, 2, 3))</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; calc_apply(&#39;*&#39;, nil)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; calc_apply(&#39;*&#39;, as_scheme_list(1, 2, 3, 4, 5))</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; calc_apply(&#39;&#x2F;&#39;, as_scheme_list(40, 5))</span><br><span class="line">8.0</span><br></pre></td></tr></table></figure>
<p>The role of <code>calc_eval</code> is to make proper calls to <code>calc_apply</code> by first computing the value of operand sub-expressions before passing them as arguments to <code>calc_apply</code>. Thus, <code>calc_eval</code> can accept a nested expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(exp)</span><br><span class="line">(+ (* 3 4) 5)</span><br><span class="line">&gt;&gt;&gt; calc_eval(exp)</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<p>The structure of <code>calc_eval</code> is an example of dispatching on type: the form of the expression. The first form of expression is a number, which requires no additional evaluation step. In general, primitive expressions that do not require an additional evaluation step are called <em>self-evaluating</em>. The only self-evaluating expressions in our Calculator language are numbers, but a general programming language might also include strings, boolean values, etc.</p>
<p><strong>Read-eval-print loops.</strong> A typical approach to interacting with an interpreter is through a read-eval-print loop, or REPL, which is a mode of interaction that reads an expression, evaluates it, and prints the result for the user. The Python interactive session is an example of such a loop.</p>
<p>An implementation of a REPL can be largely independent of the interpreter it uses. The function <code>read_eval_print_loop</code> below buffers input from the user, constructs an expression using the language-specific <code>scheme_read</code> function, then prints the result of applying <code>calc_eval</code> to that expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def read_eval_print_loop():</span><br><span class="line">        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span><br><span class="line">        while True:</span><br><span class="line">            src &#x3D; buffer_input()</span><br><span class="line">            while src.more_on_line:</span><br><span class="line">                expression &#x3D; scheme_read(src)</span><br><span class="line">                print(calc_eval(expression))</span><br></pre></td></tr></table></figure>
<p>This version of <code>read_eval_print_loop</code> contains all of the essential components of an interactive interface. An example session would look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; (* 1 2 3)</span><br><span class="line">6</span><br><span class="line">&gt; (+)</span><br><span class="line">0</span><br><span class="line">&gt; (+ 2 (&#x2F; 4 8))</span><br><span class="line">2.5</span><br><span class="line">&gt; (+ 2 2) (* 3 3)</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">&gt; (+ 1</span><br><span class="line">     (- 23)</span><br><span class="line">     (* 4 2.5))</span><br><span class="line">-12</span><br></pre></td></tr></table></figure>
<p>This loop implementation has no mechanism for termination or error handling. We can improve the interface by reporting errors to the user. We can also allow the user to exit the loop by signalling a keyboard interrupt (<code>Control-C</code> on UNIX) or end-of-file exception (<code>Control-D</code> on UNIX). To enable these improvements, we place the original suite of the <code>while</code> statement within a <code>try</code> statement. The first <code>except</code>clause handles <code>SyntaxError</code> and <code>ValueError</code> exceptions raised by <code>scheme_read</code> as well as <code>TypeError</code> and <code>ZeroDivisionError</code> exceptions raised by <code>calc_eval</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def read_eval_print_loop():</span><br><span class="line">        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                src &#x3D; buffer_input()</span><br><span class="line">                while src.more_on_line:</span><br><span class="line">                    expression &#x3D; scheme_read(src)</span><br><span class="line">                    print(calc_eval(expression))</span><br><span class="line">            except (SyntaxError, TypeError, ValueError, ZeroDivisionError) as err:</span><br><span class="line">                print(type(err).__name__ + &#39;:&#39;, err)</span><br><span class="line">            except (KeyboardInterrupt, EOFError):  # &lt;Control&gt;-D, etc.</span><br><span class="line">                print(&#39;Calculation completed.&#39;)</span><br><span class="line">                return</span><br></pre></td></tr></table></figure>
<p>This loop implementation reports errors without exiting the loop. Rather than exiting the program on an error, restarting the loop after an error message lets users revise their expressions. Upon importing the <code>readline</code> module, users can even recall their previous inputs using the up arrow or <code>Control-P</code>. The final result provides an informative error reporting interface:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; )</span><br><span class="line">SyntaxError: unexpected token: )</span><br><span class="line">&gt; 2.3.4</span><br><span class="line">ValueError: invalid numeral: 2.3.4</span><br><span class="line">&gt; +</span><br><span class="line">TypeError: + is not a number or call expression</span><br><span class="line">&gt; (&#x2F; 5)</span><br><span class="line">TypeError: &#x2F; requires exactly 2 arguments</span><br><span class="line">&gt; (&#x2F; 1 0)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>As we generalize our interpreter to new languages other than Calculator, we will see that the <code>read_eval_print_loop</code> is parameterized by a parsing function, an evaluation function, and the exception types handled by the <code>try</code> statement. Beyond these changes, all REPLs can be implemented using the same structure.</p>
<h2 id="3-5-Interpreters-for-Languages-with-Abstraction"><a href="#3-5-Interpreters-for-Languages-with-Abstraction" class="headerlink" title="3.5  Interpreters for Languages with Abstraction"></a>3.5  Interpreters for Languages with Abstraction</h2><p>The Calculator language provides a means of combination through nested call expressions. However, there is no way to define new operators, give names to values, or express general methods of computation. Calculator does not support abstraction in any way. As a result, it is not a particularly powerful or general programming language. We now turn to the task of defining a general programming language that supports abstraction by binding names to values and defining new operations.</p>
<p>Unlike the previous section, which presented a complete interpreter as Python source code, this section takes a descriptive approach. The companion project asks you to implement the ideas presented here by building a fully functional Scheme interpreter.</p>
<h3 id="3-5-1-Structure"><a href="#3-5-1-Structure" class="headerlink" title="3.5.1  Structure"></a>3.5.1  Structure</h3><p>This section describes the general structure of a Scheme interpreter. Completing that project will produce a working implementation of the interpreter described here.</p>
<p>An interpreter for Scheme can share much of the same structure as the Calculator interpreter. A parser produces an expression that is interpreted by an evaluator. The evaluation function inspects the form of an expression, and for call expressions it calls a function to apply a procedure to some arguments. Much of the difference in evaluators is associated with special forms, user-defined functions, and implementing the environment model of computation.</p>
<p><strong>Parsing.</strong> The <a href="http://composingprograms.com/examples/scalc/scheme_reader.py.html" target="_blank" rel="noopener">scheme_reader</a> and <a href="http://composingprograms.com/examples/scalc/scheme_tokens.py.html" target="_blank" rel="noopener">scheme_tokens</a> modules from the Calculator interpreter are nearly sufficient to parse any valid Scheme expression. However, it does not yet support quotation or dotted lists. A full Scheme interpreter should be able to parse the following input expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; read_line(&quot;(car &#39;(1 . 2))&quot;)</span><br><span class="line">Pair(&#39;car&#39;, Pair(Pair(&#39;quote&#39;, Pair(Pair(1, 2), nil)), nil))</span><br></pre></td></tr></table></figure>
<p>Your first task in implementing the Scheme interpreter will be to extend <a href="http://composingprograms.com/examples/scalc/scheme_reader.py.html" target="_blank" rel="noopener">scheme_reader</a> to correctly parse dotted lists and quotation.</p>
<p><strong>Evaluation.</strong> Scheme is evaluated one expression at a time. A skeleton implementation of the evaluator is defined in <code>scheme.py</code> of the companion project. Each expression returned from <code>scheme_read</code> is passed to the <code>scheme_eval</code> function, which evaluates an expression <code>expr</code> in the current environment <code>env</code>.</p>
<p>The <code>scheme_eval</code> function evaluates the different forms of expressions in Scheme: primitives, special forms, and call expressions. The form of a combination in Scheme can be determined by inspecting its first element. Each special form has its own evaluation rule. A simplified implementation of <code>scheme_eval</code>appears below. Some error checking and special form handling has been removed in order to focus our discussion. A complete implementation appears in the companion project.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def scheme_eval(expr, env):</span><br><span class="line">        &quot;&quot;&quot;Evaluate Scheme expression expr in environment env.&quot;&quot;&quot;</span><br><span class="line">        if scheme_symbolp(expr):</span><br><span class="line">            return env[expr]</span><br><span class="line">        elif scheme_atomp(expr):</span><br><span class="line">            return expr</span><br><span class="line">        first, rest &#x3D; expr.first, expr.second</span><br><span class="line">        if first &#x3D;&#x3D; &quot;lambda&quot;:</span><br><span class="line">            return do_lambda_form(rest, env)</span><br><span class="line">        elif first &#x3D;&#x3D; &quot;define&quot;:</span><br><span class="line">            do_define_form(rest, env)</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            procedure &#x3D; scheme_eval(first, env)</span><br><span class="line">            args &#x3D; rest.map(lambda operand: scheme_eval(operand, env))</span><br><span class="line">            return scheme_apply(procedure, args, env)</span><br></pre></td></tr></table></figure>
<p><strong>Procedure application.</strong> The final case above invokes a second process, procedure application, that is implemented by the function <code>scheme_apply</code>. The procedure application process in Scheme is considerably more general than the <code>calc_apply</code> function in Calculator. It applies two kinds of arguments: a <code>PrimtiveProcedure</code> or a <code>LambdaProcedure</code>. A <code>PrimitiveProcedure</code> is implemented in Python; it has an instance attribute <code>fn</code> that is bound to a Python function. In addition, it may or may not require access to the current environment. This Python function is called whenever the procedure is applied.</p>
<p>A <code>LambdaProcedure</code> is implemented in Scheme. It has a <code>body</code> attribute that is a Scheme expression, evaluated whenever the procedure is applied. To apply the procedure to a list of arguments, the body expression is evaluated in a new environment. To construct this environment, a new frame is added to the environment, in which the formal parameters of the procedure are bound to the arguments. The body is evaluated using <code>scheme_eval</code>.</p>
<p><strong>Eval/apply recursion.</strong> The functions that implement the evaluation process, <code>scheme_eval</code> and <code>scheme_apply</code>, are mutually recursive. Evaluation requires application whenever a call expression is encountered. Application uses evaluation to evaluate operand expressions into arguments, as well as to evaluate the body of user-defined procedures. The general structure of this mutually recursive process appears in interpreters quite generally: evaluation is defined in terms of application and application is defined in terms of evaluation.</p>
<p>This recursive cycle ends with language primitives. Evaluation has a base case that is evaluating a primitive expression. Some special forms also constitute base cases without recursive calls. Function application has a base case that is applying a primitive procedure. This mutually recursive structure, between an eval function that processes expression forms and an apply function that processes functions and their arguments, constitutes the essence of the evaluation process.</p>
<h3 id="3-5-2-Environments"><a href="#3-5-2-Environments" class="headerlink" title="3.5.2  Environments"></a>3.5.2  Environments</h3><p>Now that we have described the structure of our Scheme interpreter, we turn to implementing the <code>Frame</code>class that forms environments. Each <code>Frame</code> instance represents an environment in which symbols are bound to values. A frame has a dictionary of <code>bindings</code>, as well as a <code>parent</code> frame that is <code>None</code> for the global frame.</p>
<p>Bindings are not accessed directly, but instead through two <code>Frame</code> methods: <code>lookup</code> and <code>define</code>. The first implements the look-up procedure of the environment model of computation described in Chapter 1. A symbol is matched against the <code>bindings</code> of the current frame. If it is found, the value to which it is bound is returned. If it is not found, look-up proceeds to the <code>parent</code> frame. On the other hand, the <code>define</code>method always binds a symbol to a value in the current frame.</p>
<p>The implementation of <code>lookup</code> and the use of <code>define</code> are left as exercises. As an illustration of their use, consider the following example Scheme program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (factorial n)</span><br><span class="line">  (if (&#x3D; n 0) 1 (* n (factorial (- n 1)))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(factorial 5)</span><br></pre></td></tr></table></figure>
<p>120</p>
<p>The first input expression is a <code>define</code> special form, evaluated by the <code>do_define_form</code> Python function. Defining a function has several steps:</p>
<ol>
<li>Check the format of the expression to ensure that it is a well-formed Scheme list with at least two elements following the keyword <code>define</code>.</li>
<li>Analyze the first element, in this case a <code>Pair</code>, to find the function name <code>factorial</code> and formal parameter list <code>(n)</code>.</li>
<li>Create a <code>LambdaProcedure</code> with the supplied formal parameters, body, and parent environment.</li>
<li>Bind the symbol <code>factorial</code> to this function, in the first frame of the current environment. In this case, the environment consists only of the global frame.</li>
</ol>
<p>The second input is a call expression. The <code>procedure</code> passed to <code>scheme_apply</code> is the <code>LambdaProcedure</code>just created and bound to the symbol <code>factorial</code>. The <code>args</code> passed is a one-element Scheme list <code>(5)</code>. To apply the procedure, a new frame is created that extends the global frame (the parent environment of the <code>factorial</code> procedure). In this frame, the symbol <code>n</code> is bound to the value 5. Then, the body of <code>factorial</code>is evaluated in that environment, and its value is returned.</p>
<h3 id="3-5-3-Data-as-Programs"><a href="#3-5-3-Data-as-Programs" class="headerlink" title="3.5.3  Data as Programs"></a>3.5.3  Data as Programs</h3><p>In thinking about a program that evaluates Scheme expressions, an analogy might be helpful. One operational view of the meaning of a program is that a program is a description of an abstract machine. For example, consider again this procedure to compute factorials:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(define (factorial n)</span><br><span class="line">  (if (&#x3D; n 0) 1 (* n (factorial (- n 1)))))</span><br></pre></td></tr></table></figure>
<p>We could express an equivalent program in Python as well, using a conditional expression.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def factorial(n):</span><br><span class="line">        return 1 if n &#x3D;&#x3D; 1 else n * factorial(n - 1)</span><br></pre></td></tr></table></figure>
<p>We may regard this program as the description of a machine containing parts that decrement, multiply, and test for equality, together with a two-position switch and another factorial machine. (The factorial machine is infinite because it contains another factorial machine within it.) The figure below is a flow diagram for the factorial machine, showing how the parts are wired together.</p>
<p><img src="http://composingprograms.com/img/factorial_machine.png" alt="img"></p>
<p>In a similar way, we can regard the Scheme interpreter as a very special machine that takes as input a description of a machine. Given this input, the interpreter configures itself to emulate the machine described. For example, if we feed our evaluator the definition of factorial the evaluator will be able to compute factorials.</p>
<p>From this perspective, our Scheme interpreter is seen to be a universal machine. It mimics other machines when these are described as Scheme programs. It acts as a bridge between the data objects that are manipulated by our programming language and the programming language itself. Image that a user types a Scheme expression into our running Scheme interpreter. From the perspective of the user, an input expression such as <code>(+ 2 2)</code> is an expression in the programming language, which the interpreter should evaluate. From the perspective of the Scheme interpreter, however, the expression is simply a sentence of words that is to be manipulated according to a well-defined set of rules.</p>
<p>That the user’s programs are the interpreter’s data need not be a source of confusion. In fact, it is sometimes convenient to ignore this distinction, and to give the user the ability to explicitly evaluate a data object as an expression. In Scheme, we use this facility whenever employing the <code>run</code> procedure. Similar functions exist in Python: the <code>eval</code> function will evaluate a Python expression and the <code>exec</code>function will execute a Python statement. Thus,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&#39;2+2&#39;)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>and</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2+2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>both return the same result. Evaluating expressions that are constructed as a part of execution is a common and powerful feature in dynamic programming languages. In few languages is this practice as common as in Scheme, but the ability to construct and evaluate expressions during the course of execution of a program can prove to be a valuable tool for any programmer.</p>
<h3 id="3-5-4-Macros"><a href="#3-5-4-Macros" class="headerlink" title="3.5.4  Macros"></a>3.5.4  Macros</h3><p>Scheme combinations are represented as Scheme lists. The expression <code>(+ 2 x)</code> is a three-element list containing the symbol <code>+</code>, the number 2, and the symbol <code>x</code>. Likewise, the expression <code>(map abs &#39;(-1 -2))</code>is a three-element list containing the symbol <code>map</code>, the symbol <code>abs</code>, and a list containing -1 and -2.</p>
<p>Because expressions in the language are structured data, it is convenient to write Scheme expressions that build other Scheme expressions. Scheme programs are just lists of expressions, and so it is possible to write programs that output and even execute other programs.</p>
<p>The fact that expressions are lists allows us to use list manipulation procedures, such as <code>list</code>, <code>cons</code>, <code>car</code>, and <code>cdr</code>, to construct expressions. The built-in <code>eval</code> procedure allows a constructed expression to be evaluated.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(cons &#39;+ (list 1 2))</span><br></pre></td></tr></table></figure>
<p>(+ 1 2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(eval (cons &#39;+ (list 1 2)))</span><br></pre></td></tr></table></figure>
<p>3</p>
<p>Macros are procedures that take expressions as input and return Scheme expressions as output. Macros exist in many programming languages but are particularly powerful in Scheme and other Lisp dialects because Scheme expressions are lists, and Scheme has good built-in procedures for manipulating lists. In Scheme, there are several different built-in special forms related to macros, but this text will focus on just one: <code>define-macro</code>.</p>
<p>The <code>define-macro</code> special form is similar to the <code>define</code> special form used to create user-defined procedures.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define-macro (twice f) (list &#39;begin f f))</span><br></pre></td></tr></table></figure>
<p>Evaluating this <code>define-macro</code> expression creates a new macro and binds it to the name <code>twice</code> in the first frame of the current environment. A macro is called like a procedure using a call expression, but the evaluation procedure for macro call expressions is different from the regular procedure for call expressions.</p>
<p>To evaluate a macro call expression, such as <code>(twice (print 2))</code>, Scheme does the following:</p>
<ol>
<li>Evaluate the operator sub-expression, which evaluates to a macro.</li>
<li>Apply the macro procedure on the operands <em>without</em> evaluating the operands first.</li>
<li>Evaluate the expression returned from the macro procedure.</li>
</ol>
<p>For example, calling <code>(twice (print 2))</code> will pass the expression <code>(print 2)</code>, which is a two-element list containing the symbol <code>print</code> and the number 2, as an argument to <code>twice</code>. Evaluating the body of <code>twice</code>in an environment in which <code>f</code> is bound to <code>(print 2)</code> creates the expression <code>(begin (print 2) (print 2))</code>, which is then evaluated. Evaluating this output expression displays 2 twice. Hence, this macro evaluates its operand twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(twice-macro (print 2))</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="3-5-5-Quasiquotation"><a href="#3-5-5-Quasiquotation" class="headerlink" title="3.5.5  Quasiquotation"></a>3.5.5  Quasiquotation</h3><p>In Scheme, a <em>quote</em> prevents an expression from being evaluated. It’s possible to use the symbol <code>quote</code>or its syntactic abbreviation, an apostrophe. Both of the expressions below evaluate to the three-element list <code>(+ x y)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(quote (+ x y))</span><br><span class="line">&#39;(+ x y)</span><br></pre></td></tr></table></figure>
<p>Similarly, a <em>quasiquote</em>, denoted using a backtick symbol, prevents an expression from being evaluated. However, parts of that expression can be <em>unquoted</em>, denoted using a comma, and those unquoted parts are evaluated. Suppose <code>b</code> is bound to 10.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define b 10)</span><br></pre></td></tr></table></figure>
<p>Quoting or quasiquoting the expression <code>(+ a b)</code> will evaluate to this three-element list, which contains the symbols <code>a</code> and <code>b</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;(+ a b)</span><br><span class="line">&#96;(+ a b)</span><br></pre></td></tr></table></figure>
<p>In the final example below, <code>b</code> is unquoted and therefore evaluated, while the whole list remains quoted, and so no addition is performed. Instead, the expression evaluates to the list <code>(+ a 10)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;(+ ,b c)</span><br></pre></td></tr></table></figure>
<p>With quasiquotes and unquotes, it is often the case that a macro definition requires less work to express. For example, we can simplify <code>twice-macro</code> from the previous section as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define-macro (twice f) &#96;(begin ,f ,f))</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-4-Data-Processing"><a href="#Chapter-4-Data-Processing" class="headerlink" title="Chapter 4: Data Processing"></a>Chapter 4: Data Processing</h1><h2 id="4-1-Introduction"><a href="#4-1-Introduction" class="headerlink" title="4.1  Introduction"></a>4.1  Introduction</h2><p>Modern computers can process vast amounts of data representing many aspects of the world. From these big data sets, we can learn about human behavior in unprecedented ways: how language is used, what photos are taken, what topics are discussed, and how people engage with their surroundings. To process large data sets efficiently, programs are organized into pipelines of manipulations on sequential streams of data. In this chapter, we consider a suite of techniques process and manipulate sequential data streams efficiently.</p>
<p>In Chapter 2, we introduced a sequence interface, implemented in Python by built-in data types such as <code>list</code> and <code>range</code>. In this chapter, we extend the concept of sequential data to include collections that have unbounded or even infinite size. Two mathematical examples of infinite sequences are the positive integers and the Fibonacci numbers. Sequential data sets of unbounded length also appear in other computational domains. For instance, the sequence of telephone calls sent through a cell tower, the sequence of mouse movements made by a computer user, and the sequence of acceleration measurements from sensors on an aircraft all continue to grow as the world evolves.</p>
<h2 id="4-2-Implicit-Sequences"><a href="#4-2-Implicit-Sequences" class="headerlink" title="4.2  Implicit Sequences"></a>4.2  Implicit Sequences</h2><p>A sequence can be represented without each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing the value of each element in advance. Instead, we compute elements on demand.</p>
<p>An example of this idea arises in the <code>range</code> container type introduced in Chapter 2. A <code>range</code> represents a consecutive, bounded sequence of integers. However, it is not the case that each element of that sequence is represented explicitly in memory. Instead, when an element is requested from a <code>range</code>, it is computed. Hence, we can represent very large ranges of integers without using large blocks of memory. Only the end points of the range are stored as part of the <code>range</code> object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; range(10000, 1000000000)</span><br><span class="line">&gt;&gt;&gt; r[45006230]</span><br><span class="line">45016230</span><br></pre></td></tr></table></figure>
<p>In this example, not all 999,990,000 integers in this range are stored when the range instance is constructed. Instead, the range object adds the first element 10,000 to the index 45,006,230 to produce the element 45,016,230. Computing values on demand, rather than retrieving them from an existing representation, is an example of <em>lazy</em> computation. In computer science, lazy computation describes any program that delays the computation of a value until that value is needed.</p>
<h3 id="4-2-1-Iterators"><a href="#4-2-1-Iterators" class="headerlink" title="4.2.1  Iterators"></a>4.2.1  Iterators</h3><p><strong>Note:</strong> This content on iterators and generators now also appears in Chapter 2.</p>
<p>Python and many other programming languages provide a unified way to process elements of a container value sequentially, called an iterator. An <em>iterator</em> is an object that provides sequential access to values, one by one.</p>
<p>The iterator abstraction has two components: a mechanism for retrieving the next element in the sequence being processed and a mechanism for signaling that the end of the sequence has been reached and no further elements remain. For any container, such as a list or range, an iterator can be obtained by calling the built-in <code>iter</code> function. The contents of the iterator can be accessed by calling the built-in <code>next</code> function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; primes &#x3D; [2, 3, 5, 7]</span><br><span class="line">&gt;&gt;&gt; type(primes)</span><br><span class="line">&lt;class &#39;list&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; iterator &#x3D; iter(primes)</span><br><span class="line">&gt;&gt;&gt; type(iterator)</span><br><span class="line">&lt;class &#39;list_iterator&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>Python signals that there are no more values available by raising a <code>StopIteration</code> exception when <code>next</code>is called. This exception can be handled using a <code>try</code> statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; next(iterator)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        next(iterator)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        print(&#39;No more values&#39;)</span><br><span class="line">No more values</span><br></pre></td></tr></table></figure>
<p>An iterator maintains local state to represent its position in a sequence. Each time <code>next</code> is called, that position advances. Two separate iterators can track two different positions in the same sequence. However, two names for the same iterator will share a position because they share the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; range(3, 13)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; iter(r)  # 1st iterator over r</span><br><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t &#x3D; iter(r)  # 2nd iterator over r</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; u &#x3D; t        # Alternate name for the 2nd iterator</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>Advancing the second iterator does not affect the first. Since the last value returned from the first iterator was 4, it is positioned to return 5 next. On the other hand, the second iterator is positioned to return 7 next.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(s)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>Calling <code>iter</code> on an iterator will return that iterator, not a copy. This behavior is included in Python so that a programmer can call <code>iter</code> on a value to get an iterator without having to worry about whether it is an iterator or a container.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; v &#x3D; iter(t)  # Another alterante name for the 2nd iterator</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; next(u)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>The usefulness of iterators is derived from the fact that the underlying series of data for an iterator may not be represented explicitly in memory. An iterator provides a mechanism for considering each of a series of values in turn, but all of those elements do not need to be stored simultaneously. Instead, when the next element is requested from an iterator, that element may be computed on demand instead of being retrieved from an existing memory source.</p>
<p>Ranges are able to compute the elements of a sequence lazily because the sequence represented is uniform, and any element is easy to compute from the starting and ending bounds of the range. Iterators allow for lazy generation of a much broader class of underlying sequential datasets because they do not need to provide access to arbitrary elements of the underlying series. Instead, iterators are only required to compute the next element of the series, in order, each time another element is requested. While not as flexible as <em>random access</em> (accessing arbitrary elements of a sequence in any order), <em>sequential access</em>to sequential data is often sufficient for data processing applications.</p>
<h3 id="4-2-2-Iterables"><a href="#4-2-2-Iterables" class="headerlink" title="4.2.2  Iterables"></a>4.2.2  Iterables</h3><p>Any value that can produce iterators is called an <em>iterable</em> value. In Python, an iterable value is anything that can be passed to the built-in <code>iter</code> function. Iterables include sequence values such as strings and tuples, as well as other containers such as sets and dictionaries. Iterators are also iterables because they can be passed to the <code>iter</code> function.</p>
<p>Even unordered collections such as dictionaries must define an ordering over their contents when they produce iterators. Dictionaries and sets are unordered because the programmer has no control over the order of iteration, but Python does guarantee certain properties about their order in its specification.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;one&#39;: 1, &#39;three&#39;: 3, &#39;two&#39;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; k &#x3D; iter(d)</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">&#39;one&#39;</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">&#39;three&#39;</span><br><span class="line">&gt;&gt;&gt; v &#x3D; iter(d.values())</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(v)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>If a dictionary changes in structure because a key is added or removed, then all iterators become invalid, and future iterators may exhibit arbitrary changes to the order of their contents. On the other hand, changing the value of an existing key does not invalidate iterators or change the order of their contents.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#39;two&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(k)</span><br><span class="line">       </span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br><span class="line">Traceback (most recent call last):</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-Built-in-Iterators"><a href="#4-2-3-Built-in-Iterators" class="headerlink" title="4.2.3  Built-in Iterators"></a>4.2.3  Built-in Iterators</h3><p>Several built-in functions take as arguments iterable values and return iterators. These functions are used extensively for lazy sequence processing.</p>
<p>The <code>map</code> function is lazy: calling it does not perform the computation required to compute elements of its result. Instead, an iterator object is created that can return results if queried using <code>next</code>. We can observe this fact in the following example, in which the call to <code>print</code> is delayed until the corresponding element is requested from the <code>doubled</code> iterator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#39;***&#39;, x, &#39;&#x3D;&gt;&#39;, 2*x, &#39;***&#39;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s &#x3D; range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled &#x3D; map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 &#x3D;&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 &#x3D;&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 &#x3D;&gt; 10 ***</span><br><span class="line">*** 6 &#x3D;&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>
<p>The <code>filter</code> function returns an iterator over a subset of the values in another iterable. The <code>zip</code> function returns an iterator over tuples of values that combine one value from each of multiple iterables.</p>
<h3 id="4-2-4-For-Statements"><a href="#4-2-4-For-Statements" class="headerlink" title="4.2.4  For Statements"></a>4.2.4  For Statements</h3><p>The <code>for</code> statement in Python operates on iterators. Objects are <em>iterable</em> (an interface) if they have an <code>__iter__</code> method that returns an <em>iterator</em>. Iterable objects can be the value of the <code>` in the header of a</code>for` statement:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &lt;name&gt; in &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>To execute a <code>for</code> statement, Python evaluates the header <code>, which must yield an iterable value. Then, the `iter` function is applied to that value. Until a `StopIteration` exception is raised, Python repeatedly calls `next` on that iterator and binds the result to the</code> in the <code>for</code> statement. Then, it executes the ``.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counts &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; for item in counts:</span><br><span class="line">        print(item)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>In the above example, the <code>for</code> statement implicitly calls <code>iter(counts)</code>, which returns an iterator over its contents. The <code>for</code> statement then calls <code>next</code> on that iterator repeatedly, and assigns the returned value to <code>item</code> each time. This process continues until the iterator raises a <code>StopIteration</code> exception, at which point execution of the <code>for</code> statement concludes.</p>
<p>With our knowledge of iterators, we can implement the execution rule of a <code>for</code> statement in terms of <code>while</code>, assignment, and <code>try</code> statements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; items &#x3D; iter(counts)</span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        while True:</span><br><span class="line">            item &#x3D; next(items)</span><br><span class="line">            print(item)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        pass</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>Above, the iterator returned by calling <code>iter</code> on <code>counts</code> is bound to a name <code>items</code> so that it can be queried for each element in turn. The handling clause for the <code>StopIteration</code> exception does nothing, but handling the exception provides a control mechanism for exiting the <code>while</code> loop.</p>
<h3 id="4-2-5-Generators"><a href="#4-2-5-Generators" class="headerlink" title="4.2.5  Generators"></a>4.2.5  Generators</h3><p>Generators allow us to define iterations over arbitrary sequences, even infinite sequences, by leveraging the features of the Python interpreter.</p>
<p>A <em>generator</em> is an iterator returned by a special class of function called a <em>generator function</em>. Generator functions are distinguished from regular functions in that rather than containing <code>return</code> statements in their body, they use <code>yield</code> statements to return elements of a series.</p>
<p>Generators do not use attributes of an object to track their progress through a series. Instead, they control the execution of the generator function, which runs until the next <code>yield</code> statement is executed each time <code>next</code> is called on the generator. For example, the <code>letters_generator</code> function below returns a generator over the letters a, b, c, and then d.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def letters_generator():</span><br><span class="line">        current &#x3D; &#39;a&#39;</span><br><span class="line">        while current &lt;&#x3D; &#39;d&#39;:</span><br><span class="line">            yield current</span><br><span class="line">            current &#x3D; chr(ord(current)+1)</span><br><span class="line">&gt;&gt;&gt; for letter in letters_generator():</span><br><span class="line">        print(letter)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p>The <code>yield</code> statement indicates that we are defining a generator function, rather than a regular function. When called, a generator function doesn’t return a particular yielded value, but instead a <code>generator</code>(which is a type of iterator) that itself can return the yielded values. Calling <code>next</code> on the generator continues execution of the generator function from wherever it left off previously until another <code>yield</code>statement is executed.</p>
<p>The first time <code>next</code> is called, the program executes statements from the body of the <code>letters_generator</code>function until it encounters the <code>yield</code> statement. Then, it pauses and returns the value of <code>current</code>. <code>yield</code>statements do not destroy the newly created environment; they preserve it for later. When <code>next</code> is called again, execution resumes where it left off. The values of <code>current</code> and of any other bound names in the scope of <code>letters_generator</code> are preserved across subsequent calls to <code>next</code>.</p>
<p>We can walk through the generator by manually calling <code>next()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; letters &#x3D; letters_generator()</span><br><span class="line">&gt;&gt;&gt; type(letters)</span><br><span class="line">&lt;class &#39;generator&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;c&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">&#39;d&#39;</span><br><span class="line">&gt;&gt;&gt; next(letters)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>The generator does not start executing any of the body statements of its generator function until the first time <code>next</code> is called. The generator raises a <code>StopIteration</code> exception whenever its generator function returns.</p>
<h3 id="4-2-6-Python-Streams"><a href="#4-2-6-Python-Streams" class="headerlink" title="4.2.6  Python Streams"></a>4.2.6  Python Streams</h3><p><em>Streams</em> offer another way to represent sequential data implicitly. A stream is a lazily computed linked list. Like the <code>Link</code> class from Chapter 2, a <code>Stream</code> instance responds to requests for its <code>first</code> element and the <code>rest</code> of the stream. Like an <code>Link</code>, the <code>rest</code> of a <code>Stream</code> is itself a <code>Stream</code>. Unlike an <code>Link</code>, the <code>rest</code> of a stream is only computed when it is looked up, rather than being stored in advance. That is, the <code>rest</code> of a stream is computed lazily.</p>
<p>To achieve this lazy evaluation, a stream stores a function that computes the rest of the stream. Whenever this function is called, its returned value is cached as part of the stream in an attribute called <code>_rest</code>, named with an underscore to indicate that it should not be accessed directly.</p>
<p>The accessible attribute <code>rest</code> is a property method that returns the rest of the stream, computing it if necessary. With this design, a stream stores <em>how to compute</em> the rest of the stream, rather than always storing the rest explicitly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Stream:</span><br><span class="line">        &quot;&quot;&quot;A lazily computed linked list.&quot;&quot;&quot;</span><br><span class="line">        class empty:</span><br><span class="line">            def __repr__(self):</span><br><span class="line">                return &#39;Stream.empty&#39;</span><br><span class="line">        empty &#x3D; empty()</span><br><span class="line">        def __init__(self, first, compute_rest&#x3D;lambda: empty):</span><br><span class="line">            assert callable(compute_rest), &#39;compute_rest must be callable.&#39;</span><br><span class="line">            self.first &#x3D; first</span><br><span class="line">            self._compute_rest &#x3D; compute_rest</span><br><span class="line">        @property</span><br><span class="line">        def rest(self):</span><br><span class="line">            &quot;&quot;&quot;Return the rest of the stream, computing it if necessary.&quot;&quot;&quot;</span><br><span class="line">            if self._compute_rest is not None:</span><br><span class="line">                self._rest &#x3D; self._compute_rest()</span><br><span class="line">                self._compute_rest &#x3D; None</span><br><span class="line">            return self._rest</span><br><span class="line">        def __repr__(self):</span><br><span class="line">            return &#39;Stream(&#123;0&#125;, &lt;...&gt;)&#39;.format(repr(self.first))</span><br></pre></td></tr></table></figure>
<p>A linked list is defined using a nested expression. For example, we can create an <code>Link</code> that represents the elements 1 then 5 as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; Link(1, Link(2+3, Link(9)))</span><br></pre></td></tr></table></figure>
<p>Likewise, we can create a <code>Stream</code> representing the same series. The <code>Stream</code> does not actually compute the second element 5 until the rest of the stream is requested. We achieve this effect by creating anonymous functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; Stream(1, lambda: Stream(2+3, lambda: Stream(9)))</span><br></pre></td></tr></table></figure>
<p>Here, 1 is the first element of the stream, and the <code>lambda</code> expression that follows returns a function for computing the rest of the stream.</p>
<p>Accessing the elements of linked list <code>r</code> and stream <code>s</code> proceed similarly. However, while 5 is stored within <code>r</code>, it is computed on demand for <code>s</code> via addition, the first time that it is requested.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.first</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; s.first</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.rest.first</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; s.rest.first</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; r.rest</span><br><span class="line">Link(5, Link(9))</span><br><span class="line">&gt;&gt;&gt; s.rest</span><br><span class="line">Stream(5, &lt;...&gt;)</span><br></pre></td></tr></table></figure>
<p>While the <code>rest</code> of <code>r</code> is a two-element linked list, the <code>rest</code> of <code>s</code> includes a function to compute the rest; the fact that it will return the empty stream may not yet have been discovered.</p>
<p>When a <code>Stream</code> instance is constructed, the field <code>self._rest</code> is <code>None</code>, signifying that the rest of the <code>Stream</code>has not yet been computed. When the <code>rest</code> attribute is requested via a dot expression, the <code>rest</code>property method is invoked, which triggers computation with <code>self._rest = self._compute_rest()</code>. Because of the caching mechanism within a <code>Stream</code>, the <code>compute_rest</code> function is only ever called once, then discarded.</p>
<p>The essential properties of a <code>compute_rest</code> function are that it takes no arguments, and it returns a <code>Stream</code> or <code>Stream.empty</code>.</p>
<p>Lazy evaluation gives us the ability to represent infinite sequential datasets using streams. For example, we can represent increasing integers, starting at any <code>first</code> value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def integer_stream(first):</span><br><span class="line">        def compute_rest():</span><br><span class="line">            return integer_stream(first+1)</span><br><span class="line">        return Stream(first, compute_rest)</span><br><span class="line">&gt;&gt;&gt; positives &#x3D; integer_stream(1)</span><br><span class="line">&gt;&gt;&gt; positives</span><br><span class="line">Stream(1, &lt;...&gt;)</span><br><span class="line">&gt;&gt;&gt; positives.first</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>When <code>integer_stream</code> is called for the first time, it returns a stream whose <code>first</code> is the first integer in the sequence. However, <code>integer_stream</code> is actually recursive because this stream’s <code>compute_rest</code> calls<code>integer_stream</code> again, with an incremented argument. We say that <code>integer_stream</code> is lazy because the recursive call to <code>integer_stream</code> is only made whenever the <code>rest</code> of an integer stream is requested.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; positives.first</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; positives.rest.first</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; positives.rest.rest</span><br><span class="line">Stream(3, &lt;...&gt;)</span><br></pre></td></tr></table></figure>
<p>The same higher-order functions that manipulate sequences — <code>map</code> and <code>filter</code> — also apply to streams, although their implementations must change to apply their argument functions lazily. The function <code>map_stream</code> maps a function over a stream, which produces a new stream. The locally defined<code>compute_rest</code> function ensures that the function will be mapped onto the rest of the stream whenever the rest is computed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def map_stream(fn, s):</span><br><span class="line">        if s is Stream.empty:</span><br><span class="line">            return s</span><br><span class="line">        def compute_rest():</span><br><span class="line">            return map_stream(fn, s.rest)</span><br><span class="line">        return Stream(fn(s.first), compute_rest)</span><br></pre></td></tr></table></figure>
<p>A stream can be filtered by defining a <code>compute_rest</code> function that applies the filter function to the rest of the stream. If the filter function rejects the first element of the stream, the rest is computed immediately. Because <code>filter_stream</code> is recursive, the rest may be computed multiple times until a valid <code>first</code> element is found.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def filter_stream(fn, s):</span><br><span class="line">        if s is Stream.empty:</span><br><span class="line">            return s</span><br><span class="line">        def compute_rest():</span><br><span class="line">            return filter_stream(fn, s.rest)</span><br><span class="line">        if fn(s.first):</span><br><span class="line">            return Stream(s.first, compute_rest)</span><br><span class="line">        else:</span><br><span class="line">            return compute_rest()</span><br></pre></td></tr></table></figure>
<p>The <code>map_stream</code> and <code>filter_stream</code> functions exhibit a common pattern in stream processing: a locally defined <code>compute_rest</code> function recursively applies a processing function to the rest of the stream whenever the rest is computed.</p>
<p>To inspect the contents of a stream, we can coerce up to the first <code>k</code> elements to a Python <code>list</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def first_k_as_list(s, k):</span><br><span class="line">        first_k &#x3D; []</span><br><span class="line">        while s is not Stream.empty and k &gt; 0:</span><br><span class="line">            first_k.append(s.first)</span><br><span class="line">            s, k &#x3D; s.rest, k-1</span><br><span class="line">        return first_k</span><br></pre></td></tr></table></figure>
<p>These convenience functions allow us to verify our <code>map_stream</code> implementation with a simple example that squares the integers from 3 to 7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; integer_stream(3)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">Stream(3, &lt;...&gt;)</span><br><span class="line">&gt;&gt;&gt; m &#x3D; map_stream(lambda x: x*x, s)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">Stream(9, &lt;...&gt;)</span><br><span class="line">&gt;&gt;&gt; first_k_as_list(m, 5)</span><br><span class="line">[9, 16, 25, 36, 49]</span><br></pre></td></tr></table></figure>
<p>We can use our <code>filter_stream</code> function to define a stream of prime numbers using the sieve of Eratosthenes, which filters a stream of integers to remove all numbers that are multiples of its first element. By successively filtering with each prime, all composite numbers are removed from the stream.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def primes(pos_stream):</span><br><span class="line">        def not_divible(x):</span><br><span class="line">            return x % pos_stream.first !&#x3D; 0</span><br><span class="line">        def compute_rest():</span><br><span class="line">            return primes(filter_stream(not_divible, pos_stream.rest))</span><br><span class="line">        return Stream(pos_stream.first, compute_rest)</span><br></pre></td></tr></table></figure>
<p>By truncating the <code>primes</code> stream, we can enumerate any prefix of the prime numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prime_numbers &#x3D; primes(integer_stream(2))</span><br><span class="line">&gt;&gt;&gt; first_k_as_list(prime_numbers, 7)</span><br><span class="line">[2, 3, 5, 7, 11, 13, 17]</span><br></pre></td></tr></table></figure>
<p>Streams contrast with iterators in that they can be passed to pure functions multiple times and yield the same result each time. The primes stream is not “used up” by converting it to a list. That is, the <code>first</code>element of <code>prime_numbers</code> is still 2 after converting the prefix of the stream to a list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prime_numbers.first</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Just as linked lists provide a simple implementation of the sequence abstraction, streams provide a simple, functional, recursive data structure that implements lazy evaluation through the use of higher-order functions.</p>
<h2 id="4-3-Declarative-Programming"><a href="#4-3-Declarative-Programming" class="headerlink" title="4.3  Declarative Programming"></a>4.3  Declarative Programming</h2><p>In addition to streams, data values are often stored in large repositories called databases. A database consists of a data store containing the data values along with an interface for retrieving and transforming those values. Each value stored in a database is called a <em>record</em>. Records with similar structure are grouped into tables. Records are retrieved and transformed using queries, which are statements in a query language. By far the most ubiquitous query language in use today is called Structured Query Language or SQL (pronounced “sequel”).</p>
<p>SQL is an example of a declarative programming language. Statements do not describe computations directly, but instead describe the desired result of some computation. It is the role of the <em>query interpreter</em>of the database system to design and perform a computational process to produce such a result.</p>
<p>This interaction differs substantially from the procedural programming paradigm of Python or Scheme. In Python, computational processes are described directly by the programmer. A declarative language abstracts away procedural details, instead focusing on the form of the result.</p>
<h3 id="4-3-1-Tables"><a href="#4-3-1-Tables" class="headerlink" title="4.3.1  Tables"></a>4.3.1  Tables</h3><p>The SQL language is standardized, but most database systems implement some custom variant of the language that is endowed with proprietary features. In this text, we will describe a small subset of SQL as it is implemented in <a href="http://sqlite.org/" target="_blank" rel="noopener">Sqlite</a>. You can follow along by <a href="http://sqlite.org/download.html" target="_blank" rel="noopener">downloading Sqlite</a> or by using this <a href="http://kripken.github.io/sql.js/GUI/" target="_blank" rel="noopener">online SQL interpreter</a>.</p>
<p>A table, also called a <em>relation</em>, has a fixed number of named and typed columns. Each row of a table represents a data record and has one value for each column. For example, a table of cities might have columns <code>latitude</code> <code>longitude</code> that both hold numeric values, as well as a column <code>name</code> that holds a string. Each row would represent a city location position by its latitude and longitude values.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Latitude</strong></th>
<th style="text-align:left"><strong>Longitude</strong></th>
<th style="text-align:left"><strong>Name</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left">122</td>
<td style="text-align:left">Berkeley</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left">71</td>
<td style="text-align:left">Cambridge</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left">93</td>
<td style="text-align:left">Minneapolis</td>
</tr>
</tbody>
</table>
</div>
<p>A table with a single row can be created in the SQL language using a <code>select</code> statement, in which the row values are separated by commas and the column names follow the keyword “as”. All SQL statements end in a semicolon.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name;</span><br><span class="line">38|122|Berkeley</span><br></pre></td></tr></table></figure>
<p>The second line is the output, which includes one line per row with columns separated by a vertical bar.</p>
<p>A multi-line table can be constructed by union, which combines the rows of two tables. The column names of the left table are used in the constructed table. Spacing within a line does not affect the result.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt; select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt; select 45,             93,               &quot;Minneapolis&quot;;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure>
<p>A table can be given a name using a <code>create table</code> statement. While this statement can also be used to create empty tables, we will focus on the form that gives a name to an existing table defined by a <code>select</code>statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table cities as</span><br><span class="line">   ...&gt;    select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt;    select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt;    select 45,             93,               &quot;Minneapolis&quot;;</span><br></pre></td></tr></table></figure>
<p>Once a table is named, that name can be used in a <code>from</code> clause within a <code>select</code> statement. All columns of a table can be displayed using the special <code>select *</code> form.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select * from cities;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-Select-Statements"><a href="#4-3-2-Select-Statements" class="headerlink" title="4.3.2  Select Statements"></a>4.3.2  Select Statements</h3><p>A <code>select</code> statement defines a new table either by listing the values in a single row or, more commonly, by projecting an existing table using a <code>from</code> clause:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select [column description] from [existing table name]</span><br></pre></td></tr></table></figure>
<p>The columns of the resulting table are described by a comma-separated list of expressions that are each evaluated for each row of the existing input table.</p>
<p>For example, we can create a two-column table that describes each city by how far north or south it is of Berkeley. Each degree of latitude measures 60 nautical miles to the north.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select name, 60*abs(latitude-38) from cities;</span><br><span class="line">Berkeley|0</span><br><span class="line">Cambridge|240</span><br><span class="line">Minneapolis|420</span><br></pre></td></tr></table></figure>
<p>Column descriptions are expressions in a language that shares many properties with Python: infix operators such as + and %, built-in functions such as <code>abs</code> and <code>round</code>, and parentheses that describe evaluation order. Names in these expressions, such as <code>latitude</code> above, evaluate to the column value in the row being projected.</p>
<p>Optionally, each expression can be followed by the keyword <code>as</code> and a column name. When the entire table is given a name, it is often helpful to give each column a name so that it can be referenced in future <code>select</code> statements. Columns described by a simple name are named automatically.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table distances as</span><br><span class="line">   ...&gt;   select name, 60*abs(latitude-38) as distance from cities;</span><br><span class="line">sqlite&gt; select distance&#x2F;5, name from distances;</span><br><span class="line">0|Berkeley</span><br><span class="line">48|Cambridge</span><br><span class="line">84|Minneapolis</span><br></pre></td></tr></table></figure>
<p><strong>Where Clauses.</strong> A <code>select</code> statement can also include a <code>where</code> clause with a filtering expression. This expression filters the rows that are projected. Only a row for which the filtering expression evaluates to a true value will be used to produce a row in the resulting table.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table cold as</span><br><span class="line">   ...&gt;   select name from cities where latitude &gt; 43;</span><br><span class="line">sqlite&gt; select name, &quot;is cold!&quot; from cold;</span><br><span class="line">Minneapolis|is cold!</span><br></pre></td></tr></table></figure>
<p><strong>Order Clauses.</strong> A <code>select</code> statement can also express an ordering over the resulting table. An <code>order</code>clause contains an ordering expression that is evaluated for each unfiltered row. The resulting values of this expression are used as a sorting criterion for the result table.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select distance, name from distances order by -distance;</span><br><span class="line">84|Minneapolis</span><br><span class="line">48|Cambridge</span><br><span class="line">0|Berkeley</span><br></pre></td></tr></table></figure>
<p>The combination of these features allows a <code>select</code> statement to express a wide range of projections of an input table into a related output table.</p>
<h3 id="4-3-3-Joins"><a href="#4-3-3-Joins" class="headerlink" title="4.3.3  Joins"></a>4.3.3  Joins</h3><p>Databases typically contain multiple tables, and queries can require information contained within different tables to compute a desired result. For instance, we may have a second table describing the mean daily high temperature of different cities.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table temps as</span><br><span class="line">   ...&gt;   select &quot;Berkeley&quot; as city, 68 as temp union</span><br><span class="line">   ...&gt;   select &quot;Chicago&quot;         , 59         union</span><br><span class="line">   ...&gt;   select &quot;Minneapolis&quot;     , 55;</span><br></pre></td></tr></table></figure>
<p>Data are combined by <em>joining</em> multiple tables together into one, a fundamental operation in database systems. There are many methods of joining, all closely related, but we will focus on just one method in this text. When tables are joined, the resulting table contains a new row for each combination of rows in the input tables. If two tables are joined and the left table has mm rows and the right table has nn rows, then the joined table will have m⋅nm⋅n rows. Joins are expressed in SQL by separating table names by commas in the <code>from</code> clause of a <code>select</code> statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select * from cities, temps;</span><br><span class="line">38|122|Berkeley|Berkeley|68</span><br><span class="line">38|122|Berkeley|Chicago|59</span><br><span class="line">38|122|Berkeley|Minneapolis|55</span><br><span class="line">42|71|Cambridge|Berkeley|68</span><br><span class="line">42|71|Cambridge|Chicago|59</span><br><span class="line">42|71|Cambridge|Minneapolis|55</span><br><span class="line">45|93|Minneapolis|Berkeley|68</span><br><span class="line">45|93|Minneapolis|Chicago|59</span><br><span class="line">45|93|Minneapolis|Minneapolis|55</span><br></pre></td></tr></table></figure>
<p>Joins are typically accompanied by a <code>where</code> clause that expresses a relationship between the two tables. For example, if we wanted to collect data into a table that would allow us to correlate latitude and temperature, we would select rows from the join where the same city is mentioned in each. Within the <code>cities</code> table, the city name is stored in a column called <code>name</code>. Within the <code>temps</code> table, the city name is stored in a column called <code>city</code>. The <code>where</code> clause can select for rows in the joined table in which these values are equal. In SQL, numeric equality is tested with a single <code>=</code> symbol.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select name, latitude, temp from cities, temps where name &#x3D; city;</span><br><span class="line">Berkeley|38|68</span><br><span class="line">Minneapolis|45|55</span><br></pre></td></tr></table></figure>
<p>Tables may have overlapping column names, and so we need a method for disambiguating column names by table. A table may also be joined with itself, and so we need a method for disambiguating tables. To do so, SQL allows us to give aliases to tables within a <code>from</code> clause using the keyword <code>as</code> and to refer to a column within a particular table using a dot expression. The following <code>select</code> statement computes the temperature difference between pairs of unequal cities. The alphabetical ordering constraint in the <code>where</code> clause ensures that each pair will only appear once in the result.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select a.city, b.city, a.temp - b.temp</span><br><span class="line">   ...&gt;        from temps as a, temps as b where a.city &lt; b.city;</span><br><span class="line">Berkeley|Chicago|10</span><br><span class="line">Berkeley|Minneapolis|15</span><br><span class="line">Chicago|Minneapolis|5</span><br></pre></td></tr></table></figure>
<p>Our two means of combining tables in SQL, join and union, allow for a great deal of expressive power in the language.</p>
<h3 id="4-3-4-Aggregation-and-Grouping"><a href="#4-3-4-Aggregation-and-Grouping" class="headerlink" title="4.3.4  Aggregation and Grouping"></a>4.3.4  Aggregation and Grouping</h3><p>The <code>select</code> statements introduced so far can join, project, and manipulate individual rows. In addition, a <code>select</code> statement can perform aggregation operations over multiple rows. The aggregate functions <code>max</code>,<code>min</code>, <code>count</code>, and <code>sum</code> return the maximum, minimum, number, and sum of the values in a column. Multiple aggregate functions can be applied to the same set of rows by defining more than one column. Only columns that are included by the <code>where</code> clause are considered in the aggreagation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table animals as</span><br><span class="line">  ....&gt;   select &quot;dog&quot; as name, 4 as legs, 20 as weight union</span><br><span class="line">  ....&gt;   select &quot;cat&quot;        , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;ferret&quot;     , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;t-rex&quot;      , 2        , 12000        union</span><br><span class="line">  ....&gt;   select &quot;penguin&quot;    , 2        , 10           union</span><br><span class="line">  ....&gt;   select &quot;bird&quot;       , 2        , 6;</span><br><span class="line">sqlite&gt; select max(legs) from animals;</span><br><span class="line">4</span><br><span class="line">sqlite&gt; select sum(weight) from animals;</span><br><span class="line">12056</span><br><span class="line">sqlite&gt; select min(legs), max(weight) from animals where name &lt;&gt; &quot;t-rex&quot;;</span><br><span class="line">2|20</span><br></pre></td></tr></table></figure>
<p>The <code>distinct</code> keyword ensures that no repeated values in a column are included in the aggregation. Only two distinct values of <code>legs</code> appear in the <code>animals</code> table. The special <code>count(*)</code> syntax counts the number of rows.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select count(legs) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(*) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(distinct legs) from animals;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Each of these <code>select</code> statements has produced a table with a single row. The <code>group by</code> and <code>having</code>clauses of a <code>select</code> statement are used to partition rows into groups and select only a subset of the groups. Any aggregate functions in the <code>having</code> clause or column description will apply to each group independently, rather than the entire set of rows in the table.</p>
<p>For example, to compute the maximum weight of both a four-legged and a two-legged animal from this table, the first statement below groups together dogs and cats as one group and birds as a separate group. The result indicates that the maximum weight for a two-legged animal is 3 (the bird) and for a four-legged animal is 20 (the dog). The second query lists the values in the <code>legs</code> column for which there are at least two distinct names.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select legs, max(weight) from animals group by legs;</span><br><span class="line">2|12000</span><br><span class="line">4|20</span><br><span class="line">sqlite&gt; select weight from animals group by weight having count(*)&gt;1;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>Multiple columns and full expressions can appear in the <code>group by</code> clause, and groups will be formed for every unique combination of values that result. Typically, the expression used for grouping also appears in the column description, so that it is easy to identify which result row resulted from each group.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select max(name) from animals group by legs, weight order by name;</span><br><span class="line">bird</span><br><span class="line">dog</span><br><span class="line">ferret</span><br><span class="line">penguin</span><br><span class="line">t-rex</span><br><span class="line">sqlite&gt; select max(name), legs, weight from animals group by legs, weight</span><br><span class="line">  ....&gt;   having max(weight) &lt; 100;</span><br><span class="line">bird|2|6</span><br><span class="line">penguin|2|10</span><br><span class="line">ferret|4|10</span><br><span class="line">dog|4|20</span><br><span class="line">sqlite&gt; select count(*), weight&#x2F;legs from animals group by weight&#x2F;legs;</span><br><span class="line">2|2</span><br><span class="line">1|3</span><br><span class="line">2|5</span><br><span class="line">1|6000</span><br></pre></td></tr></table></figure>
<p>A <code>having</code> clause can contain the same filtering as a <code>where</code> clause, but can also include calls to aggregate functions. For the fastest execution and clearest use of the language, a condition that filters individual rows based on their contents should appear in a <code>where</code> clause, while a <code>having</code> clause should be used only when aggregation is required in the condition (such as specifying a minimum <code>count</code> for a group).</p>
<p>When using a <code>group by</code> clause, column descriptions can contain expressions that do not aggregate. In some cases, the SQL interpreter will choose the value from a row that corresponds to another column that includes aggregation. For example, the following statement gives the <code>name</code> of an animal with maximal<code>weight</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select name, max(weight) from animals;</span><br><span class="line">t-rex|12000</span><br><span class="line">sqlite&gt; select name, legs, max(weight) from animals group by legs;</span><br><span class="line">t-rex|2|12000</span><br><span class="line">dog|4|20</span><br></pre></td></tr></table></figure>
<p>However, whenever the row that corresponds to aggregation is unclear (for instance, when aggregating with <code>count</code> instead of <code>max</code>), the value chosen may be arbitrary. For the clearest and most predictable use of the language, a <code>select</code> statement that includes a <code>group by</code> clause should include at least one aggregate column and only include non-aggregate columns if their contents is predictable from the aggregation.</p>
<h3 id="4-3-5-Create-Table-and-Drop-Table"><a href="#4-3-5-Create-Table-and-Drop-Table" class="headerlink" title="4.3.5  Create Table and Drop Table"></a>4.3.5  Create Table and Drop Table</h3><p>The <code>create table</code> statement creates a new table in our database. As we saw earlier, we can combine the <code>create table</code> statement with the <code>select</code> statement to give a name to an existing table, but we can also use the <code>create table</code> statement along with a list of column names to create an empty table. For each column, we can optionally include the <code>unique</code> keyword, which indicates that the column can only contain unique values, or the <code>default</code> keyword, which gives a default value for an item in the column. For the entire <code>create table</code> statement, including the optional <code>if not exists</code> clause will prevent an error if we attempt to create duplicate tables.</p>
<p>The <code>drop table</code> statement deletes a table from our database. Including the optional <code>if exists</code> clause will prevent an error if we attempt to drop a non-existing table.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table primes (n, prime);</span><br><span class="line">sqlite&gt; drop table primes;</span><br><span class="line">sqlite&gt; drop table if exists primes;</span><br><span class="line">sqlite&gt; create table primes (n unique, prime default 1);</span><br><span class="line">sqlite&gt; create table if not exists primes (n, prime);</span><br></pre></td></tr></table></figure>
<h3 id="4-3-6-Modifying-Tables"><a href="#4-3-6-Modifying-Tables" class="headerlink" title="4.3.6  Modifying Tables"></a>4.3.6  Modifying Tables</h3><p>The <code>insert into</code> statement allows us to add rows to a table in our database. In particular, we can insert values into all columns of our table, or we can add to one specific column, which will set the other columns to their default values. By combining the <code>insert into</code> and <code>select</code> statements, we can add the rows of an existing table to our table.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; insert into primes values (2, 1), (3, 1);</span><br><span class="line">sqlite&gt; select * from primes;</span><br><span class="line">2|1</span><br><span class="line">3|1</span><br><span class="line">sqlite&gt; insert into primes(n) values (4), (5);</span><br><span class="line">sqlite&gt; select * from primes;</span><br><span class="line">2|1</span><br><span class="line">3|1</span><br><span class="line">4|1</span><br><span class="line">5|1</span><br><span class="line">sqlite&gt; insert into primes(n) select n + 4 from primes;</span><br><span class="line">sqlite&gt; select * from primes;</span><br><span class="line">2|1</span><br><span class="line">3|1</span><br><span class="line">4|1</span><br><span class="line">5|1</span><br><span class="line">6|1</span><br><span class="line">7|1</span><br><span class="line">8|1</span><br><span class="line">9|1</span><br></pre></td></tr></table></figure>
<p>The <code>update</code> statement sets all entries in certain columns of a table to new values for a subset of rows as indicated by an optional <code>where</code> clause. We can update all rows by omitting the optional <code>where</code> clause.</p>
<p>The <code>delete from</code> statement deletes a subset of rows of a table as indicated by an optional <code>where</code> clause. If we do not include a <code>where</code> clause, then we will delete all rows, but an empty table would remain in our database.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; update primes set prime &#x3D; 0 where n &gt; 2 and n % 2 &#x3D; 0;</span><br><span class="line">sqlite&gt; update primes set prime &#x3D; 0 where n &gt; 3 and n % 3 &#x3D; 0;</span><br><span class="line">sqlite&gt; select * from primes;</span><br><span class="line">2|1</span><br><span class="line">3|1</span><br><span class="line">4|0</span><br><span class="line">5|1</span><br><span class="line">6|0</span><br><span class="line">7|1</span><br><span class="line">8|0</span><br><span class="line">9|0</span><br><span class="line">sqlite&gt; delete from primes where prime &#x3D; 0;</span><br><span class="line">sqlite&gt; select * from primes;</span><br><span class="line">2|1</span><br><span class="line">3|1</span><br><span class="line">5|1</span><br><span class="line">7|1</span><br></pre></td></tr></table></figure>
<h2 id="4-4-Logic-Programming"><a href="#4-4-Logic-Programming" class="headerlink" title="4.4  Logic Programming"></a>4.4  Logic Programming</h2><p>In this section, we introduce a declarative query language called <code>logic</code>, designed specifically for this text. It is based upon <a href="http://en.wikipedia.org/wiki/Prolog" target="_blank" rel="noopener">Prolog</a> and the declarative language in <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.1" target="_blank" rel="noopener">Structure and Interpretation of Computer Programs</a>. Data records are expressed as Scheme lists, and queries are expressed as Scheme values. The <a href="http://composingprograms.com/examples/logic/logic.py.html" target="_blank" rel="noopener">logic</a> interpreter is a complete implementation that depends upon the Scheme project of the previous chapter.</p>
<h3 id="4-4-1-Facts-and-Queries"><a href="#4-4-1-Facts-and-Queries" class="headerlink" title="4.4.1  Facts and Queries"></a>4.4.1  Facts and Queries</h3><p>Databases store records that represent facts in the system. The purpose of the query interpreter is to retrieve collections of facts drawn directly from database records, as well as to deduce new facts from the database using logical inference. A <code>fact</code> statement in the <code>logic</code> language consists of one or more lists following the keyword <code>fact</code>. A simple fact is a single list. A dog breeder with an interest in U.S. Presidents might record the genealogy of her collection of dogs using the <code>logic</code> language as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (parent abraham barack))</span><br><span class="line">(fact (parent abraham clinton))</span><br><span class="line">(fact (parent delano herbert))</span><br><span class="line">(fact (parent fillmore abraham))</span><br><span class="line">(fact (parent fillmore delano))</span><br><span class="line">(fact (parent fillmore grover))</span><br><span class="line">(fact (parent eisenhower fillmore))</span><br></pre></td></tr></table></figure>
<p>Each fact is not a procedure application, as in a Scheme expression, but instead a <em>relation</em> that is declared. “The dog Abraham is the parent of Barack,” declares the first fact. Relation types do not need to be defined in advance. Relations are not applied, but instead matched to queries.</p>
<p>A query also consists of one or more lists, but begins with the keyword <code>query</code>. A query may contain variables, which are symbols that begin with a question mark. Variables are matched to facts by the query interpreter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (parent abraham ?child))</span><br></pre></td></tr></table></figure>
<p>Success!<br>child: barack<br>child: clinton</p>
<p>The query interpreter responds with <code>Success!</code> to indicate that the query matches some fact. The following lines show substitutions of the variable <code>?child</code> that match the query to the facts in the database.</p>
<p><strong>Compound facts.</strong> Facts may also contain variables as well as multiple sub-expressions. A multi-expression fact begins with a conclusion, followed by hypotheses. For the conclusion to be true, all of the hypotheses must be satisfied:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact &lt;conclusion&gt; &lt;hypothesis0&gt; &lt;hypothesis1&gt; ... &lt;hypothesisN&gt;)</span><br></pre></td></tr></table></figure>
<p>For example, facts about children can be declared based on the facts about parents already in the database:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (child ?c ?p) (parent ?p ?c))</span><br></pre></td></tr></table></figure>
<p>The fact above can be read as: “<code>?c</code> is the child of <code>?p</code>, provided that <code>?p</code> is the parent of <code>?c</code>.” A query can now refer to this fact:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (child ?child fillmore))</span><br></pre></td></tr></table></figure>
<p>Success!<br>child: abraham<br>child: delano<br>child: grover</p>
<p>The query above requires the query interpreter to combine the fact that defines <code>child</code> with the various parent facts about <code>fillmore</code>. The user of the language does not need to know how this information is combined, but only that the result has a particular form. It is up to the query interpreter to prove that <code>(child abraham fillmore)</code> is true, given the available facts.</p>
<p>A query is not required to include variables; it may simply verify a fact:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (child herbert delano))</span><br></pre></td></tr></table></figure>
<p>Success!</p>
<p>A query that does not match any facts will return failure:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (child eisenhower ?parent))</span><br></pre></td></tr></table></figure>
<p>Failed.</p>
<p><strong>Negation.</strong> We can check if some query does not match any fact by using the special keyword <code>not</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (not &lt;relation&gt;))</span><br></pre></td></tr></table></figure>
<p>This query succeeds if <code>fails, and fails if</code> succeeds. This idea is known as <em>negation as failure</em>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (not (parent abraham clinton)))</span><br></pre></td></tr></table></figure>
<p>Failed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (not (parent abraham barack)))</span><br></pre></td></tr></table></figure>
<p>Failed.</p>
<p>Sometimes, negation as failure may be counterintuitive to how one might expect negation to work. Think about the result of the following query:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(query (not (parent abraham ?who)))</span><br></pre></td></tr></table></figure>
<p>Why does this query fail? Surely there are many symbols that could be bound to <code>?who</code> for which this should hold. However, the steps for negation indicate that we first inspect the relation <code>(parent abraham ?who)</code>. This relation succeeds, since <code>?who</code> can be bound to either <code>barack</code> or <code>clinton</code>. Because this relation succeeds, the negation of this relation must fail.</p>
<h3 id="4-4-2-Recursive-Facts"><a href="#4-4-2-Recursive-Facts" class="headerlink" title="4.4.2  Recursive Facts"></a>4.4.2  Recursive Facts</h3><p>The <code>logic</code> language also allows recursive facts. That is, the conclusion of a fact may depend upon a hypothesis that contains the same symbols. For instance, the ancestor relation is defined with two facts. Some <code>?a</code> is an ancestor of <code>?y</code> if it is a parent of <code>?y</code> or if it is the parent of an ancestor of <code>?y</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (ancestor ?a ?y) (parent ?a ?y))</span><br><span class="line">(fact (ancestor ?a ?y) (parent ?a ?z) (ancestor ?z ?y))</span><br></pre></td></tr></table></figure>
<p>A single query can then list all ancestors of <code>herbert</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (ancestor ?a herbert))</span><br></pre></td></tr></table></figure>
<p>Success!<br>a: delano<br>a: fillmore<br>a: eisenhower</p>
<p><strong>Compound queries.</strong> A query may have multiple subexpressions, in which case all must be satisfied simultaneously by an assignment of symbols to variables. If a variable appears more than once in a query, then it must take the same value in each context. The following query finds ancestors of both <code>herbert</code> and <code>barack</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (ancestor ?a barack) (ancestor ?a herbert))</span><br></pre></td></tr></table></figure>
<p>Success!<br>a: fillmore<br>a: eisenhower</p>
<p>Recursive facts may require long chains of inference to match queries to existing facts in a database. For instance, to prove the fact <code>(ancestor fillmore herbert)</code>, we must prove each of the following facts in succession:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(parent delano herbert)       ; (1), a simple fact</span><br><span class="line">(ancestor delano herbert)     ; (2), from (1) and the 1st ancestor fact</span><br><span class="line">(parent fillmore delano)      ; (3), a simple fact</span><br><span class="line">(ancestor fillmore herbert)   ; (4), from (2), (3), &amp; the 2nd ancestor fact</span><br></pre></td></tr></table></figure>
<p>In this way, a single fact can imply a large number of additional facts, or even infinitely many, as long as the query interpreter is able to discover them.</p>
<p><strong>Hierarchical facts.</strong> Thus far, each fact and query expression has been a list of symbols. In addition, fact and query lists can contain lists, providing a way to represent hierarchical data. The color of each dog may be stored along with the name an additional record:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (dog (name abraham) (color white)))</span><br><span class="line">(fact (dog (name barack) (color tan)))</span><br><span class="line">(fact (dog (name clinton) (color white)))</span><br><span class="line">(fact (dog (name delano) (color white)))</span><br><span class="line">(fact (dog (name eisenhower) (color tan)))</span><br><span class="line">(fact (dog (name fillmore) (color brown)))</span><br><span class="line">(fact (dog (name grover) (color tan)))</span><br><span class="line">(fact (dog (name herbert) (color brown)))</span><br></pre></td></tr></table></figure>
<p>Queries can articulate the full structure of hierarchical facts, or they can match variables to whole lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (dog (name clinton) (color ?color)))</span><br></pre></td></tr></table></figure>
<p>Success!<br>color: white</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (dog (name clinton) ?info))</span><br></pre></td></tr></table></figure>
<p>Success!<br>info: (color white)</p>
<p>Much of the power of a database lies in the ability of the query interpreter to join together multiple kinds of facts in a single query. The following query finds all pairs of dogs for which one is the ancestor of the other and they share a color:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (dog (name ?name) (color ?color))</span><br><span class="line">       (ancestor ?ancestor ?name)</span><br><span class="line">       (dog (name ?ancestor) (color ?color)))</span><br></pre></td></tr></table></figure>
<p>Success!<br>name: barack    color: tan    ancestor: eisenhower<br>name: clinton    color: white    ancestor: abraham<br>name: grover    color: tan    ancestor: eisenhower<br>name: herbert    color: brown    ancestor: fillmore</p>
<p>Variables can refer to lists in hierarchical records, but also using dot notation. A variable following a dot matches the rest of the list of a fact. Dotted lists can appear in either facts or queries. The following example constructs pedigrees of dogs by listing their chain of ancestry. Young <code>barack</code> follows a venerable line of presidential pups:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (pedigree ?name) (dog (name ?name) . ?details))</span><br><span class="line">(fact (pedigree ?child ?parent . ?rest)</span><br><span class="line">      (parent ?parent ?child)</span><br><span class="line">      (pedigree ?parent . ?rest))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(query (pedigree barack . ?lineage))</span><br></pre></td></tr></table></figure>
<p>Success!<br>lineage: ()<br>lineage: (abraham)<br>lineage: (abraham fillmore)<br>lineage: (abraham fillmore eisenhower)</p>
<p>Declarative or logical programming can express relationships among facts with remarkable efficiency. For example, if we wish to express that two lists can append to form a longer list with the elements of the first, followed by the elements of the second, we state two rules. First, a base case declares that appending an empty list to any list gives that list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (append-to-form () ?x ?x))</span><br></pre></td></tr></table></figure>
<p>Second, a recursive fact declares that a list with first element <code>?a</code> and rest <code>?r</code> appends to a list <code>?y</code> to form a list with first element <code>?a</code> and some appended rest <code>?z</code>. For this relation to hold, it must be the case that <code>?r</code> and <code>?y</code> append to form <code>?z</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(fact (append-to-form (?a . ?r) ?y (?a . ?z)) (append-to-form ?r ?y ?z))</span><br></pre></td></tr></table></figure>
<p>Using these two facts, the query interpreter can compute the result of appending any two lists together:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (append-to-form (a b c) (d e) ?result))</span><br></pre></td></tr></table></figure>
<p>Success!<br>result: (a b c d e)</p>
<p>In addition, it can compute all possible pairs of lists <code>?left</code> and <code>?right</code> that can append to form the list <code>(a b c d e)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (append-to-form ?left ?right (a b c d e)))</span><br></pre></td></tr></table></figure>
<p>Success!<br>left: ()    right: (a b c d e)<br>left: (a)    right: (b c d e)<br>left: (a b)    right: (c d e)<br>left: (a b c)    right: (d e)<br>left: (a b c d)    right: (e)<br>left: (a b c d e)    right: ()</p>
<p>Although it may appear that our query interpreter is quite intelligent, we will see that it finds these combinations through one simple operation repeated many times: that of matching two lists that contain variables in an environment.</p>
<h2 id="4-5-Unification"><a href="#4-5-Unification" class="headerlink" title="4.5  Unification"></a>4.5  Unification</h2><p>This section describes an implementation of the query interpreter that performs inference in the <code>logic</code>language. The interpreter is a general problem solver, but has substantial limitations on the scale and type of problems it can solve. More sophisticated logical programming languages exist, but the construction of efficient inference procedures remains an active research topic in computer science.</p>
<p>The fundamental operation performed by the query interpreter is called <em>unification</em>. Unification is a general method of matching a query to a fact, each of which may contain variables. The query interpreter applies this operation repeatedly, first to match the original query to conclusions of facts, and then to match the hypotheses of facts to other conclusions in the database. In doing so, the query interpreter performs a search through the space of all facts related to a query. If it finds a way to support that query with an assignment of values to variables, it returns that assignment as a successful result.</p>
<h3 id="4-5-1-Pattern-Matching"><a href="#4-5-1-Pattern-Matching" class="headerlink" title="4.5.1  Pattern Matching"></a>4.5.1  Pattern Matching</h3><p>In order to return simple facts that match a query, the interpreter must match a query that contains variables with a fact that does not. For example, the query <code>(query (parent abraham ?child))</code> and the fact <code>(fact (parent abraham barack))</code> match, if the variable <code>?child</code> takes the value <code>barack</code>.</p>
<p>In general, a pattern matches some expression (a possibly nested Scheme list) if there is a binding of variable names to values such that substituting those values into the pattern yields the expression.</p>
<p>For example, the expression <code>((a b) c (a b))</code> matches the pattern <code>(?x c ?x)</code> with variable <code>?x</code> bound to value <code>(a b)</code>. The same expression matches the pattern <code>((a ?y) ?z (a b))</code> with variable <code>?y</code> bound to <code>b</code>and <code>?z</code> bound to <code>c</code>.</p>
<h3 id="4-5-2-Representing-Facts-and-Queries"><a href="#4-5-2-Representing-Facts-and-Queries" class="headerlink" title="4.5.2  Representing Facts and Queries"></a>4.5.2  Representing Facts and Queries</h3><p>The following examples can be replicated by importing the provided <a href="http://composingprograms.com/examples/logic/logic.py.html" target="_blank" rel="noopener">logic</a> example program.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from logic import *</span><br></pre></td></tr></table></figure>
<p>Both queries and facts are represented as Scheme lists in the logic language, using the same <code>Pair</code> class and <code>nil</code> object in the previous chapter. For example, the query expression <code>(?x c ?x)</code> is represented as nested <code>Pair</code> instances.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; read_line(&quot;(?x c ?x)&quot;)</span><br><span class="line">Pair(&#39;?x&#39;, Pair(&#39;c&#39;, Pair(&#39;?x&#39;, nil)))</span><br></pre></td></tr></table></figure>
<p>As in the Scheme project, an environment that binds symbols to values is represented with an instance of the <code>Frame</code> class, which has an attribute called <code>bindings</code>.</p>
<p>The function that performs pattern matching in the <code>logic</code> language is called <code>unify</code>. It takes two inputs, <code>e</code>and <code>f</code>, as well as an environment <code>env</code> that records the bindings of variables to values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e &#x3D; read_line(&quot;((a b) c (a b))&quot;)</span><br><span class="line">&gt;&gt;&gt; f &#x3D; read_line(&quot;(?x c ?x)&quot;)</span><br><span class="line">&gt;&gt;&gt; env &#x3D; Frame(None)</span><br><span class="line">&gt;&gt;&gt; unify(e, f, env)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; env.bindings</span><br><span class="line">&#123;&#39;?x&#39;: Pair(&#39;a&#39;, Pair(&#39;b&#39;, nil))&#125;</span><br><span class="line">&gt;&gt;&gt; print(env.lookup(&#39;?x&#39;))</span><br><span class="line">(a b)</span><br></pre></td></tr></table></figure>
<p>Above, the return value of <code>True</code> from <code>unify</code> indicates that the pattern <code>f</code> was able to match the expression <code>e</code>. The result of unification is recorded in the binding in <code>env</code> of <code>?x</code> to <code>(a b)</code>.</p>
<h3 id="4-5-3-The-Unification-Algorithm"><a href="#4-5-3-The-Unification-Algorithm" class="headerlink" title="4.5.3  The Unification Algorithm"></a>4.5.3  The Unification Algorithm</h3><p>Unification is a generalization of pattern matching that attempts to find a mapping between two expressions that may both contain variables. The <code>unify</code> function implements unification via a recursive process, which performs unification on corresponding parts of two expressions until a contradiction is reached or a viable binding to all variables can be established.</p>
<p>Let us begin with an example. The pattern <code>(?x ?x)</code> can match the pattern <code>((a ?y c) (a b ?z))</code>because there is an expression with no variables that matches both: <code>((a b c) (a b c))</code>. Unification identifies this solution via the following steps:</p>
<ol>
<li>To match the first element of each pattern, the variable <code>?x</code> is bound to the expression <code>(a ?y c)</code>.</li>
<li>To match the second element of each pattern, first the variable <code>?x</code> is replaced by its value. Then, <code>(a ?y c)</code> is matched to <code>(a b ?z)</code> by binding <code>?y</code> to <code>b</code> and <code>?z</code> to <code>c</code>.</li>
</ol>
<p>As a result, the bindings placed in the environment passed to <code>unify</code> contain entries for <code>?x</code>, <code>?y</code>, and <code>?z</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e &#x3D; read_line(&quot;(?x ?x)&quot;)</span><br><span class="line">&gt;&gt;&gt; f &#x3D; read_line(&quot; ((a ?y c) (a b ?z))&quot;)</span><br><span class="line">&gt;&gt;&gt; env &#x3D; Frame(None)</span><br><span class="line">&gt;&gt;&gt; unify(e, f, env)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; env.bindings</span><br><span class="line">&#123;&#39;?z&#39;: &#39;c&#39;, &#39;?y&#39;: &#39;b&#39;, &#39;?x&#39;: Pair(&#39;a&#39;, Pair(&#39;?y&#39;, Pair(&#39;c&#39;, nil)))&#125;</span><br></pre></td></tr></table></figure>
<p>The result of unification may bind a variable to an expression that also contains variables, as we see above with <code>?x</code> bound to <code>(a ?y c)</code>. The <code>bind</code> function recursively and repeatedly binds all variables to their values in an expression until no bound variables remain.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(bind(e, env))</span><br><span class="line">((a b c) (a b c))</span><br></pre></td></tr></table></figure>
<p>In general, unification proceeds by checking several conditions. The implementation of <code>unify</code> directly follows the description below.</p>
<ol>
<li>Both inputs <code>e</code> and <code>f</code> are replaced by their values if they are variables.</li>
<li>If <code>e</code> and <code>f</code> are equal, unification succeeds.</li>
<li>If <code>e</code> is a variable, unification succeeds and <code>e</code> is bound to <code>f</code>.</li>
<li>If <code>f</code> is a variable, unification succeeds and <code>f</code> is bound to <code>e</code>.</li>
<li>If neither is a variable, both are not lists, and they are not equal, then <code>e</code> and <code>f</code> cannot be unified, and so unification fails.</li>
<li>If none of these cases holds, then <code>e</code> and <code>f</code> are both pairs, and so unification is performed on both their first and second corresponding elements.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def unify(e, f, env):</span><br><span class="line">        &quot;&quot;&quot;Destructively extend ENV so as to unify (make equal) e and f, returning</span><br><span class="line">        True if this succeeds and False otherwise.  ENV may be modified in either</span><br><span class="line">        case (its existing bindings are never changed).&quot;&quot;&quot;</span><br><span class="line">        e &#x3D; lookup(e, env)</span><br><span class="line">        f &#x3D; lookup(f, env)</span><br><span class="line">        if e &#x3D;&#x3D; f:</span><br><span class="line">            return True</span><br><span class="line">        elif isvar(e):</span><br><span class="line">            env.define(e, f)</span><br><span class="line">            return True</span><br><span class="line">        elif isvar(f):</span><br><span class="line">            env.define(f, e)</span><br><span class="line">            return True</span><br><span class="line">        elif scheme_atomp(e) or scheme_atomp(f):</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return unify(e.first, f.first, env) and unify(e.second, f.second, env)</span><br></pre></td></tr></table></figure>
<h3 id="4-5-4-Proofs"><a href="#4-5-4-Proofs" class="headerlink" title="4.5.4  Proofs"></a>4.5.4  Proofs</h3><p>One way to think about the <code>logic</code> language is as a prover of assertions in a formal system. Each stated fact establishes an axiom in a formal system, and each query must be established by the query interpreter from these axioms. That is, each query asserts that there is some assignment to its variables such that all of its sub-expressions simultaneously follow from the facts of the system. The role of the query interpreter is to verify that this is so.</p>
<p>For instance, given the set of facts about dogs, we may assert that there is some common ancestor of Clinton and a tan dog. The query interpreter only outputs <code>Success!</code> if it is able to establish that this assertion is true. As a byproduct, it informs us of the name of that common ancestor and the tan dog:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(query (ancestor ?a clinton)</span><br><span class="line">       (ancestor ?a ?brown-dog)</span><br><span class="line">       (dog (name ?brown-dog) (color brown)))</span><br></pre></td></tr></table></figure>
<p>Success!<br>a: fillmore    brown-dog: herbert<br>a: eisenhower    brown-dog: fillmore<br>a: eisenhower    brown-dog: herbert</p>
<p>Each of the three assignments shown in the result is a trace of a larger proof that the query is true given the facts. A full proof would include all of the facts that were used, for instance including <code>(parent abraham clinton)</code> and <code>(parent fillmore abraham)</code>.</p>
<h3 id="4-5-5-Search"><a href="#4-5-5-Search" class="headerlink" title="4.5.5  Search"></a>4.5.5  Search</h3><p>In order to establish a query from the facts already established in the system, the query interpreter performs a search in the space of all possible facts. Unification is the primitive operation that pattern matches two expressions. The <em>search procedure</em> in a query interpreter chooses what expressions to unify in order to find a set of facts that chain together to establishes the query.</p>
<p>The recursive <code>search</code> function implements the search procedure for the <code>logic</code> language. It takes as input the Scheme list of <code>clauses</code> in the query, an environment <code>env</code> containing current bindings of symbols to values (initially empty), and the <code>depth</code> of the chain of rules that have been chained together already.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def search(clauses, env, depth):</span><br><span class="line">        &quot;&quot;&quot;Search for an application of rules to establish all the CLAUSES,</span><br><span class="line">        non-destructively extending the unifier ENV.  Limit the search to</span><br><span class="line">        the nested application of DEPTH rules.&quot;&quot;&quot;</span><br><span class="line">        if clauses is nil:</span><br><span class="line">            yield env</span><br><span class="line">        elif DEPTH_LIMIT is None or depth &lt;&#x3D; DEPTH_LIMIT:</span><br><span class="line">            if clauses.first.first in (&#39;not&#39;, &#39;~&#39;):</span><br><span class="line">                clause &#x3D; ground(clauses.first.second, env)</span><br><span class="line">                try:</span><br><span class="line">                    next(search(clause, glob, 0))</span><br><span class="line">                except StopIteration:</span><br><span class="line">                    env_head &#x3D; Frame(env)</span><br><span class="line">                    for result in search(clauses.second, env_head, depth+1):</span><br><span class="line">                        yield result</span><br><span class="line">            else:</span><br><span class="line">                for fact in facts:</span><br><span class="line">                    fact &#x3D; rename_variables(fact, get_unique_id())</span><br><span class="line">                    env_head &#x3D; Frame(env)</span><br><span class="line">                    if unify(fact.first, clauses.first, env_head):</span><br><span class="line">                        for env_rule in search(fact.second, env_head, depth+1):</span><br><span class="line">                            for result in search(clauses.second, env_rule, depth+1):</span><br><span class="line">                                yield result</span><br></pre></td></tr></table></figure>
<p>The search to satisfy all clauses simultaneously begins with the first clause. In the special case where our first clause is negated, rather than trying to unify the first clause of the query with a fact, we check that there is no such unification possible through a recursive call to <code>search</code>. If this recursive call yields nothing, we continue the search process with the rest of our clauses. If unification is possible, we fail immediately.</p>
<p>If our first clause is not negated, then for each fact in the database, <code>search</code> attempts to unify the first clause of the fact with the first clause of the query. Unification is performed in a new environment <code>env_head</code>. As a side effect of unification, variables are bound to values in <code>env_head</code>.</p>
<p>If unification is successful, then the clause matches the conclusion of the current rule. The following <code>for</code>statement attempts to establish the hypotheses of the rule, so that the conclusion can be established. It is here that the hypotheses of a recursive rule would be passed recursively to <code>search</code> in order to be established.</p>
<p>Finally, for every successful search of <code>fact.second</code>, the resulting environment is bound to <code>env_rule</code>. Given these bindings of values to variables, the final <code>for</code> statement searches to establish the rest of the clauses in the initial query. Any successful result is returned via the inner <code>yield</code> statement.</p>
<p><strong>Unique names.</strong> Unification assumes that no variable is shared among both <code>e</code> and <code>f</code>. However, we often reuse variable names in the facts and queries of the <code>logic</code> language. We would not like to confuse an <code>?x</code>in one fact with an <code>?x</code> in another; these variables are unrelated. To ensure that names are not confused, before a fact is passed into unify, its variable names are replaced by unique names using <code>rename_variables</code> by appending a unique integer for the fact.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def rename_variables(expr, n):</span><br><span class="line">        &quot;&quot;&quot;Rename all variables in EXPR with an identifier N.&quot;&quot;&quot;</span><br><span class="line">        if isvar(expr):</span><br><span class="line">            return expr + &#39;_&#39; + str(n)</span><br><span class="line">        elif scheme_pairp(expr):</span><br><span class="line">            return Pair(rename_variables(expr.first, n),</span><br><span class="line">                        rename_variables(expr.second, n))</span><br><span class="line">        else:</span><br><span class="line">            return expr</span><br></pre></td></tr></table></figure>
<p>The remaining details, including the user interface to the <code>logic</code> language and the definition of various helper functions, appears in the <a href="http://composingprograms.com/examples/logic/logic.py.html" target="_blank" rel="noopener">logic</a> example.</p>
<h2 id="4-6-Distributed-Computing"><a href="#4-6-Distributed-Computing" class="headerlink" title="4.6  Distributed Computing"></a>4.6  Distributed Computing</h2><p>Large-scale data processing applications often coordinate effort among multiple computers. A distributed computing application is one in which multiple interconnected but independent computers coordinate to perform a joint computation.</p>
<p>Different computers are independent in the sense that they do not directly share memory. Instead, they communicate with each other using <em>messages</em>, information transferred from one computer to another over a network.</p>
<h3 id="4-6-1-Messages"><a href="#4-6-1-Messages" class="headerlink" title="4.6.1  Messages"></a>4.6.1  Messages</h3><p>Messages sent between computers are sequences of bytes. The purpose of a message varies; messages can request data, send data, or instruct another computer to evaluate a procedure call. In all cases, the sending computer must encode information in a way that the receiving computer can decode and correctly interpret. To do so, computers adopt a message protocol that endows meaning to sequences of bytes.</p>
<p>A <em>message protocol</em> is a set of rules for encoding and interpreting messages. Both the sending and receiving computers must agree on the semantics of a message to enable successful communication. Many message protocols specify that a message conform to a particular format in which certain bits at fixed positions indicate fixed conditions. Others use special bytes or byte sequences to delimit parts of the message, much as punctuation delimits sub-expressions in the syntax of a programming language.</p>
<p>Message protocols are not particular programs or software libraries. Instead, they are rules that can be applied by a variety of programs, even written in different programming languages. As a result, computers with vastly different software systems can participate in the same distributed system, simply by conforming to the message protocols that govern the system.</p>
<p><strong>The TCP/IP Protocols</strong>. On the Internet, messages are transferred from one machine to another using the <a href="http://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener">Internet Protocol</a> (IP), which specifies how to transfer <em>packets</em> of data among different networks to allow global Internet communication. IP was designed under the assumption that networks are inherently unreliable at any point and dynamic in structure. Moreover, it does not assume that any central tracking or monitoring of communication exists. Each packet contains a header containing the destination IP address, along with other information. All packets are forwarded throughout the network toward the destination using simple routing rules on a best-effort basis.</p>
<p>This design imposes constraints on communication. Packets transferred using modern IP implementations (IPv4 and IPv6) have a maximum size of 65,535 bytes. Larger data values must be split among multiple packets. The IP does not guarantee that packets will be received in the same order that they were sent. Some packets may be lost, and some packets may be transmitted multiple times.</p>
<p>The <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol</a> is an abstraction defined in terms of the IP that provides reliable, ordered transmission of arbitrarily large byte streams. The protocol provides this guarantee by correctly ordering packets transferred by the IP, removing duplicates, and requesting retransmission of lost packets. This improved reliability comes at the expense of latency, the time required to send a message from one point to another.</p>
<p>The TCP breaks a stream of data into <em>TCP segments</em>, each of which includes a portion of the data preceded by a header that contains sequence and state information to support reliable, ordered transmission of data. Some TCP segments do not include data at all, but instead establish or terminate a connection between two computers.</p>
<p>Establishing a connection between two computers <code>A</code> and <code>B</code> proceeds in three steps:</p>
<ol>
<li><code>A</code> sends a request to a <em>port</em> of <code>B</code> to establish a TCP connection, providing a <em>port number</em> to which to send the response.</li>
<li><code>B</code> sends a response to the port specified by <code>A</code> and waits for its response to be acknowledged.</li>
<li><code>A</code> sends an acknowledgment response, verifying that data can be transferred in both directions.</li>
</ol>
<p>After this three-step “handshake”, the TCP connection is established, and <code>A</code> and <code>B</code> can send data to each other. Terminating a TCP connection proceeds as a sequence of steps in which both the client and server request and acknowledge the end of the connection.</p>
<h3 id="4-6-2-Client-Server-Architecture"><a href="#4-6-2-Client-Server-Architecture" class="headerlink" title="4.6.2  Client/Server Architecture"></a>4.6.2  Client/Server Architecture</h3><p>The client/server architecture is a way to dispense a service from a central source. A <em>server</em> provides a service and multiple <em>clients</em> communicate with the server to consume that service. In this architecture, clients and servers have different roles. The server’s role is to respond to service requests from clients, while a client’s role is to issue requests and make use of the server’s response in order to perform some task. The diagram below illustrates the architecture.</p>
<p><img src="http://composingprograms.com/img/clientserver.png" alt="img"></p>
<p>The most influential use of the model is the modern World Wide Web. When a web browser displays the contents of a web page, several programs running on independent computers interact using the client/server architecture. This section describes the process of requesting a web page in order to illustrate central ideas in client/server distributed systems.</p>
<p><strong>Roles</strong>. The web browser application on a Web user’s computer has the role of the client when requesting a web page. When requesting the content from a domain name on the Internet, such as www.nytimes.com, it must communicate with at least two different servers.</p>
<p>The client first requests the Internet Protocol (IP) address of the computer located at that name from a Domain Name Server (DNS). A DNS provides the service of mapping domain names to IP addresses, which are numerical identifiers of machines on the Internet. Python can make such a request directly using the <code>socket</code> module.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from socket import gethostbyname</span><br><span class="line">&gt;&gt;&gt; gethostbyname(&#39;www.nytimes.com&#39;)</span><br><span class="line">&#39;170.149.172.130&#39;</span><br></pre></td></tr></table></figure>
<p>The client then requests the contents of the web page from the web server located at that IP address. The response in this case is an <a href="http://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a> document that contains headlines and article excerpts of the day’s news, as well as expressions that indicate how the web browser client should lay out that contents on the user’s screen. Python can make the two requests required to retrieve this content using the<code>urllib.request</code> module.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.request import urlopen</span><br><span class="line">&gt;&gt;&gt; response &#x3D; urlopen(&#39;http:&#x2F;&#x2F;www.nytimes.com&#39;).read()</span><br><span class="line">&gt;&gt;&gt; response[:15]</span><br><span class="line">b&#39;&lt;!DOCTYPE html&gt;&#39;</span><br></pre></td></tr></table></figure>
<p>Upon receiving this response, the browser issues additional requests for images, videos, and other auxiliary components of the page. These requests are initiated because the original HTML document contains addresses of additional content and a description of how they embed into the page.</p>
<p><strong>An HTTP Request</strong>. The Hypertext Transfer Protocol (HTTP) is a protocol implemented using TCP that governs communication for the World Wide Web (WWW). It assumes a client/server architecture between a web browser and a web server. HTTP specifies the format of messages exchanged between browsers and servers. All web browsers use the HTTP format to request pages from a web server, and all web servers use the HTTP format to send back their responses.</p>
<p>HTTP requests have several types, the most common of which is a <code>GET</code> request for a specific web page. A <code>GET</code> request specifies a location. For instance, typing the address <code>http://en.wikipedia.org/wiki/UC_Berkeley</code> into a web browser issues an HTTP <code>GET</code> request to port 80 of the web server at <code>en.wikipedia.org</code> for the contents at location <code>/wiki/UC_Berkeley</code>.</p>
<p>The server sends back an HTTP response:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Mon, 23 May 2011 22:38:34 GMT</span><br><span class="line">Server: Apache&#x2F;1.3.3.7 (Unix) (Red-Hat&#x2F;Linux)</span><br><span class="line">Last-Modified: Wed, 08 Jan 2011 23:11:55 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line">... web page content ...</span><br></pre></td></tr></table></figure>
<p>On the first line, the text <code>200 OK</code> indicates that there were no errors in responding to the request. The subsequent lines of the header give information about the server, the date, and the type of content being sent back.</p>
<p>If you have typed in a wrong web address, or clicked on a broken link, you may have seen a message such as this error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">404 Error File Not Found</span><br></pre></td></tr></table></figure>
<p>It means that the server sent back an HTTP header that started:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 404 Not Found</span><br></pre></td></tr></table></figure>
<p>The numbers 200 and 404 are HTTP response codes. A fixed set of response codes is a common feature of a message protocol. Designers of protocols attempt to anticipate common messages that will be sent via the protocol and assign fixed codes to reduce transmission size and establish a common message semantics. In the HTTP protocol, the 200 response code indicates success, while 404 indicates an error that a resource was not found. A variety of other <a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">response codes</a> exist in the HTTP 1.1 standard as well.</p>
<p><strong>Modularity</strong>. The concepts of <em>client</em> and <em>server</em> are powerful abstractions. A server provides a service, possibly to multiple clients simultaneously, and a client consumes that service. The clients do not need to know the details of how the service is provided, or how the data they are receiving is stored or calculated, and the server does not need to know how its responses are going to be used.</p>
<p>On the web, we think of clients and servers as being on different machines, but even systems on a single machine can have client/server architectures. For example, signals from input devices on a computer need to be generally available to programs running on the computer. The programs are clients, consuming mouse and keyboard input data. The operating system’s device drivers are the servers, taking in physical signals and serving them up as usable input. In addition, the central processing unit (CPU) and the specialized graphical processing unit (GPU) often participate in a client/server architecture with the CPU as the client and the GPU as a server of images.</p>
<p>A drawback of client/server systems is that the server is a single point of failure. It is the only component with the ability to dispense the service. There can be any number of clients, which are interchangeable and can come and go as necessary.</p>
<p>Another drawback of client-server systems is that computing resources become scarce if there are too many clients. Clients increase the demand on the system without contributing any computing resources.</p>
<h3 id="4-6-3-Peer-to-Peer-Systems"><a href="#4-6-3-Peer-to-Peer-Systems" class="headerlink" title="4.6.3  Peer-to-Peer Systems"></a>4.6.3  Peer-to-Peer Systems</h3><p>The client/server model is appropriate for service-oriented situations. However, there are other computational goals for which a more equal division of labor is a better choice. The term <em>peer-to-peer</em> is used to describe distributed systems in which labor is divided among all the components of the system. All the computers send and receive data, and they all contribute some processing power and memory. As a distributed system increases in size, its capacity of computational resources increases. In a peer-to-peer system, all components of the system contribute some processing power and memory to a distributed computation.</p>
<p>Division of labor among all participants is the identifying characteristic of a peer-to-peer system. This means that peers need to be able to communicate with each other reliably. In order to make sure that messages reach their intended destinations, peer-to-peer systems need to have an organized network structure. The components in these systems cooperate to maintain enough information about the locations of other components to send messages to intended destinations.</p>
<p>In some peer-to-peer systems, the job of maintaining the health of the network is taken on by a set of specialized components. Such systems are not pure peer-to-peer systems, because they have different types of components that serve different functions. The components that support a peer-to-peer network act like scaffolding: they help the network stay connected, they maintain information about the locations of different computers, and they help newcomers take their place within their neighborhood.</p>
<p>The most common applications of peer-to-peer systems are data transfer and data storage. For data transfer, each computer in the system contributes to send data over the network. If the destination computer is in a particular computer’s neighborhood, that computer helps send data along. For data storage, the data set may be too large to fit on any single computer, or too valuable to store on just a single computer. Each computer stores a small portion of the data, and there may be multiple copies of the same data spread over different computers. When a computer fails, the data that was on it can be restored from other copies and put back when a replacement arrives.</p>
<p>Skype, the voice- and video-chat service, is an example of a data transfer application with a peer-to-peer architecture. When two people on different computers are having a Skype conversation, their communications are transmitted through a peer-to-peer network. This network is composed of other computers running the Skype application. Each computer knows the location of a few other computers in its neighborhood. A computer helps send a packet to its destination by passing it on a neighbor, which passes it on to some other neighbor, and so on, until the packet reaches its intended destination. Skype is not a pure peer-to-peer system. A scaffolding network of <em>supernodes</em> is responsible for logging-in and logging-out users, maintaining information about the locations of their computers, and modifying the network structure when users enter and exit.</p>
<h2 id="4-7-Distributed-Data-Processing"><a href="#4-7-Distributed-Data-Processing" class="headerlink" title="4.7  Distributed Data Processing"></a>4.7  Distributed Data Processing</h2><p>Distributed systems are often used to collect, access, and manipulate large data sets. For example, the database systems described earlier in the chapter can operate over datasets that are stored across multiple machines. No single machine may contain the data necessary to respond to a query, and so communication is required to service requests.</p>
<p>This section investigates a typical big data processing scenario in which a data set too large to be processed by a single machine is instead distributed among many machines, each of which process a portion of the dataset. The result of processing must often be aggregated across machines, so that results from one machine’s computation can be combined with others. To coordinate this distributed data processing, we will discuss a programming framework called <a href="http://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">MapReduce</a>.</p>
<p>Creating a distributed data processing application with MapReduce combines many of the ideas presented throughout this text. An application is expressed in terms of pure functions that are used to <em>map</em> over a large dataset and then to <em>reduce</em> the mapped sequences of values into a final result.</p>
<p>Familiar concepts from functional programming are used to maximal advantage in a MapReduce program. MapReduce requires that the functions used to map and reduce the data be pure functions. In general, a program expressed only in terms of pure functions has considerable flexibility in how it is executed. Sub-expressions can be computed in arbitrary order and in parallel without affecting the final result. A MapReduce application evaluates many pure functions in parallel, reordering computations to be executed efficiently in a distributed system.</p>
<p>The principal advantage of MapReduce is that it enforces a separation of concerns between two parts of a distributed data processing application:</p>
<ol>
<li>The map and reduce functions that process data and combine results.</li>
<li>The communication and coordination between machines.</li>
</ol>
<p>The coordination mechanism handles many issues that arise in distributed computing, such as machine failures, network failures, and progress monitoring. While managing these issues introduces some complexity in a MapReduce application, none of that complexity is exposed to the application developer. Instead, building a MapReduce application only requires specifying the map and reduce functions in (1) above; the challenges of distributed computation are hidden via abstraction.</p>
<h3 id="4-7-1-MapReduce"><a href="#4-7-1-MapReduce" class="headerlink" title="4.7.1  MapReduce"></a>4.7.1  MapReduce</h3><p>The MapReduce framework assumes as input a large, unordered stream of input values of an arbitrary type. For instance, each input may be a line of text in some vast corpus. Computation proceeds in three steps.</p>
<ol>
<li>A map function is applied to each input, which outputs zero or more intermediate key-value pairs of an arbitrary type.</li>
<li>All intermediate key-value pairs are grouped by key, so that pairs with the same key can be reduced together.</li>
<li>A reduce function combines the values for a given key <code>k</code>; it outputs zero or more values, which are each associated with <code>k</code> in the final output.</li>
</ol>
<p>To perform this computation, the MapReduce framework creates tasks (perhaps on different machines) that perform various roles in the computation. A <em>map task</em> applies the map function to some subset of the input data and outputs intermediate key-value pairs. A <em>reduce</em> task sorts and groups key-value pairs by key, then applies the reduce function to the values for each key. All communication between map and reduce tasks is handled by the framework, as is the task of grouping intermediate key-value pairs by key.</p>
<p>In order to utilize multiple machines in a MapReduce application, multiple mappers run in parallel in a <em>map phase</em>, and multiple reducers run in parallel in a <em>reduce phase</em>. In between these phases, the <em>sort phase</em> groups together key-value pairs by sorting them, so that all key-value pairs with the same key are adjacent.</p>
<p>Consider the problem of counting the vowels in a corpus of text. We can solve this problem using the MapReduce framework with an appropriate choice of map and reduce functions. The map function takes as input a line of text and outputs key-value pairs in which the key is a vowel and the value is a count. Zero counts are omitted from the output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def count_vowels(line):</span><br><span class="line">    &quot;&quot;&quot;A map function that counts the vowels in a line.&quot;&quot;&quot;</span><br><span class="line">    for vowel in &#39;aeiou&#39;:</span><br><span class="line">        count &#x3D; line.count(vowel)</span><br><span class="line">        if count &gt; 0:</span><br><span class="line">            emit(vowel, count)</span><br></pre></td></tr></table></figure>
<p>The reduce function is the built-in sum functions in Python, which takes as input an iterator over values (all values for a given key) and returns their sum.</p>
<h3 id="4-7-2-Local-Implementation"><a href="#4-7-2-Local-Implementation" class="headerlink" title="4.7.2  Local Implementation"></a>4.7.2  Local Implementation</h3><p>To specify a MapReduce application, we require an implementation of the MapReduce framework into which we can insert map and reduce functions. In the following section, we will use the open-source <a href="http://en.wikipedia.org/wiki/Hadoop" target="_blank" rel="noopener">Hadoop</a> implementation. In this section, we develop a minimal implementation using built-in tools of the Unix operating system.</p>
<p>The Unix operating system creates an abstraction barrier between user programs and the underlying hardware of a computer. It provides a mechanism for programs to communicate with each other, in particular by allowing one program to consume the output of another. In their seminal text on Unix programming, Kernigham and Pike assert that, “”The power of a system comes more from the relationships among programs than from the programs themselves.”</p>
<p>A Python source file can be converted into a Unix program by adding a comment to the first line indicating that the program should be executed using the Python 3 interpreter. The input to a Unix program is an iterable object called <em>standard input</em> and accessed as <code>sys.stdin</code>. Iterating over this object yields string-valued lines of text. The output of a Unix program is called <em>standard output</em> and accessed as <code>sys.stdout</code>. The built-in <code>print</code> function writes a line of text to standard output. The following Unix program writes each line of its input to its output, in reverse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    print(line.strip(&#39;\n&#39;)[::-1])</span><br></pre></td></tr></table></figure>
<p>If we save this program to a file called <code>rev.py</code>, we can execute it as a Unix program. First, we need to tell the operating system that we have created an executable program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x rev.py</span><br></pre></td></tr></table></figure>
<p>Next, we can pass input into this program. Input to a program can come from another program. This effect is achieved using the <code>|</code> symbol (called “pipe”) which channels the output of the program before the pipe into the program after the pipe. The program <code>nslookup</code> outputs the host name of an IP address (in this case for the New York Times):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup 170.149.172.130 | .&#x2F;rev.py</span><br><span class="line">moc.semityn.www</span><br></pre></td></tr></table></figure>
<p>The <code>cat</code> program outputs the contents of files. Thus, the <code>rev.py</code> program can be used to reverse the contents of the <code>rev.py</code> file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat rev.py | .&#x2F;rev.py</span><br><span class="line">3nohtyp vne&#x2F;nib&#x2F;rsu&#x2F;!#</span><br><span class="line"></span><br><span class="line">sys tropmi</span><br><span class="line"></span><br><span class="line">:nidts.sys ni enil rof</span><br><span class="line">)]1-::[)&#39;n\&#39;(pirts.enil(tnirp</span><br></pre></td></tr></table></figure>
<p>These tools are enough for us to implement a basic MapReduce framework. This version has only a single map task and single reduce task, which are both Unix programs implemented in Python. We run an entire MapReduce application using the following command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat input | .&#x2F;mapper.py | sort | .&#x2F;reducer.py</span><br></pre></td></tr></table></figure>
<p>The <code>mapper.py</code> and <code>reducer.py</code> programs must implement the map function and reduce function, along with some simple input and output behavior. For instance, in order to implement the vowel counting application described above, we would write the following <code>count_vowels_mapper.py</code> program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from mr import emit</span><br><span class="line"></span><br><span class="line">def count_vowels(line):</span><br><span class="line">    &quot;&quot;&quot;A map function that counts the vowels in a line.&quot;&quot;&quot;</span><br><span class="line">    for vowel in &#39;aeiou&#39;:</span><br><span class="line">        count &#x3D; line.count(vowel)</span><br><span class="line">        if count &gt; 0:</span><br><span class="line">            emit(vowel, count)</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    count_vowels(line)</span><br></pre></td></tr></table></figure>
<p>In addition, we would write the following <code>sum_reducer.py</code> program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from mr import values_by_key, emit</span><br><span class="line"></span><br><span class="line">for key, value_iterator in values_by_key(sys.stdin):</span><br><span class="line">    emit(key, sum(value_iterator))</span><br></pre></td></tr></table></figure>
<p>The <a href="http://composingprograms.com/examples/mapreduce/mr.py" target="_blank" rel="noopener">mr module</a> is a companion module to this text that provides the functions <code>emit</code> to emit a key-value pair and <code>group_values_by_key</code> to group together values that have the same key. This module also includes an interface to the Hadoop distributed implementation of MapReduce.</p>
<p>Finally, assume that we have the following input file called <code>haiku.txt</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Google MapReduce</span><br><span class="line">Is a Big Data framework</span><br><span class="line">For batch processing</span><br></pre></td></tr></table></figure>
<p>Local execution using Unix pipes gives us the count of each vowel in the haiku:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat haiku.txt | .&#x2F;count_vowels_mapper.py | sort | .&#x2F;sum_reducer.py</span><br><span class="line">&#39;a&#39;   6</span><br><span class="line">&#39;e&#39;   5</span><br><span class="line">&#39;i&#39;   2</span><br><span class="line">&#39;o&#39;   5</span><br><span class="line">&#39;u&#39;   1</span><br></pre></td></tr></table></figure>
<h3 id="4-7-3-Distributed-Implementation"><a href="#4-7-3-Distributed-Implementation" class="headerlink" title="4.7.3  Distributed Implementation"></a>4.7.3  Distributed Implementation</h3><p><a href="http://en.wikipedia.org/wiki/Hadoop" target="_blank" rel="noopener">Hadoop</a> is the name of an open-source implementation of the MapReduce framework that executes MapReduce applications on a cluster of machines, distributing input data and computation for efficient parallel processing. Its streaming interface allows arbitrary Unix programs to define the map and reduce functions. In fact, our <code>count_vowels_mapper.py</code> and <code>sum_reducer.py</code> can be used directly with a Hadoop installation to compute vowel counts on large text corpora.</p>
<p>Hadoop offers several advantages over our simplistic local MapReduce implementation. The first is speed: map and reduce functions are applied in parallel using different tasks on different machines running simultaneously. The second is fault tolerance: when a task fails for any reason, its result can be recomputed by another task in order to complete the overall computation. The third is monitoring: the framework provides a user interface for tracking the progress of a MapReduce application.</p>
<p>In order to run the vowel counting application using the provided <code>mapreduce.py</code> module, install Hadoop, change the assignment statement of <code>HADOOP</code> to the root of your local installation, copy a collection of text files into the Hadoop distributed file system, and then run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 mr.py run count_vowels_mapper.py sum_reducer.py [input] [output]</span><br></pre></td></tr></table></figure>
<p>where <code>[input]</code> and <code>[output]</code> are directories in the Hadoop file system.</p>
<p>For more information on the Hadoop streaming interface and use of the system, consult the <a href="http://hadoop.apache.org/docs/stable/streaming.html" target="_blank" rel="noopener">Hadoop Streaming Documentation</a>.</p>
<h2 id="4-8-Parallel-Computing"><a href="#4-8-Parallel-Computing" class="headerlink" title="4.8  Parallel Computing"></a>4.8  Parallel Computing</h2><p>From the 1970s through the mid-2000s, the speed of individual processor cores grew at an exponential rate. Much of this increase in speed was accomplished by increasing the <em>clock frequency</em>, the rate at which a processor performs basic operations. In the mid-2000s, however, this exponential increase came to an abrupt end, due to power and thermal constraints, and the speed of individual processor cores has increased much more slowly since then. Instead, CPU manufacturers began to place multiple cores in a single processor, enabling more operations to be performed concurrently.</p>
<p>Parallelism is not a new concept. Large-scale parallel machines have been used for decades, primarily for scientific computing and data analysis. Even in personal computers with a single processor core, operating systems and interpreters have provided the abstraction of concurrency. This is done through<em>context switching</em>, or rapidly switching between different tasks without waiting for them to complete. Thus, multiple programs can run on the same machine concurrently, even if it only has a single processing core.</p>
<p>Given the current trend of increasing the number of processor cores, individual applications must now take advantage of parallelism in order to run faster. Within a single program, computation must be arranged so that as much work can be done in parallel as possible. However, parallelism introduces new challenges in writing correct code, particularly in the presence of shared, mutable state.</p>
<p>For problems that can be solved efficiently in the functional model, with no shared mutable state, parallelism poses few problems. Pure functions provide <em>referential transparency</em>, meaning that expressions can be replaced with their values, and vice versa, without affecting the behavior of a program. This enables expressions that do not depend on each other to be evaluated in parallel. As discussed in the previous section, the MapReduce framework allows functional programs to be specified and run in parallel with minimal programmer effort.</p>
<p>Unfortunately, not all problems can be solved efficiently using functional programming. The Berkeley View project has identified <a href="http://view.eecs.berkeley.edu/wiki/Dwarf_Mine" target="_blank" rel="noopener">thirteen common computational patterns</a> in science and engineering, only one of which is MapReduce. The remaining patterns require shared state.</p>
<p>In the remainder of this section, we will see how mutable shared state can introduce bugs into parallel programs and a number of approaches to prevent such bugs. We will examine these techniques in the context of two applications, a web <a href="http://composingprograms.com/examples/parallel/crawler.py.html" target="_blank" rel="noopener">crawler</a> and a particle <a href="http://composingprograms.com/examples/parallel/particle.py.html" target="_blank" rel="noopener">simulator</a>.</p>
<h3 id="4-8-1-Parallelism-in-Python"><a href="#4-8-1-Parallelism-in-Python" class="headerlink" title="4.8.1  Parallelism in Python"></a>4.8.1  Parallelism in Python</h3><p>Before we dive deeper into the details of parallelism, let us first explore Python’s support for parallel computation. Python provides two means of parallel execution: threading and multiprocessing.</p>
<p><strong>Threading</strong>. In <em>threading</em>, multiple “threads” of execution exist within a single interpreter. Each thread executes code independently from the others, though they share the same data. However, the CPython interpreter, the main implementation of Python, only interprets code in one thread at a time, switching between them in order to provide the illusion of parallelism. On the other hand, operations external to the interpreter, such as writing to a file or accessing the network, may run in parallel.</p>
<p>The <code>threading</code> module contains classes that enable threads to be created and synchronized. The following is a simple example of a multithreaded program:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import threading</span><br><span class="line">&gt;&gt;&gt; def thread_hello():</span><br><span class="line">        other &#x3D; threading.Thread(target&#x3D;thread_say_hello, args&#x3D;())</span><br><span class="line">        other.start()</span><br><span class="line">        thread_say_hello()</span><br><span class="line">&gt;&gt;&gt; def thread_say_hello():</span><br><span class="line">        print(&#39;hello from&#39;, threading.current_thread().name)</span><br><span class="line">&gt;&gt;&gt; thread_hello()</span><br><span class="line">hello from Thread-1</span><br><span class="line">hello from MainThread</span><br></pre></td></tr></table></figure>
<p>The <code>Thread</code> constructor creates a new thread. It requires a target function that the new thread should run, as well as the arguments to that function. Calling <code>start</code> on a <code>Thread</code> object marks it ready to run. The <code>current_thread</code> function returns the <code>Thread</code> object associated with the current thread of execution.</p>
<p>In this example, the prints can happen in any order, since we haven’t synchronized them in any way.</p>
<p><strong>Multiprocessing</strong>. Python also supports <em>multiprocessing</em>, which allows a program to spawn multiple interpreters, or <em>processes</em>, each of which can run code independently. These processes do not generally share data, so any shared state must be communicated between processes. On the other hand, processes execute in parallel according to the level of parallelism provided by the underlying operating system and hardware. Thus, if the CPU has multiple processor cores, Python processes can truly run concurrently.</p>
<p>The <code>multiprocessing</code> module contains classes for creating and synchronizing processes. The following is the hello example using processes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import multiprocessing</span><br><span class="line">&gt;&gt;&gt; def process_hello():</span><br><span class="line">        other &#x3D; multiprocessing.Process(target&#x3D;process_say_hello, args&#x3D;())</span><br><span class="line">        other.start()</span><br><span class="line">        process_say_hello()</span><br><span class="line">&gt;&gt;&gt; def process_say_hello():</span><br><span class="line">        print(&#39;hello from&#39;, multiprocessing.current_process().name)</span><br><span class="line">&gt;&gt;&gt; process_hello()</span><br><span class="line">hello from MainProcess</span><br><span class="line">&gt;&gt;&gt; hello from Process-1</span><br></pre></td></tr></table></figure>
<p>As this example demonstrates, many of the classes and functions in <code>multiprocessing</code> are analogous to those in <code>threading</code>. This example also demonstrates how lack of synchronization affects shared state, as the display can be considered shared state. Here, the interpreter prompt from the interactive process appears before the print output from the other process.</p>
<h3 id="4-8-2-The-Problem-with-Shared-State"><a href="#4-8-2-The-Problem-with-Shared-State" class="headerlink" title="4.8.2  The Problem with Shared State"></a>4.8.2  The Problem with Shared State</h3><p>To further illustrate the problem with shared state, let’s look at a simple example of a counter that is shared between two threads:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">counter &#x3D; [0]</span><br><span class="line"></span><br><span class="line">def increment():</span><br><span class="line">    count &#x3D; counter[0]</span><br><span class="line">    sleep(0) # try to force a switch to the other thread</span><br><span class="line">    counter[0] &#x3D; count + 1</span><br><span class="line"></span><br><span class="line">other &#x3D; threading.Thread(target&#x3D;increment, args&#x3D;())</span><br><span class="line">other.start()</span><br><span class="line">increment()</span><br><span class="line">print(&#39;count is now: &#39;, counter[0])</span><br></pre></td></tr></table></figure>
<p>In this program, two threads attempt to increment the same counter. The CPython interpreter can switch between threads at almost any time. Only the most basic operations are <em>atomic</em>, meaning that they appear to occur instantly, with no switch possible during their evaluation or execution. Incrementing a counter requires multiple basic operations: read the old value, add one to it, and write the new value. The interpreter can switch threads between any of these operations.</p>
<p>In order to show what happens when the interpreter switches threads at the wrong time, we have attempted to force a switch by sleeping for 0 seconds. When this code is run, the interpreter often does switch threads at the <code>sleep</code> call. This can result in the following sequence of operations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread 0                    Thread 1</span><br><span class="line">read counter[0]: 0</span><br><span class="line">                            read counter[0]: 0</span><br><span class="line">calculate 0 + 1: 1</span><br><span class="line">write 1 -&gt; counter[0]</span><br><span class="line">                            calculate 0 + 1: 1</span><br><span class="line">                            write 1 -&gt; counter[0]</span><br></pre></td></tr></table></figure>
<p>The end result is that the counter has a value of 1, even though it was incremented twice! Worse, the interpreter may only switch at the wrong time very rarely, making this difficult to debug. Even with the <code>sleep</code> call, this program sometimes produces a correct count of 2 and sometimes an incorrect count of 1.</p>
<p>This problem arises only in the presence of shared data that may be mutated by one thread while another thread accesses it. Such a conflict is called a <em>race condition</em>, and it is an example of a bug that only exists in the parallel world.</p>
<p>In order to avoid race conditions, shared data that may be mutated and accessed by multiple threads must be protected against concurrent access. For example, if we can ensure that thread 1 only accesses the counter after thread 0 finishes accessing it, or vice versa, we can guarantee that the right result is computed. We say that shared data is <em>synchronized</em> if it is protected from concurrent access. In the next few subsections, we will see multiple mechanisms providing synchronization.</p>
<h3 id="4-8-3-When-No-Synchronization-is-Necessary"><a href="#4-8-3-When-No-Synchronization-is-Necessary" class="headerlink" title="4.8.3  When No Synchronization is Necessary"></a>4.8.3  When No Synchronization is Necessary</h3><p>In some cases, access to shared data need not be synchronized, if concurrent access cannot result in incorrect behavior. The simplest example is read-only data. Since such data is never mutated, all threads will always read the same values regardless when they access the data.</p>
<p>In rare cases, shared data that is mutated may not require synchronization. However, understanding when this is the case requires a deep knowledge of how the interpreter and underlying software and hardware work. Consider the following example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">items &#x3D; []</span><br><span class="line">flag &#x3D; []</span><br><span class="line"></span><br><span class="line">def consume():</span><br><span class="line">    while not flag:</span><br><span class="line">        pass</span><br><span class="line">    print(&#39;items is&#39;, items)</span><br><span class="line"></span><br><span class="line">def produce():</span><br><span class="line">    consumer &#x3D; threading.Thread(target&#x3D;consume, args&#x3D;())</span><br><span class="line">    consumer.start()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        items.append(i)</span><br><span class="line">    flag.append(&#39;go&#39;)</span><br><span class="line"></span><br><span class="line">produce()</span><br></pre></td></tr></table></figure>
<p>Here, the producer thread adds items to <code>items</code>, while the consumer waits until <code>flag</code> is non-empty. When the producer finishes adding items, it adds an element to <code>flag</code>, allowing the consumer to proceed.</p>
<p>In most Python implementations, this example will work correctly. However, a common optimization in other compilers and interpreters, and even the hardware itself, is to reorder operations within a single thread that do not depend on each other for data. In such a system, the statement <code>flag.append(&#39;go&#39;)</code>may be moved before the loop, since neither depends on the other for data. In general, you should avoid code like this unless you are certain that the underlying system won’t reorder the relevant operations.</p>
<h3 id="4-8-4-Synchronized-Data-Structures"><a href="#4-8-4-Synchronized-Data-Structures" class="headerlink" title="4.8.4  Synchronized Data Structures"></a>4.8.4  Synchronized Data Structures</h3><p>The simplest means of synchronizing shared data is to use a data structure that provides synchronized operations. The <code>queue</code> module contains a <code>Queue</code> class that provides synchronized first in, first out access to data. The <code>put</code> method adds an item to the <code>Queue</code>, and the <code>get</code> method retrieves an item. The class itself ensures that these methods are synchronized, so items are not lost no matter how thread operations are interleaved. Here is a producer/consumer example that uses a <code>Queue</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">queue &#x3D; Queue()</span><br><span class="line"></span><br><span class="line">def synchronized_consume():</span><br><span class="line">    while True:</span><br><span class="line">        print(&#39;got an item:&#39;, queue.get())</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line">def synchronized_produce():</span><br><span class="line">    consumer &#x3D; threading.Thread(target&#x3D;synchronized_consume, args&#x3D;())</span><br><span class="line">    consumer.daemon &#x3D; True</span><br><span class="line">    consumer.start()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        queue.put(i)</span><br><span class="line">    queue.join()</span><br><span class="line"></span><br><span class="line">synchronized_produce()</span><br></pre></td></tr></table></figure>
<p>There are a few changes to this code, in addition to the <code>Queue</code> and <code>get</code> and <code>put</code> calls. We have marked the consumer thread as a <em>daemon</em>, which means that the program will not wait for that thread to complete before exiting. This allows us to use an infinite loop in the consumer. However, we do need to ensure that the main thread exits, but only after all items have been consumed from the <code>Queue</code>. The consumer calls the <code>task_done</code> method to inform the <code>Queue</code> that it is done processing an item, and the main thread calls the <code>join</code> method, which waits until all items have been processed, ensuring that the program exits only after that is the case.</p>
<p>A more complex example that makes use of a <code>Queue</code> is a parallel web <a href="http://composingprograms.com/examples/parallel/crawler.py.html" target="_blank" rel="noopener">crawler</a> that searches for dead links on a website. This crawler follows all links that are hosted by the same site, so it must process a number of URLs, continually adding new ones to a <code>Queue</code> and removing URLs for processing. By using a synchronized <code>Queue</code>, multiple threads can safely add to and remove from the data structure concurrently.</p>
<h3 id="4-8-5-Locks"><a href="#4-8-5-Locks" class="headerlink" title="4.8.5  Locks"></a>4.8.5  Locks</h3><p>When a synchronized version of a particular data structure is not available, we have to provide our own synchronization. A <em>lock</em> is a basic mechanism to do so. It can be <em>acquired</em> by at most one thread, after which no other thread may acquire it until it is <em>released</em> by the thread that previously acquired it.</p>
<p>In Python, the <code>threading</code> module contains a <code>Lock</code> class to provide locking. A <code>Lock</code> has <code>acquire</code> and <code>release</code> methods to acquire and release the lock, and the class guarantees that only one thread at a time can acquire it. All other threads that attempt to acquire a lock while it is already being held are forced to wait until it is released.</p>
<p>For a lock to protect a particular set of data, all the threads need to be programmed to follow a rule: no thread will access any of the shared data unless it owns that particular lock. In effect, all the threads need to “wrap” their manipulation of the shared data in <code>acquire</code> and <code>release</code> calls for that lock.</p>
<p>In the parallel web <a href="http://composingprograms.com/examples/parallel/crawler.py.html" target="_blank" rel="noopener">crawler</a>, a set is used to keep track of all URLs that have been encountered by any thread, so as to avoid processing a particular URL more than once (and potentially getting stuck in a cycle). However, Python does not provide a synchronized set, so we must use a lock to protect access to a normal set:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">seen &#x3D; set()</span><br><span class="line">seen_lock &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def already_seen(item):</span><br><span class="line">    seen_lock.acquire()</span><br><span class="line">    result &#x3D; True</span><br><span class="line">    if item not in seen:</span><br><span class="line">        seen.add(item)</span><br><span class="line">        result &#x3D; False</span><br><span class="line">    seen_lock.release()</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p>A lock is necessary here, in order to prevent another thread from adding the URL to the set between this thread checking if it is in the set and adding it to the set. Furthermore, adding to a set is not atomic, so concurrent attempts to add to a set may corrupt its internal data.</p>
<p>In this code, we had to be careful not to return until after we released the lock. In general, we have to ensure that we release a lock when we no longer need it. This can be very error-prone, particularly in the presence of exceptions, so Python provides a <code>with</code> compound statement that handles acquiring and releasing a lock for us:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def already_seen(item):</span><br><span class="line">    with seen_lock:</span><br><span class="line">        if item not in seen:</span><br><span class="line">            seen.add(item)</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<p>The <code>with</code> statement ensures that <code>seen_lock</code> is acquired before its suite is executed and that it is released when the suite is exited for any reason. (The <code>with</code> statement can actually be used for operations other than locking, though we won’t cover alternative uses here.)</p>
<p>Operations that must be synchronized with each other must use the same lock. However, two disjoint sets of operations that must be synchronized only with operations in the same set should use two different lock objects to avoid over-synchronization.</p>
<h3 id="4-8-6-Barriers"><a href="#4-8-6-Barriers" class="headerlink" title="4.8.6  Barriers"></a>4.8.6  Barriers</h3><p>Another way to avoid conflicting access to shared data is to divide a program into phases, ensuring that shared data is mutated in a phase in which no other thread accesses it. A <em>barrier</em> divides a program into phases by requiring all threads to reach it before any of them can proceed. Code that is executed after a barrier cannot be concurrent with code executed before the barrier.</p>
<p>In Python, the <code>threading</code> module provides a barrier in the form of the the <code>wait</code> method of a <code>Barrier</code>instance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">counters &#x3D; [0, 0]</span><br><span class="line">barrier &#x3D; threading.Barrier(2)</span><br><span class="line"></span><br><span class="line">def count(thread_num, steps):</span><br><span class="line">    for i in range(steps):</span><br><span class="line">        other &#x3D; counters[1 - thread_num]</span><br><span class="line">        barrier.wait() # wait for reads to complete</span><br><span class="line">        counters[thread_num] &#x3D; other + 1</span><br><span class="line">        barrier.wait() # wait for writes to complete</span><br><span class="line"></span><br><span class="line">def threaded_count(steps):</span><br><span class="line">    other &#x3D; threading.Thread(target&#x3D;count, args&#x3D;(1, steps))</span><br><span class="line">    other.start()</span><br><span class="line">    count(0, steps)</span><br><span class="line">    print(&#39;counters:&#39;, counters)</span><br><span class="line"></span><br><span class="line">threaded_count(10)</span><br></pre></td></tr></table></figure>
<p>In this example, reading and writing to shared data take place in different phases, separated by barriers. The writes occur in the same phase, but they are disjoint; this disjointness is necessary to avoid concurrent writes to the same data in the same phase. Since this code is properly synchronized, both counters will always be 10 at the end.</p>
<p>The multithreaded particle <a href="http://composingprograms.com/examples/parallel/particle.py.html" target="_blank" rel="noopener">simulator</a> uses a barrier in a similar fashion to synchronize access to shared data. In the simulation, each thread owns a number of particles, all of which interact with each other over the course of many discrete timesteps. A particle has a position, velocity, and acceleration, and a new acceleration is computed in each timestep based on the positions of the other particles. The velocity of the particle must be updated accordingly, and its position according to its velocity.</p>
<p>As with the simple example above, there is a read phase, in which all particles’ positions are read by all threads. Each thread updates its own particles’ acceleration in this phase, but since these are disjoint writes, they need not be synchronized. In the write phase, each thread updates its own particles’ velocities and positions. Again, these are disjoint writes, and they are protected from the read phase by barriers.</p>
<h3 id="4-8-7-Message-Passing"><a href="#4-8-7-Message-Passing" class="headerlink" title="4.8.7  Message Passing"></a>4.8.7  Message Passing</h3><p>A final mechanism to avoid improper mutation of shared data is to entirely avoid concurrent access to the same data. In Python, using multiprocessing rather than threading naturally results in this, since processes run in separate interpreters with their own data. Any state required by multiple processes can be communicated by passing messages between processes.</p>
<p>The <code>Pipe</code> class in the <code>multiprocessing</code> module provides a communication channel between processes. By default, it is duplex, meaning a two-way channel, though passing in the argument <code>False</code> results in a one-way channel. The <code>send</code> method sends an object over the channel, while the <code>recv</code> method receives an object. The latter is <em>blocking</em>, meaning that a process that calls <code>recv</code> will wait until an object is received.</p>
<p>The following is a producer/consumer example using processes and pipes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def process_consume(in_pipe):</span><br><span class="line">    while True:</span><br><span class="line">        item &#x3D; in_pipe.recv()</span><br><span class="line">        if item is None:</span><br><span class="line">            return</span><br><span class="line">        print(&#39;got an item:&#39;, item)</span><br><span class="line"></span><br><span class="line">def process_produce():</span><br><span class="line">    pipe &#x3D; multiprocessing.Pipe(False)</span><br><span class="line">    consumer &#x3D; multiprocessing.Process(target&#x3D;process_consume, args&#x3D;(pipe[0],))</span><br><span class="line">    consumer.start()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pipe[1].send(i)</span><br><span class="line">    pipe[1].send(None) # done signal</span><br><span class="line"></span><br><span class="line">process_produce()</span><br></pre></td></tr></table></figure>
<p>In this example, we use a <code>None</code> message to signal the end of communication. We also passed in one end of the pipe as an argument to the target function when creating the consumer process. This is necessary, since state must be explicitly shared between processes.</p>
<p>The multiprocess version of the particle <a href="http://composingprograms.com/examples/parallel/particle.py.html" target="_blank" rel="noopener">simulator</a> uses pipes to communicate particle positions between processes in each timestep. In fact, it uses pipes to set up an entire circular pipeline between processes, in order to minimize communication. Each process injects its own particles’ positions into its pipeline stage, which eventually go through a full rotation of the pipeline. At each step of the rotation, a process applies forces from the positions that are currently in its own pipeline stage on to its own particles, so that after a full rotation, all forces have been applied to its particles.</p>
<p>The <code>multiprocessing</code> module provides other synchronization mechanisms for processes, including synchronized queues, locks, and as of Python 3.3, barriers. For example, a lock or a barrier can be used to synchronize printing to the screen, avoiding the improper display output we saw previously.</p>
<h3 id="4-8-8-Synchronization-Pitfalls"><a href="#4-8-8-Synchronization-Pitfalls" class="headerlink" title="4.8.8  Synchronization Pitfalls"></a>4.8.8  Synchronization Pitfalls</h3><p>While synchronization methods are effective for protecting shared state, they can also be used incorrectly, failing to accomplish the proper synchronization, over-synchronizing, or causing the program to hang as a result of deadlock.</p>
<p><strong>Under-synchronization</strong>. A common pitfall in parallel computing is to neglect to properly synchronize shared accesses. In the set example, we need to synchronize the membership check and insertion together, so that another thread cannot perform an insertion in between these two operations. Failing to synchronize the two operations together is erroneous, even if they are separately synchronized.</p>
<p><strong>Over-synchronization</strong>. Another common error is to over-synchronize a program, so that non-conflicting operations cannot occur concurrently. As a trivial example, we can avoid all conflicting access to shared data by acquiring a master lock when a thread starts and only releasing it when a thread completes. This serializes our entire code, so that nothing runs in parallel. In some cases, this can even cause our program to hang indefinitely. For example, consider a consumer/producer program in which the consumer obtains the lock and never releases it. This prevents the producer from producing any items, which in turn prevents the consumer from doing anything since it has nothing to consume.</p>
<p>While this example is trivial, in practice, programmers often over-synchronize their code to some degree, preventing their code from taking complete advantage of the available parallelism.</p>
<p><strong>Deadlock</strong>. Because they cause threads or processes to wait on each other, synchronization mechanisms are vulnerable to <em>deadlock</em>, a situation in which two or more threads or processes are stuck, waiting for each other to finish. We have just seen how neglecting to release a lock can cause a thread to get stuck indefinitely. But even if threads or processes do properly release locks, programs can still reach deadlock.</p>
<p>The source of deadlock is a <em>circular wait</em>, illustrated below with processes. No process can continue because it is waiting for other processes that are waiting for it to complete.</p>
<p><img src="http://composingprograms.com/img/deadlock.png" alt="img"></p>
<p>As an example, we will set up a deadlock with two processes. Suppose they share a duplex pipe and attempt to communicate with each other as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def deadlock(in_pipe, out_pipe):</span><br><span class="line">    item &#x3D; in_pipe.recv()</span><br><span class="line">    print(&#39;got an item:&#39;, item)</span><br><span class="line">    out_pipe.send(item + 1)</span><br><span class="line"></span><br><span class="line">def create_deadlock():</span><br><span class="line">    pipe &#x3D; multiprocessing.Pipe()</span><br><span class="line">    other &#x3D; multiprocessing.Process(target&#x3D;deadlock, args&#x3D;(pipe[0], pipe[1]))</span><br><span class="line">    other.start()</span><br><span class="line">    deadlock(pipe[1], pipe[0])</span><br><span class="line"></span><br><span class="line">create_deadlock()</span><br></pre></td></tr></table></figure>
<p>Both processes attempt to receive data first. Recall that the <code>recv</code> method blocks until an item is available. Since neither process has sent anything, both will wait indefinitely for the other to send it data, resulting in deadlock.</p>
<p>Synchronization operations must be properly aligned to avoid deadlock. This may require sending over a pipe before receiving, acquiring multiple locks in the same order, and ensuring that all threads reach the right barrier at the right time.</p>
<h3 id="4-8-9-Conclusion"><a href="#4-8-9-Conclusion" class="headerlink" title="4.8.9  Conclusion"></a>4.8.9  Conclusion</h3><p>As we have seen, parallelism presents new challenges in writing correct and efficient code. As the trend of increasing parallelism at the hardware level will continue for the foreseeable future, parallel computation will become more and more important in application programming. There is a very active body of research on making parallelism easier and less error-prone for programmers. Our discussion here serves only as a basic introduction to this crucial area of computer science.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Programming/" rel="tag"># Programming</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/05/04/2020/Data-Structure/" rel="next" title="Data Structure">
                <i class="fa fa-chevron-left"></i> Data Structure
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="H Yu" />
            
              <p class="site-author-name" itemprop="name">H Yu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            



            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hyu1024" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hyu1024@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-Building-Abstractions-with-Functions"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1: Building Abstractions with Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Getting-Started"><span class="nav-number">1.1.</span> <span class="nav-text">1.1  Getting Started</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-Programming-in-Python"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1  Programming in Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-Installing-Python-3"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2  Installing Python 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-Interactive-Sessions"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3  Interactive Sessions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-First-Example"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4  First Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-Errors"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5  Errors</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Elements-of-Programming"><span class="nav-number">1.2.</span> <span class="nav-text">1.2  Elements of Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-Expressions"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1  Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-Call-Expressions"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2  Call Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-Importing-Library-Functions"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3  Importing Library Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-Names-and-the-Environment"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4  Names and the Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5-Evaluating-Nested-Expressions"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.2.5  Evaluating Nested Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6-The-Non-Pure-Print-Function"><span class="nav-number">1.2.6.</span> <span class="nav-text">1.2.6  The Non-Pure Print Function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Defining-New-Functions"><span class="nav-number">1.3.</span> <span class="nav-text">1.3  Defining New Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-Environments"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1  Environments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-Calling-User-Defined-Functions"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2  Calling User-Defined Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-Example-Calling-a-User-Defined-Function"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3  Example: Calling a User-Defined Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-Local-Names"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4  Local Names</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-Choosing-Names"><span class="nav-number">1.3.5.</span> <span class="nav-text">1.3.5  Choosing Names</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-Functions-as-Abstractions"><span class="nav-number">1.3.6.</span> <span class="nav-text">1.3.6  Functions as Abstractions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-7-Operators"><span class="nav-number">1.3.7.</span> <span class="nav-text">1.3.7  Operators</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Designing-Functions"><span class="nav-number">1.4.</span> <span class="nav-text">1.4  Designing Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-Documentation"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1  Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-Default-Argument-Values"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2  Default Argument Values</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Control"><span class="nav-number">1.5.</span> <span class="nav-text">1.5  Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-Statements"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1  Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-Compound-Statements"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2  Compound Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-Defining-Functions-II-Local-Assignment"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3  Defining Functions II: Local Assignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4-Conditional-Statements"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4  Conditional Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5-Iteration"><span class="nav-number">1.5.5.</span> <span class="nav-text">1.5.5  Iteration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-6-Testing"><span class="nav-number">1.5.6.</span> <span class="nav-text">1.5.6  Testing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-Higher-Order-Functions"><span class="nav-number">1.6.</span> <span class="nav-text">1.6  Higher-Order Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-Functions-as-Arguments"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1  Functions as Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-Functions-as-General-Methods"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2  Functions as General Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-Defining-Functions-III-Nested-Definitions"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3  Defining Functions III: Nested Definitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-Functions-as-Returned-Values"><span class="nav-number">1.6.4.</span> <span class="nav-text">1.6.4  Functions as Returned Values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-5-Example-Newton’s-Method"><span class="nav-number">1.6.5.</span> <span class="nav-text">1.6.5  Example: Newton’s Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-6-Currying"><span class="nav-number">1.6.6.</span> <span class="nav-text">1.6.6  Currying</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-7-Lambda-Expressions"><span class="nav-number">1.6.7.</span> <span class="nav-text">1.6.7  Lambda Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-8-Abstractions-and-First-Class-Functions"><span class="nav-number">1.6.8.</span> <span class="nav-text">1.6.8  Abstractions and First-Class Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-9-Function-Decorators"><span class="nav-number">1.6.9.</span> <span class="nav-text">1.6.9  Function Decorators</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-Recursive-Functions"><span class="nav-number">1.7.</span> <span class="nav-text">1.7  Recursive Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-The-Anatomy-of-Recursive-Functions"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1  The Anatomy of Recursive Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-Mutual-Recursion"><span class="nav-number">1.7.2.</span> <span class="nav-text">1.7.2  Mutual Recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-Printing-in-Recursive-Functions"><span class="nav-number">1.7.3.</span> <span class="nav-text">1.7.3  Printing in Recursive Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-4-Tree-Recursion"><span class="nav-number">1.7.4.</span> <span class="nav-text">1.7.4  Tree Recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-5-Example-Partitions"><span class="nav-number">1.7.5.</span> <span class="nav-text">1.7.5  Example: Partitions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-Building-Abstractions-with-Data"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2: Building Abstractions with Data</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Introduction"><span class="nav-number">2.1.</span> <span class="nav-text">2.1  Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Native-Data-Types"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1  Native Data Types</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Data-Abstraction"><span class="nav-number">2.2.</span> <span class="nav-text">2.2  Data Abstraction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-Example-Rational-Numbers"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1  Example: Rational Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Pairs"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2  Pairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-Abstraction-Barriers"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3  Abstraction Barriers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-The-Properties-of-Data"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4  The Properties of Data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Sequences"><span class="nav-number">2.3.</span> <span class="nav-text">2.3  Sequences</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-Lists"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1  Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-Sequence-Iteration"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2  Sequence Iteration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-Sequence-Processing"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3  Sequence Processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-Sequence-Abstraction"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4  Sequence Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-Strings"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5  Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6-Trees"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6  Trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-7-Linked-Lists"><span class="nav-number">2.3.7.</span> <span class="nav-text">2.3.7  Linked Lists</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Mutable-Data"><span class="nav-number">2.4.</span> <span class="nav-text">2.4  Mutable Data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-The-Object-Metaphor"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1  The Object Metaphor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-Sequence-Objects"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2  Sequence Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-Dictionaries"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3  Dictionaries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-Local-State"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4  Local State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-5-The-Benefits-of-Non-Local-Assignment"><span class="nav-number">2.4.5.</span> <span class="nav-text">2.4.5  The Benefits of Non-Local Assignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-6-The-Cost-of-Non-Local-Assignment"><span class="nav-number">2.4.6.</span> <span class="nav-text">2.4.6  The Cost of Non-Local Assignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-7-Iterators"><span class="nav-number">2.4.7.</span> <span class="nav-text">2.4.7  Iterators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-8-Iterables"><span class="nav-number">2.4.8.</span> <span class="nav-text">2.4.8  Iterables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-9-Built-in-Iterators"><span class="nav-number">2.4.9.</span> <span class="nav-text">2.4.9  Built-in Iterators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-10-Generators"><span class="nav-number">2.4.10.</span> <span class="nav-text">2.4.10  Generators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-11-Implementing-Lists-and-Dictionaries"><span class="nav-number">2.4.11.</span> <span class="nav-text">2.4.11  Implementing Lists and Dictionaries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-12-Dispatch-Dictionaries"><span class="nav-number">2.4.12.</span> <span class="nav-text">2.4.12  Dispatch Dictionaries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-13-Propagating-Constraints"><span class="nav-number">2.4.13.</span> <span class="nav-text">2.4.13  Propagating Constraints</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Object-Oriented-Programming"><span class="nav-number">2.5.</span> <span class="nav-text">2.5  Object-Oriented Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-Objects-and-Classes"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1  Objects and Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-Defining-Classes"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2  Defining Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-Message-Passing-and-Dot-Expressions"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3  Message Passing and Dot Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-Class-Attributes"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4  Class Attributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-5-Inheritance"><span class="nav-number">2.5.5.</span> <span class="nav-text">2.5.5  Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-6-Using-Inheritance"><span class="nav-number">2.5.6.</span> <span class="nav-text">2.5.6  Using Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-7-Multiple-Inheritance"><span class="nav-number">2.5.7.</span> <span class="nav-text">2.5.7  Multiple Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-8-The-Role-of-Objects"><span class="nav-number">2.5.8.</span> <span class="nav-text">2.5.8  The Role of Objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Implementing-Classes-and-Objects"><span class="nav-number">2.6.</span> <span class="nav-text">2.6  Implementing Classes and Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-Instances"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1  Instances</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-Classes"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2  Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-Using-Implemented-Objects"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.6.3  Using Implemented Objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-Object-Abstraction"><span class="nav-number">2.7.</span> <span class="nav-text">2.7  Object Abstraction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-String-Conversion"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1  String Conversion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-Special-Methods"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.7.2  Special Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-Multiple-Representations"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.7.3  Multiple Representations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-Generic-Functions"><span class="nav-number">2.7.4.</span> <span class="nav-text">2.7.4  Generic Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-2Hide-contents"><span class="nav-number">2.7.5.</span> <span class="nav-text">Chapter 2Hide contents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Introduction-1"><span class="nav-number">2.7.6.</span> <span class="nav-text">2.1 Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Data-Abstraction-1"><span class="nav-number">2.7.7.</span> <span class="nav-text">2.2 Data Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Sequences-1"><span class="nav-number">2.7.8.</span> <span class="nav-text">2.3 Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Mutable-Data-1"><span class="nav-number">2.7.9.</span> <span class="nav-text">2.4 Mutable Data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Object-Oriented-Programming-1"><span class="nav-number">2.7.10.</span> <span class="nav-text">2.5 Object-Oriented Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Implementing-Classes-and-Objects-1"><span class="nav-number">2.7.11.</span> <span class="nav-text">2.6 Implementing Classes and Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Object-Abstraction-1"><span class="nav-number">2.7.12.</span> <span class="nav-text">2.7 Object Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-Efficiency"><span class="nav-number">2.7.13.</span> <span class="nav-text">2.8 Efficiency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-Recursive-Objects"><span class="nav-number">2.7.14.</span> <span class="nav-text">2.9 Recursive Objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-Efficiency-1"><span class="nav-number">2.8.</span> <span class="nav-text">2.8  Efficiency</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-Measuring-Efficiency"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1  Measuring Efficiency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-Memoization"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2  Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-Orders-of-Growth"><span class="nav-number">2.8.3.</span> <span class="nav-text">2.8.3  Orders of Growth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-4-Example-Exponentiation"><span class="nav-number">2.8.4.</span> <span class="nav-text">2.8.4  Example: Exponentiation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-5-Growth-Categories"><span class="nav-number">2.8.5.</span> <span class="nav-text">2.8.5  Growth Categories</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-Recursive-Objects-1"><span class="nav-number">2.9.</span> <span class="nav-text">2.9  Recursive Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-1-Linked-List-Class"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.9.1  Linked List Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-2-Tree-Class"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.9.2  Tree Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-3-Sets"><span class="nav-number">2.9.3.</span> <span class="nav-text">2.9.3  Sets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-Interpreting-Computer-Programs"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3: Interpreting Computer Programs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Introduction"><span class="nav-number">3.1.</span> <span class="nav-text">3.1  Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-Programming-Languages"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1  Programming Languages</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Functional-Programming"><span class="nav-number">3.2.</span> <span class="nav-text">3.2  Functional Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-Expressions"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1  Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-Definitions"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2  Definitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-Compound-values"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3  Compound values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-Symbolic-Data"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4  Symbolic Data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-Turtle-graphics"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5  Turtle graphics</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Exceptions"><span class="nav-number">3.3.</span> <span class="nav-text">3.3  Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-Exception-Objects"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1  Exception Objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Interpreters-for-Languages-with-Combination"><span class="nav-number">3.4.</span> <span class="nav-text">3.4  Interpreters for Languages with Combination</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-A-Scheme-Syntax-Calculator"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1  A Scheme-Syntax Calculator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-Expression-Trees"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2  Expression Trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-Parsing-Expressions"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3  Parsing Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-Calculator-Evaluation"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4  Calculator Evaluation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Interpreters-for-Languages-with-Abstraction"><span class="nav-number">3.5.</span> <span class="nav-text">3.5  Interpreters for Languages with Abstraction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-Structure"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1  Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-Environments"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2  Environments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-Data-as-Programs"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3  Data as Programs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-Macros"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.5.4  Macros</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-Quasiquotation"><span class="nav-number">3.5.5.</span> <span class="nav-text">3.5.5  Quasiquotation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-4-Data-Processing"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4: Data Processing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Introduction"><span class="nav-number">4.1.</span> <span class="nav-text">4.1  Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Implicit-Sequences"><span class="nav-number">4.2.</span> <span class="nav-text">4.2  Implicit Sequences</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-Iterators"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1  Iterators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-Iterables"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2  Iterables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-Built-in-Iterators"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3  Built-in Iterators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-For-Statements"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4  For Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-Generators"><span class="nav-number">4.2.5.</span> <span class="nav-text">4.2.5  Generators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-Python-Streams"><span class="nav-number">4.2.6.</span> <span class="nav-text">4.2.6  Python Streams</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Declarative-Programming"><span class="nav-number">4.3.</span> <span class="nav-text">4.3  Declarative Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-Tables"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1  Tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-Select-Statements"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2  Select Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-Joins"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3  Joins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-Aggregation-and-Grouping"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4  Aggregation and Grouping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-Create-Table-and-Drop-Table"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5  Create Table and Drop Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-6-Modifying-Tables"><span class="nav-number">4.3.6.</span> <span class="nav-text">4.3.6  Modifying Tables</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Logic-Programming"><span class="nav-number">4.4.</span> <span class="nav-text">4.4  Logic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-Facts-and-Queries"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1  Facts and Queries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-Recursive-Facts"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2  Recursive Facts</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-Unification"><span class="nav-number">4.5.</span> <span class="nav-text">4.5  Unification</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-Pattern-Matching"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1  Pattern Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-Representing-Facts-and-Queries"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2  Representing Facts and Queries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-The-Unification-Algorithm"><span class="nav-number">4.5.3.</span> <span class="nav-text">4.5.3  The Unification Algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-Proofs"><span class="nav-number">4.5.4.</span> <span class="nav-text">4.5.4  Proofs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5-Search"><span class="nav-number">4.5.5.</span> <span class="nav-text">4.5.5  Search</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-Distributed-Computing"><span class="nav-number">4.6.</span> <span class="nav-text">4.6  Distributed Computing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-Messages"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.6.1  Messages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-Client-Server-Architecture"><span class="nav-number">4.6.2.</span> <span class="nav-text">4.6.2  Client&#x2F;Server Architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-Peer-to-Peer-Systems"><span class="nav-number">4.6.3.</span> <span class="nav-text">4.6.3  Peer-to-Peer Systems</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-Distributed-Data-Processing"><span class="nav-number">4.7.</span> <span class="nav-text">4.7  Distributed Data Processing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-1-MapReduce"><span class="nav-number">4.7.1.</span> <span class="nav-text">4.7.1  MapReduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-2-Local-Implementation"><span class="nav-number">4.7.2.</span> <span class="nav-text">4.7.2  Local Implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-3-Distributed-Implementation"><span class="nav-number">4.7.3.</span> <span class="nav-text">4.7.3  Distributed Implementation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-Parallel-Computing"><span class="nav-number">4.8.</span> <span class="nav-text">4.8  Parallel Computing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-1-Parallelism-in-Python"><span class="nav-number">4.8.1.</span> <span class="nav-text">4.8.1  Parallelism in Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-2-The-Problem-with-Shared-State"><span class="nav-number">4.8.2.</span> <span class="nav-text">4.8.2  The Problem with Shared State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-3-When-No-Synchronization-is-Necessary"><span class="nav-number">4.8.3.</span> <span class="nav-text">4.8.3  When No Synchronization is Necessary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-4-Synchronized-Data-Structures"><span class="nav-number">4.8.4.</span> <span class="nav-text">4.8.4  Synchronized Data Structures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-5-Locks"><span class="nav-number">4.8.5.</span> <span class="nav-text">4.8.5  Locks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-6-Barriers"><span class="nav-number">4.8.6.</span> <span class="nav-text">4.8.6  Barriers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-7-Message-Passing"><span class="nav-number">4.8.7.</span> <span class="nav-text">4.8.7  Message Passing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-8-Synchronization-Pitfalls"><span class="nav-number">4.8.8.</span> <span class="nav-text">4.8.8  Synchronization Pitfalls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-9-Conclusion"><span class="nav-number">4.8.9.</span> <span class="nav-text">4.8.9  Conclusion</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">H Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
